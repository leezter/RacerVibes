<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <title>Top‑Down Racer — Bigger Track + 9 AI + Collisions</title>
    <meta name="theme-color" content="#0a0a0a" />
    <link rel="manifest" href="manifest.webmanifest" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script src="utils/utils.js"></script>
  <script src="ai/mcp_racing_line.js"></script>
  <script src="ai/racing_line_validation.js"></script>
  <script src="ai/racer_ai.js"></script>
  <script src="utils/storage-utils.js"></script>
  <script type="module" src="physics.js"></script>
    <script src="decor_generator.js"></script>
    <script src="track_storage.js"></script>
    <script src="ui/speedometer.js"></script>
    <style>
      :root { --dev-panel-top: 56px; } /* Top offset for dev panels below the Dev menu button */
      html, body, #root { height: 100%; margin: 0; }
  body { background: #0a0a0a; color: #eee; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow:hidden; overscroll-behavior:none; }
      .wrap { display:flex; flex-direction:column; align-items:center; gap:12px; padding:16px; }
  canvas { border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,.6); background: #000; touch-action: none; }
      .subtitle { opacity:.9; font-size: 12px; }
      .note { opacity:.7; font-size: 11px; }
      .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#1f2937; font-size:12px; margin-left:8px; }
      /* Mobile HUD buttons - moved further down */
      .hud { position:fixed; inset:0; pointer-events:none; }
      .btn { position:absolute; width:clamp(48px, 10vw, 72px); height:clamp(48px, 10vw, 72px); border-radius:50%; background:#1f2937a6; color:#fff; display:grid; place-items:center; pointer-events:auto; user-select:none; touch-action:none; -webkit-tap-highlight-color: transparent; font-size:clamp(14px, 4vw, 18px); }
      .btn:active { background:#374151cc; }
      .btn.left  { left:12px; bottom:24px; }
      .btn.right { left:calc(12px + clamp(52px, 11vw, 76px)); bottom:24px; }
      .btn.thr   { right:12px; bottom:calc(24px + clamp(52px, 11vw, 76px)); }
      .btn.brk   { right:12px; bottom:24px; }
  .btn.gyro  { right:12px; top:12px; width:44px; height:32px; border-radius:8px; font-size:11px; }
      @media (min-width: 900px) { .hud { display:none; } }
  .quit-btn { position:fixed; right:12px; bottom:12px; z-index:36; width:44px; height:44px; border-radius:8px; background:rgba(15,23,42,0.96); color:#e2e8f0; display:grid; place-items:center; cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,.45); font-size:18px; }
  .quit-btn:active { transform:translateY(1px); }
      /* Portrait orientation warning */
      .portrait-warning { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(10,10,10,0.94); color:#fff; z-index:10; text-align:center; padding:24px; }
      .portrait-warning .box { max-width:520px; border:1px solid #2a2a2a; border-radius:12px; padding:18px; background:#111; }
      @media (orientation: portrait) { .portrait-warning { display:flex; } }

      /* Dev Menu Dropdown - top left */
      .dev-menu-container { position:fixed; top:12px; left:12px; z-index:40; }
      .dev-menu-toggle { padding:6px 14px; border-radius:8px; border:1px solid rgba(59,130,246,0.45); background:rgba(15,23,42,0.92); color:#e2e8f0; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:6px; }
      .dev-menu-toggle:hover { background:rgba(30,41,59,0.94); }
      .dev-menu-toggle::after { content:'▾'; font-size:10px; }
      .dev-menu-toggle.open::after { content:'▴'; }
      .dev-menu-dropdown { display:none; position:absolute; top:100%; left:0; margin-top:4px; min-width:160px; padding:6px; border-radius:10px; border:1px solid rgba(71,85,105,0.6); background:rgba(15,23,42,0.96); box-shadow:0 12px 32px rgba(15,23,42,0.45); }
      .dev-menu-dropdown.open { display:flex; flex-direction:column; gap:4px; }
      .dev-menu-item { padding:8px 12px; border-radius:6px; border:none; background:transparent; color:#e2e8f0; font-size:12px; cursor:pointer; text-align:left; display:flex; align-items:center; gap:8px; }
      .dev-menu-item:hover { background:rgba(59,130,246,0.25); }
      .dev-menu-item.active { background:rgba(59,130,246,0.35); }
      .dev-menu-item::before { content:''; width:6px; height:6px; border-radius:50%; background:transparent; }
      .dev-menu-item.active::before { background:#38bdf8; }

      /* Hide old individual dev toggle buttons - now in dropdown */
      .dev-toggle { display:none !important; }
      .dev-toggle.ai-toggle { display:none !important; }

      /* Dev panels - positioned from dev menu */
      .dev-panel { position:fixed; top:var(--dev-panel-top); left:12px; width:min(220px, calc(100vw - 24px)); max-height:calc(100vh - 80px); overflow-y:auto; padding:12px; border-radius:12px; border:1px solid rgba(71,85,105,0.6); background:rgba(15,23,42,0.94); color:#e2e8f0; font-size:12px; display:none; gap:10px; box-shadow:0 12px 32px rgba(15,23,42,0.45); z-index:35; }
      .dev-panel.open { display:flex; flex-direction:column; }
      .dev-panel h3 { margin:0 0 4px; font-size:13px; font-weight:600; }
      .dev-panel h4 { margin:8px 0 4px; font-size:12px; font-weight:600; }
      .dev-panel .field { display:grid; grid-template-columns:1fr 56px; align-items:center; gap:6px; }
      .dev-panel label { display:flex; flex-direction:column; gap:4px; font-size:11px; color:#94a3b8; }
      .dev-panel input[type="range"] { width:100%; accent-color:#38bdf8; }
      .dev-panel input[type="number"],
      .dev-panel select { width:100%; padding:3px 5px; border-radius:6px; border:1px solid rgba(148,163,184,0.5); background:#0f172a; color:#e2e8f0; font-size:11px; }
      .dev-panel.ai-panel { width:min(240px, calc(100vw - 24px)); }
      .hud-tip { position:fixed; top:12px; left:50%; transform:translateX(-50%); padding:5px 12px; border-radius:999px; background:rgba(15,23,42,0.92); color:#e2e8f0; font-size:11px; z-index:28; box-shadow:0 8px 20px rgba(15,23,42,0.45); pointer-events:none; }
      
      /* Responsive adjustments for mobile */
      @media (max-width: 600px) {
        .dev-panel { font-size:11px; padding:10px; width:min(200px, calc(100vw - 24px)); }
        .dev-panel h3 { font-size:12px; }
        .dev-panel .field { grid-template-columns:1fr 48px; gap:4px; }
        .dev-panel input[type="number"], .dev-panel select { font-size:10px; padding:2px 4px; }
        .dev-menu-toggle { padding:5px 10px; font-size:11px; }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <!-- Mobile HUD overlay for touch controls -->
    <!-- Portrait orientation guidance -->
    <div class="portrait-warning" aria-live="polite">
      <div class="box">
        <h2 style="margin:0 0 8px; font:700 20px system-ui">Rotate device</h2>
        <p style="margin:0; opacity:.9">This game is best played in landscape. Please rotate your device.</p>
      </div>
    </div>
    <div class="hud" aria-hidden="true">
      <div class="btn left"  title="Left">◄</div>
      <div class="btn right" title="Right">►</div>
      <div class="btn thr"   title="Throttle">▲</div>
      <div class="btn brk"   title="Brake/Reverse">▼</div>
      <div class="btn gyro"   title="Toggle Gyro">GY</div>
    </div>

    <!-- Quit button (bottom-right) -->
    <div id="quitBtn" class="quit-btn" title="Quit to menu" aria-label="Quit to menu">⎋</div>

    <script src="modes/registry.js"></script>
    <script src="modes/grip.js"></script>
    <script type="text/babel" data-presets="env,react">
// Utility: request fullscreen politely
function requestFullscreen(el){
  if (!el) return;
  const anyEl = el;
  try {
    if (anyEl.requestFullscreen) return anyEl.requestFullscreen();
    if (anyEl.webkitRequestFullscreen) return anyEl.webkitRequestFullscreen();
    if (anyEl.msRequestFullscreen) return anyEl.msRequestFullscreen();
  } catch(e) { /* ignore */ }
}

// Compute viewport usable size ignoring mobile URL bar (using visualViewport if available)
function getViewportSize(){
  const vv = window.visualViewport;
  if (vv && vv.width && vv.height) return { w: vv.width, h: vv.height };
  const doc = document.documentElement;
  const vw = (doc && doc.clientWidth) || window.innerWidth || 0;
  const vh = (doc && doc.clientHeight) || window.innerHeight || 0;
  return { w: vw, h: vh };
}

// Quit button handler: navigate back to start menu (delegated click — robust to script timing)
document.addEventListener('click', (e) => {
  try {
    const target = e.target;
    if (!target) return;
    const btn = target.closest ? target.closest('#quitBtn') : null;
    if (btn) {
      window.location.href = 'racer_start_menu.html';
    }
  } catch (_) {}
});
 
// ===== Skid marks =====
let skids = []; // {x1,y1,x2,y2, life}
const SKID_LIFE = 2.2;
const SKID_MAX = 2400;
function addSkid(x1,y1,x2,y2){
  skids.push({x1,y1,x2,y2, life: SKID_LIFE});
  if (skids.length > SKID_MAX) skids.splice(0, skids.length - SKID_MAX);
}
function updateSkids(dt){
  for (let i=skids.length-1;i>=0;i--){
    skids[i].life -= dt;
    if (skids[i].life <= 0) skids.splice(i,1);
  }
}
function drawSkids(ctx){
  if (!skids.length) return;
  ctx.save();
  ctx.lineCap = 'round';
  for (const s of skids){
    const a = Math.max(0, Math.min(1, s.life / SKID_LIFE));
    ctx.globalAlpha = a * 0.55;
    ctx.lineWidth = 2.0;
    ctx.strokeStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.moveTo(s.x1, s.y1);
    ctx.lineTo(s.x2, s.y2);
    ctx.stroke();
  }
  ctx.restore();
}

      
// ===== WebAudio SFX =====
let SFX = null;
let audioPrimed = false;
function primeAudio(){ audioPrimed = true; }
function ensureAudio() {
  if (!audioPrimed) {
    return SFX && SFX.ctx ? SFX : null;
  }
  if (SFX && SFX.ctx && SFX.ctx.state !== 'suspended') return SFX;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioCtx();
    const master = ctx.createGain();
    // Respect saved master volume (stored 0.0 - 1.0 in localStorage as 'masterVolume')
    try {
      const mvRaw = localStorage.getItem('masterVolume');
      const mv = mvRaw === null ? 0.9 : Number(mvRaw);
      master.gain.value = isNaN(mv) ? 0.9 : mv;
    } catch (e) { master.gain.value = 0.9; }
    master.connect(ctx.destination);

    // Engine: two oscillators + mild drive + lowpass "intake" filter
    const engGain = ctx.createGain(); engGain.gain.value = 0.0; engGain.connect(master);
    const engLP = ctx.createBiquadFilter(); engLP.type='lowpass'; engLP.frequency.value=500; engLP.Q.value = 0.7; engLP.connect(engGain);
    const oscA = ctx.createOscillator(); oscA.type='sawtooth'; oscA.frequency.value = 100; oscA.connect(engLP); oscA.start();
    const oscB = ctx.createOscillator(); oscB.type='square';   oscB.frequency.value = 50;  oscB.detune.value = 6; oscB.connect(engLP); oscB.start();

    // Exhaust/wind/skid noise buffers
    function makeNoise(){
      const len = ctx.sampleRate * 2;
      const buf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<len;i++) data[i] = Math.random()*2-1;
      const src = ctx.createBufferSource();
      src.buffer = buf; src.loop = true; return src;
    }

    // Wind (speed hiss)
    const windSrc = makeNoise(); 
    const windHP = ctx.createBiquadFilter(); windHP.type='highpass'; windHP.frequency.value=400;
    const windGain = ctx.createGain(); windGain.gain.value = 0.0;
    windSrc.connect(windHP); windHP.connect(windGain); windGain.connect(master); windSrc.start();

    // Skid (tire squeal)
    const skidSrc = makeNoise();
    const skidBP = ctx.createBiquadFilter(); skidBP.type='bandpass'; skidBP.frequency.value=3800; skidBP.Q.value=3.0;
    const skidGain = ctx.createGain(); skidGain.gain.value = 0.0;
    skidSrc.connect(skidBP); skidBP.connect(skidGain); skidGain.connect(master); skidSrc.start();

    // Grass rumble (lower freq noise)
    const grassSrc = makeNoise();
    const grassBP = ctx.createBiquadFilter(); grassBP.type='bandpass'; grassBP.frequency.value=240; grassBP.Q.value=0.6;
    const grassGain = ctx.createGain(); grassGain.gain.value = 0.0;
    grassSrc.connect(grassBP); grassBP.connect(grassGain); grassGain.connect(master); grassSrc.start();

    function crash(impact){
      // Impact: low thump + metallic ping + noise burst
      const g = ctx.createGain(); g.gain.value = 0.0; g.connect(master);
      // thump
      const th = ctx.createOscillator(); th.type = 'sine'; th.frequency.setValueAtTime(90, ctx.currentTime);
      th.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.12);
      th.connect(g);
      // ping
      const pn = ctx.createOscillator(); pn.type = 'sine'; pn.frequency.setValueAtTime(1400, ctx.currentTime);
      pn.frequency.exponentialRampToValueAtTime(500, ctx.currentTime + 0.25);
      pn.connect(g);
      // burst noise
      const nb = makeNoise(); const nbBP = ctx.createBiquadFilter(); nbBP.type='bandpass'; nbBP.frequency.value=1800; nbBP.Q.value=1.0;
      const nbG = ctx.createGain(); nbG.gain.value = 0.0; nb.connect(nbBP); nbBP.connect(nbG); nbG.connect(master);
      // envelopes
      const a = Math.min(1, 0.15 + impact * 0.8);
      g.gain.linearRampToValueAtTime(a, ctx.currentTime + 0.005);
      g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
      nbG.gain.linearRampToValueAtTime(a*0.6, ctx.currentTime + 0.005);
      nbG.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
      th.start(); pn.start(); nb.start();
      th.stop(ctx.currentTime + 0.35); pn.stop(ctx.currentTime + 0.35); nb.stop(ctx.currentTime + 0.27);
    }

    SFX = { ctx, master, eng:{oscA,oscB,lp:engLP,g:engGain}, wind:{g:windGain}, skid:{g:skidGain}, grass:{g:grassGain}, crash };
    return SFX;
  } catch(e){ console.warn('Audio init failed:', e); return null; }
}

let sfxEnabled = true;
function toggleSFX(){ sfxEnabled = !sfxEnabled; if (SFX) SFX.master.gain.value = sfxEnabled ? 0.9 : 0.0; }
function updateSFX(player, dt){
  if (!sfxEnabled) return;
  const sfx = ensureAudio(); if (!sfx) return;
  const spd = Math.max(0, player.speed||0);
  const throttle = player.sfxThrottle || 0;
  const slip = Math.max(0, Math.min(1, player.sfxSlip || 0));
  const onGrass = !!player.sfxGrass;

  const gb = player && player.gearbox;
  const cfg = gb ? gb.c : (window.GEARBOX_DEFAULTS || {});
  const idle = cfg && cfg.idleRPM ? cfg.idleRPM : 1100;
  const redline = cfg && cfg.redlineRPM ? cfg.redlineRPM : 7600;
  const rpmRaw = player.sfxRPM || idle;
  const rpmClamped = Math.max(idle, Math.min(redline, rpmRaw));
  const pitch = 0.8 + ((rpmClamped - idle) / Math.max(200, redline - idle)) * (1.6 - 0.8);
  const baseFreq = 90;
  const fA = baseFreq * pitch;
  const fB = fA * 0.5;
  sfx.eng.oscA.frequency.setTargetAtTime(fA, sfx.ctx.currentTime, 0.025);
  sfx.eng.oscB.frequency.setTargetAtTime(fB, sfx.ctx.currentTime, 0.025);
  const driveForce = Math.abs(player.sfxDriveForce || 0);
  const engVol = Math.min(0.9, 0.18 + throttle * 0.45 + Math.min(0.35, driveForce * 0.0004));
  sfx.eng.g.gain.setTargetAtTime(engVol, sfx.ctx.currentTime, 0.04);
  sfx.eng.lp.frequency.setTargetAtTime(360 + (pitch - 0.8) / 0.8 * 1200, sfx.ctx.currentTime, 0.05);

  // Wind
  const windVol = Math.min(0.5, spd*0.0025) * 0.12;
  sfx.wind.g.gain.setTargetAtTime(windVol, sfx.ctx.currentTime, 0.08);

  // Skid squeal (depends on slip; quieter on grass)
  const skidVol = (onGrass ? 0.25 : 1.0) * Math.max(0, (slip-0.15)) * 0.9;
  sfx.skid.g.gain.setTargetAtTime(skidVol, sfx.ctx.currentTime, 0.03);

  // Grass rumble
  const grassVol = onGrass ? Math.min(0.6, 0.1 + spd*0.002) : 0.0;
  sfx.grass.g.gain.setTargetAtTime(grassVol, sfx.ctx.currentTime, 0.05);

  // Impact one-shots
  if (player.sfxImpact && player.sfxImpact > 0.05){
    sfx.crash(Math.min(1, player.sfxImpact));
    player.sfxImpact = 0;
  }
}

function playCountdownBeep(freq = 520, duration = 0.45, accent = 1){
  if (!sfxEnabled) return;
  const sfx = ensureAudio();
  if (!sfx || !sfx.ctx) return;
  try {
    const ctx = sfx.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(sfx.master);
    const now = ctx.currentTime;
    const peak = Math.min(0.45, 0.28 * accent);
    gain.gain.linearRampToValueAtTime(peak, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.05);
  } catch (err) {
    console.warn('Countdown beep failed', err);
  }
}
const { useEffect, useRef, useState } = React;
      const START_PAYLOAD_KEY = 'RacingVibesStartPayload';
      const START_PAYLOAD_NAME_PREFIX = 'RacingVibesStart:';

      function readStartPayload(){
        try {
          const storage = window.sessionStorage;
          if (!storage) return null;
          const raw = storage.getItem(START_PAYLOAD_KEY);
          if (!raw) return null;
          const data = JSON.parse(raw);
          if (data && typeof data === 'object') return data;
        } catch (_){ }
        try {
          const nameRaw = window.name || '';
          if (typeof nameRaw === 'string' && nameRaw.startsWith(START_PAYLOAD_NAME_PREFIX)) {
            const json = nameRaw.slice(START_PAYLOAD_NAME_PREFIX.length);
            const data = JSON.parse(json);
            if (data && typeof data === 'object') return data;
          }
        } catch (_){ }
        return null;
      }

      const START_PAYLOAD = readStartPayload();

      function getInitialTrack() {
        if (START_PAYLOAD && typeof START_PAYLOAD.track === 'string') {
          const trimmed = START_PAYLOAD.track.trim();
          if (trimmed) return trimmed;
        }
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = (params.get('track') || '').trim();
          if (!raw) return "Le Mans";
          if (/^custom:/i.test(raw)) return raw;
          const q = raw.toLowerCase();
          const map = { "le mans": "Le Mans", "lemans": "Le Mans", "silverstone": "Silverstone", "kart": "Kart Park", "kart park": "Kart Park", "kartpark": "Kart Park", "park": "Kart Park", "windey": "Windey", "windey clone": "Windey Clone", "windeyclone": "Windey Clone", "windey circuit": "Windey Circuit", "windeycircuit": "Windey Circuit", "night loop": "Night Loop", "nightloop": "Night Loop", "night": "Night Loop" };
          if (map[q]) return map[q];
          return q ? (q[0].toUpperCase() + q.slice(1)) : "Le Mans";
        } catch (e) { return "Le Mans"; }
      }
      const CarProfiles = {
        "F1":    { width: 18, length: 44, colliderWidth: 18, colliderLength: 44, maxK: 1.18, accelK: 1.10, brakeK: 1.05, turnK: 1.20, color: "#d32f2f" },
        "GT":    { width: 24, length: 45, colliderWidth: 20, colliderLength: 39, maxK: 1.00, accelK: 1.00, brakeK: 1.00, turnK: 1.00, color: "#3949ab" },
        "Rally": { width: 18, length: 34, colliderWidth: 18, colliderLength: 34, maxK: 0.95, accelK: 1.05, brakeK: 1.05, turnK: 1.15, color: "#2e7d32" },
        "Truck": { width: 29, length: 60, colliderWidth: 22, colliderLength: 58, maxK: 0.82, accelK: 0.85, brakeK: 0.90, turnK: 0.70, color: "#f97316" }
      };

      const spriteAssets = {};
      function loadSpriteAsset(key, src){
        if (spriteAssets[key]) return spriteAssets[key];
        if (typeof Image === "undefined") return null;
        const img = new Image();
        img.decoding = "async";
        img.src = src;
        img.onerror = (err) => console.warn(`[sprites] ${key} failed to load`, err);
        spriteAssets[key] = img;
        return img;
      }

      const truckSprite = loadSpriteAsset("truck", "assets/vehicles/truck_orange.png");
      const truckSpriteMeta = { sx: 408, sy: 73, sw: 357, sh: 744 };
      const COLLIDER_VIS_STORAGE_KEY = "vehicleColliderOverlay";
      function readColliderOverlaySetting() {
        try {
          return localStorage.getItem(COLLIDER_VIS_STORAGE_KEY) === '1';
        } catch (_) {
          return false;
        }
      }
      function persistColliderOverlaySetting(value) {
        try { localStorage.setItem(COLLIDER_VIS_STORAGE_KEY, value ? '1' : '0'); } catch (_) {}
      }
      let colliderOverlayEnabled = readColliderOverlaySetting();
      function setColliderOverlayEnabled(next) {
        const enabled = !!next;
        if (enabled === colliderOverlayEnabled) return;
        colliderOverlayEnabled = enabled;
        persistColliderOverlaySetting(enabled);
      }
      const clipperSprite = loadSpriteAsset("clipper", "assets/vehicles/ClipperGT.png");
      function getInitialCar() {
        if (START_PAYLOAD && typeof START_PAYLOAD.car === 'string' && CarProfiles[START_PAYLOAD.car]) {
          return START_PAYLOAD.car;
        }
        try {
          const params = new URLSearchParams(window.location.search);
          const q = (params.get('car') || '').trim();
          return CarProfiles[q] ? q : "GT";
        } catch (e) { return "GT"; }
      }

      function getSteeringModeSetting() {
        try {
          const value = localStorage.getItem("steeringMode");
          return value === "manual" ? "manual" : "touch";
        } catch (_) {
          return "touch";
        }
      }

        const SCALE_MIN = 0.5;
        const SCALE_MAX = 3.0;
        const SCALE_STEP = 0.05;
        const SCALE_DEFAULT = 2.5;
      const CAM_BASE_ZOOM = 1.1 * SCALE_DEFAULT; // Compensate for using BASE_WORLD_W instead of scaled world
      const CAMERA_MIN = 0.6;
      const CAMERA_MAX = 1.6;
        const CAMERA_STEP = 0.05;
      const CAMERA_DEFAULT = 1.0;
      const ZOOM_DELTA_MIN = 0;
      const ZOOM_DELTA_MAX = 150;
      const ZOOM_DELTA_STEP = 1;
      const ZOOM_DELTA_DEFAULT = 100;
      const ZOOM_DROP_MIN = 0.15; // minimum raw zoom span
      const ZOOM_DROP_MAX = 1.05; // enables deep zoom-outs at high slider values
      const ZOOM_RAW_MIN_FLOOR = 0.05;
      const ZOOM_RESPONSE_MIN = 0.5;
      const ZOOM_RESPONSE_MAX = 12;
      const ZOOM_RESPONSE_STEP = 0.25;
      const ZOOM_RESPONSE_DEFAULT = 1.25;
      const ZOOM_SPEED_MIN = 0;
      const ZOOM_SPEED_MAX = 200;
      const ZOOM_SPEED_STEP = 1;
      const SPEED_PX_PER_MPH = 30 / 2.23694; // ≈13.4 px/s per mph based on default 30 px/m
      const ZOOM_SPEED_START_DEFAULT = 15;
      const ZOOM_SPEED_FULL_DEFAULT = 89;
      const ZOOM_SPEED_GAP = 5;
      const ZOOM_STORAGE_PREFIX = "cameraZoom_";
      function clampScale(value) {
        return Math.min(SCALE_MAX, Math.max(SCALE_MIN, value));
      }
      function readScale(key, fallback) {
        try {
          const stored = localStorage.getItem(key);
          if (stored === null) return fallback;
          const parsed = parseFloat(stored);
          return Number.isFinite(parsed) ? parsed : fallback;
        } catch(_) {
          return fallback;
        }
      }
      function writeScale(key, value) {
        try { localStorage.setItem(key, String(value)); } catch(_) {}
      }
      function clampCamera(value) {
        return Math.min(CAMERA_MAX, Math.max(CAMERA_MIN, value));
      }
      function readCameraDistance(fallback) {
        try {
          const stored = localStorage.getItem('cameraDistance');
          if (stored === null) return fallback;
          const parsed = parseFloat(stored);
          return Number.isFinite(parsed) ? parsed : fallback;
        } catch(_) {
          return fallback;
        }
      }
      function writeCameraDistance(value) {
        try { localStorage.setItem('cameraDistance', String(value)); } catch(_) {}
      }
      function clampZoomDelta(value) {
        return Math.min(ZOOM_DELTA_MAX, Math.max(ZOOM_DELTA_MIN, value));
      }
      function readZoomDeltaSetting(key, fallbackPercent) {
        const raw = readZoomSetting(key, fallbackPercent);
        if (!Number.isFinite(raw)) return fallbackPercent;
        if (raw <= 1.5) {
          // migrate legacy fraction values (0-1 range)
          return clampZoomDelta(Math.round(raw * 100));
        }
        return clampZoomDelta(raw);
      }
      function resolveZoomSpan(percentValue) {
        const normalized = clampZoomDelta(percentValue) / ZOOM_DELTA_MAX;
        const span = ZOOM_DROP_MIN + normalized * (ZOOM_DROP_MAX - ZOOM_DROP_MIN);
        return Math.max(ZOOM_DROP_MIN, Math.min(ZOOM_DROP_MAX, span));
      }
      function clampZoomResponse(value) {
        return Math.min(ZOOM_RESPONSE_MAX, Math.max(ZOOM_RESPONSE_MIN, value));
      }
      function clampZoomSpeed(value) {
        return Math.min(ZOOM_SPEED_MAX, Math.max(ZOOM_SPEED_MIN, value));
      }
      function mphToPx(speedMph) {
        return Math.max(0, speedMph * SPEED_PX_PER_MPH);
      }
      function pxToMph(pxSpeed) {
        return pxSpeed / SPEED_PX_PER_MPH;
      }
      function readZoomSetting(key, fallback) {
        try {
          const stored = localStorage.getItem(`${ZOOM_STORAGE_PREFIX}${key}`);
          if (stored === null) return fallback;
          const parsed = parseFloat(stored);
          return Number.isFinite(parsed) ? parsed : fallback;
        } catch (_) {
          return fallback;
        }
      }
      function writeZoomSetting(key, value) {
        try { localStorage.setItem(`${ZOOM_STORAGE_PREFIX}${key}`, String(value)); } catch (_) {}
      }
      function readZoomSpeedSetting(key, fallbackMph) {
        const raw = readZoomSetting(key, fallbackMph);
        if (!Number.isFinite(raw)) return fallbackMph;
        if (raw > ZOOM_SPEED_MAX * 2) {
          // backwards compatibility: old px/s values
          return clampZoomSpeed(raw / SPEED_PX_PER_MPH);
        }
        return clampZoomSpeed(raw);
      }
      let GEO_SCALE = clampScale(readScale('geoScale', SCALE_DEFAULT));
      let WIDTH_SCALE = clampScale(readScale('widthScale', SCALE_DEFAULT));
      const ZOOM_INIT = (() => {
        const fullRaw = readZoomSpeedSetting('fullSpeed', ZOOM_SPEED_FULL_DEFAULT);
        const full = Math.max(fullRaw, ZOOM_SPEED_MIN + ZOOM_SPEED_GAP);
        let start = readZoomSpeedSetting('startSpeed', ZOOM_SPEED_START_DEFAULT);
        if (start > full - ZOOM_SPEED_GAP) {
          start = Math.max(ZOOM_SPEED_MIN, full - ZOOM_SPEED_GAP);
        }
        return {
          start,
          full,
          maxDelta: readZoomDeltaSetting('maxDelta', ZOOM_DELTA_DEFAULT),
          response: clampZoomResponse(readZoomSetting('response', ZOOM_RESPONSE_DEFAULT))
        };
      })();


      function TopDownRacer() {
        const AI_DIFFICULTY_KEY = "racingvibes_ai_difficulty";
        const AI_LINE_VIS_KEY = "racingvibes_ai_line_visible";
        const AI_CLONE_GEARBOX_KEY = "racingvibes_ai_clone_gearbox";
        const AVAILABLE_AI_DIFFICULTIES = (() => {
          const skillMap = (window.RacerAI && window.RacerAI.AISkill) || null;
          const keys = skillMap ? Object.keys(skillMap) : ["easy", "medium", "hard"];
          return keys.length ? keys : ["medium"];
        })();
        const AI_SKILL_FALLBACK = {
          maxThrottle: 1.2,
          brakeAggro: 0.62,
          steerP: 3.2,
          steerD: 0.16,
          lookaheadBase: 50,
          lookaheadSpeed: 0.16,
          cornerMargin: 0,
          steerCutThrottle: 0.3,
          searchWindow: 56,
          speedHysteresis: 10,
          cornerEntryFactor: 0.6,
          minTargetSpeed: 110
        };
        const AI_CONTROL_LIMITS = {
          apexAggression: { min: 0, max: 1 },
          maxOffset: { min: 0.2, max: 0.65 },
          lookaheadBase: { min: 20, max: 80 },
          lookaheadSpeed: { min: 0.08, max: 0.25 },
          steerP: { min: 0.8, max: 3.2 },
          maxThrottle: { min: 0.6, max: 1.2 },
          brakeAggro: { min: 0.4, max: 1.6 },
          cornerMargin: { min: 0, max: 60 }
        };
        const MAX_AI_TARGET_SPEED = 2600;
        function mapMaxThrottleToSpeedScale(value) {
          const raw = Number.isFinite(value) ? value : 1;
          const normalized = Math.max(0, Math.min(1, (raw - 0.6) / 0.6));
          return 1 + normalized * 5;
        }
        const AI_CONTROL_DESCRIPTIONS = {
          difficulty: "Loads a skill preset; changing it updates the base controller tuning.",
          apexAggression: "Higher values hug the curb harder by biasing the racing line toward the apex.",
          maxOffset: "Caps how far the generated racing line can drift away from the centerline.",
          lookaheadBase: "Baseline distance ahead (in px) the AI samples along the racing line when slow.",
          lookaheadSpeed: "Adds extra lookahead based on speed, helping fast cars anticipate corners.",
          steerP: "Primary steering gain; higher values react faster but can oscillate.",
          maxThrottle: "Controls both throttle aggression and how high the AI pushes top speed.",
          brakeAggro: "Scales brake commands; crank it up if AI dives too deep into corners.",
          cornerMargin: "Extra speed cushion the AI removes before corners to stay stable."
        };
        const getAiControlDescription = (key) => AI_CONTROL_DESCRIPTIONS[key] || "";
        // Recovery settings for AI cars that get stuck or face the wrong way.
        const AI_RECOVERY_CFG = {
          stuckSpeed: 32,
          exitSpeed: 40,
          exitSpeedSoft: 15,
          wrongHeadingDot: 0.25,       // REDUCED: Only trigger recovery when significantly off-heading
          backwardsDot: -0.5,          // CHANGED: Must be facing mostly backwards to trigger reverse
          backwardsThreshold: -0.5,    // CHANGED: Stricter - must be facing very backwards
          exitDot: 0.10,               // REDUCED: Can exit recovery sooner
          forwardExitDot: 0.20,
          facingLineThreshold: 0.20,
          stuckTime: 0.8,              // INCREASED: Wait longer before triggering recovery
          offTrackTime: 0.6,           // INCREASED: Wait longer before off-track recovery
          backwardsTime: 1.2,          // INCREASED: Wait longer before backwards trigger
          reverseSwitch: 1.5,          // INCREASED: Try turning for longer before switching to reverse
          reverseDuration: 0.5,        // INCREASED: When reversing, do it properly
          maxDuration: 2.0,            // REDUCED: Don't stay in recovery too long
          cooldown: 0.3,               // REDUCED: Can re-enter recovery faster if needed
          searchWindow: 200,
          lineAimDistance: 180,        // INCREASED: More lenient distance check
          lineCloseDistance: 150,      // INCREASED: More lenient
          reverseBrake: 0.95,          // INCREASED: Faster reversing when needed
          reverseExitMultiplier: 1.5,
          goodPositionSpeed: 3,
          readyToGoSpeed: 2,
          edgeLookahead: 0.12,
          edgeSafetyMargin: 15,
          edgeMinSpeed: 1,
          quickExitDot: 0.10,
          reverseSteerGain: 0.40,      // INCREASED: More responsive steering when reversing
          readyFacingDot: 0.05,
          readyMinSpeed: 1,
          exitThrottle: 1.0,           // INCREASED: Full throttle on exit
          turnThrottle: 1.0,           // INCREASED: Full throttle in turn mode
          steerGainTurn: 0.50,         // INCREASED: More aggressive steering
          // Parameters for smarter recovery
          steerCommitTime: 0.15,       // REDUCED: Faster steering response
          steerCommitBoost: 0.20,
          maxReverseSpeed: 120,        // INCREASED: Allow faster reversing
          edgeHugSpeed: 20,            // REDUCED: Less aggressive edge hug detection
          edgeHugTime: 2.0,            // INCREASED: Wait longer before edge hug trigger
          forwardExitSpeed: 10,        // REDUCED: Can exit with less forward speed
          failedRecoveryCount: 3,
          recoveryMemoryTime: 5.0,
          failureCooldownMult: 2,      // REDUCED: Don't penalize too much
          lightBrakeForce: 0.40,
          moderateBrakeForce: 0.25,
          // New: threshold for when reverse is truly necessary
          mustReverseDot: -0.7         // Only start in reverse mode if facing almost completely backwards
        };
        // Configuration for AI collision avoidance behavior
        const AI_COLLISION_AVOIDANCE_CFG = {
          // Detection ranges
          detectRange: 120,            // Max distance to detect other cars (px)
          dangerRange: 60,             // Distance at which aggressive avoidance is triggered (braking + throttle cut)
          minDetectionDistance: 1,     // Minimum distance to consider (px) - prevents divide by zero
          sideDetectAngle: 0.6,        // Radians - how wide to check for cars to the side (~35 deg)
          forwardDetectAngle: 0.35,    // Radians - narrower cone for cars directly ahead (~20 deg)
          forwardDotThreshold: 0.1,    // Dot product threshold - car must be this much "ahead" to be a threat
          combinedCollisionRadius: 50, // Approximate collision radius for two cars (px)
          
          // Response tuning
          steerAvoidGain: 0.6,         // How strongly to steer away (0-1)
          brakeThreshold: 0.4,         // Relative speed fraction threshold to trigger braking
          throttleCutFactor: 0.5,      // How much to reduce throttle when avoiding
          minAvoidSpeed: 80,           // Below this speed, don't slow down for avoidance
          emergencyBrakeFactor: 0.3,   // Brake force multiplier for emergency avoidance
          throttleReductionFactor: 0.3, // Throttle reduction for moderate threat
          
          // Priority tuning - balance between racing and avoiding
          avoidancePriority: 0.6,      // 0 = ignore other cars, 1 = always avoid
          racingLinePriority: 0.7,     // How much to prefer staying on racing line vs avoiding
          speedCostThreshold: 0.15,    // Only avoid if speed cost is less than this fraction
          emergencyUrgencyThreshold: 0.8, // Above this urgency, always avoid regardless of cost
          
          // Timing
          predictionTime: 0.5,         // Seconds to look ahead for collision prediction
          reactionDelay: 0.1           // Minimum time between avoidance adjustments
        };
        
        // Collision avoidance function for AI cars
        function applyAiCollisionAvoidance(car, control, dt, allCars, player) {
          if (!car || !control) return control;
          
          const cfg = AI_COLLISION_AVOIDANCE_CFG;
          const carSpeed = getCarSpeed(car);
          
          // Skip avoidance at very low speeds - just race
          if (carSpeed < cfg.minAvoidSpeed) return control;
          
          // Car's forward direction (used for detecting cars ahead)
          const carAngle = car.angle || 0;
          const fwdX = Math.cos(carAngle);
          const fwdY = Math.sin(carAngle);
          
          // Get car velocity for prediction
          const vx = (car.physics && car.physics.vx) || car.vx || 0;
          const vy = (car.physics && car.physics.vy) || car.vy || 0;
          
          // Collect all other cars (AI + player)
          const otherCars = [];
          if (Array.isArray(allCars)) {
            for (const other of allCars) {
              if (other && other !== car) otherCars.push(other);
            }
          }
          if (player && player !== car && !otherCars.includes(player)) {
            otherCars.push(player);
          }
          
          // Find closest car in our path that we need to avoid
          let closestThreat = null;
          let closestDist = Infinity;
          let threatSide = 0; // -1 = left, 1 = right, 0 = directly ahead
          
          for (const other of otherCars) {
            if (!other) continue;
            
            // Vector from car to other
            const dx = other.x - car.x;
            const dy = other.y - car.y;
            const dist = Math.hypot(dx, dy);
            
            // Skip if too far away or too close (avoid divide by zero)
            if (dist > cfg.detectRange || dist < cfg.minDetectionDistance) continue;
            
            // Check if other car is ahead of us
            const dotForward = (dx * fwdX + dy * fwdY) / dist;
            if (dotForward < cfg.forwardDotThreshold) continue; // Behind us or beside us, not a concern
            
            // Calculate angle to other car
            const angleToOther = Math.atan2(dy, dx);
            const angleDiff = safeNormalizeAngle(angleToOther - carAngle);
            
            // Check if within detection cone
            const absAngleDiff = Math.abs(angleDiff);
            const isDirectlyAhead = absAngleDiff < cfg.forwardDetectAngle;
            const isInSideCone = absAngleDiff < cfg.sideDetectAngle;
            
            if (!isInSideCone) continue;
            
            // Predict future positions
            const otherVx = (other.physics && other.physics.vx) || other.vx || 0;
            const otherVy = (other.physics && other.physics.vy) || other.vy || 0;
            
            // Predicted positions after predictionTime
            const myFutureX = car.x + vx * cfg.predictionTime;
            const myFutureY = car.y + vy * cfg.predictionTime;
            const otherFutureX = other.x + otherVx * cfg.predictionTime;
            const otherFutureY = other.y + otherVy * cfg.predictionTime;
            
            const futureDist = Math.hypot(otherFutureX - myFutureX, otherFutureY - myFutureY);
            
            // Check if collision is predicted:
            // 1. Predicted positions will be within collision radius (future collision)
            // 2. OR car is directly ahead and already within danger range (imminent collision)
            const predictedCollision = futureDist < cfg.combinedCollisionRadius;
            const imminentCollision = isDirectlyAhead && dist < cfg.dangerRange;
            const willCollide = predictedCollision || imminentCollision;
            
            if (willCollide && dist < closestDist) {
              closestDist = dist;
              closestThreat = other;
              // Determine which side the other car is on (for steering away)
              // positive angleDiff = other is to our left, so threatSide=1
              // negative angleDiff = other is to our right, so threatSide=-1
              // steerAdjustment uses -threatSide, so: left threat → steer right, right threat → steer left
              threatSide = angleDiff > 0 ? 1 : -1;
            }
          }
          
          // If no threat, return original control
          if (!closestThreat) return control;
          
          // Calculate avoidance response
          const urgency = 1 - (closestDist / cfg.detectRange); // 0 at max range, 1 at contact
          const avoidanceStrength = urgency * cfg.avoidancePriority;
          
          // Calculate the cost of avoidance - if avoiding would significantly hurt our speed, don't do it
          const originalThrottle = control.throttle || 0;
          const speedCost = avoidanceStrength * cfg.throttleCutFactor;
          
          // Only apply avoidance if cost is acceptable
          // Racing takes priority - AI will not avoid if doing so would hurt lap time significantly
          if (speedCost > cfg.speedCostThreshold && urgency < cfg.emergencyUrgencyThreshold) {
            return control;
          }
          
          // Create modified control
          const newControl = { ...control };
          
          // Steer away from threat
          // steerAdjustment is negative when threatSide is positive (threat on left → steer right)
          const steerAdjustment = -threatSide * cfg.steerAvoidGain;
          const baseSteer = control.steer || 0;
          
          // Blend between racing line steering and avoidance steering
          // As avoidance strength increases, blend more toward avoidance steering
          // racingLinePriority determines baseline preference for racing line
          const avoidWeight = avoidanceStrength * (1 - cfg.racingLinePriority);
          const raceWeight = 1 - avoidWeight;
          const blendedSteer = baseSteer * raceWeight + steerAdjustment * avoidWeight;
          newControl.steer = safeClamp(blendedSteer, -1, 1);
          
          // Reduce throttle if car ahead is slower
          const threatSpeed = getCarSpeed(closestThreat);
          const relativeSpeed = carSpeed - threatSpeed;
          
          // Only apply braking if we're moving fast enough and closing faster than threshold
          // Note: carSpeed is already guaranteed > minAvoidSpeed from early return at function start
          if (relativeSpeed > carSpeed * cfg.brakeThreshold && closestDist < cfg.dangerRange) {
            // We're approaching significantly faster than the car ahead - slow down
            newControl.throttle = Math.max(0, originalThrottle * (1 - avoidanceStrength * cfg.throttleCutFactor));
            newControl.brake = Math.min(1, (control.brake || 0) + avoidanceStrength * cfg.emergencyBrakeFactor);
          } else if (urgency > 0.5) {
            // Moderate threat - just ease off throttle slightly
            newControl.throttle = originalThrottle * (1 - avoidanceStrength * cfg.throttleReductionFactor);
          }
          
          return newControl;
        }
        const gripModeConfig = (window.RacerModes && typeof window.RacerModes.get === "function") ? window.RacerModes.get("grip") : null;
        function sanitizeDifficulty(value){
          if (!value || typeof value !== "string") return null;
          const lower = value.toLowerCase();
          return AVAILABLE_AI_DIFFICULTIES.includes(lower) ? lower : null;
        }
        function loadStoredDifficulty(){
          try {
            const stored = localStorage.getItem(AI_DIFFICULTY_KEY);
            return sanitizeDifficulty(stored);
          } catch(_){
            return null;
          }
        }
        function loadStoredLineVisibility(){
          try {
            const stored = localStorage.getItem(AI_LINE_VIS_KEY);
            if (stored === null) return false;
            return stored === "1" || stored === "true";
          } catch(_){
            return false;
          }
        }
        function loadStoredCloneGearbox(){
          try {
            const stored = localStorage.getItem(AI_CLONE_GEARBOX_KEY);
            if (stored === null) return false;
            return stored === "1" || stored === "true";
          } catch(_){
            return false;
          }
        }
        function getAISkillDefaults(level){
          const api = window.RacerAI;
          const skillMap = api && api.AISkill;
          if (skillMap) {
            if (level && skillMap[level]) return skillMap[level];
            if (skillMap.medium) return skillMap.medium;
            const firstKey = Object.keys(skillMap)[0];
            if (firstKey) return skillMap[firstKey];
          }
          return AI_SKILL_FALLBACK;
        }
        const safeClamp = (value, min, max) => {
          if (typeof clamp === "function") return clamp(value, min, max);
          if (value < min) return min;
          if (value > max) return max;
          return value;
        };
        const safeOnRoad = (x, y) => {
          if (typeof onRoad === "function") return onRoad(x, y);
          return true;
        };
        function ensureAiRecoveryState(car) {
          if (!car) return null;
          if (!car.aiRecovery) {
            car.aiRecovery = {
              active: false,
              timer: 0,
              stuckTimer: 0,
              backwardsTimer: 0, // Track how long car has been racing backwards
              cooldown: 0,
              mode: null,
              lineIdx: 0,
              phase: null,
              reverseTimer: 0,
              phaseTimer: 0,
              // New tracking for smarter recovery
              committedSteerDir: 0,     // -1 = left, 0 = none, 1 = right
              steerCommitTimer: 0,      // Time since steering direction was committed
              edgeHugTimer: 0,          // Time spent edge hugging
              failedRecoveries: 0,      // Count of failed recovery attempts
              lastRecoveryTime: 0,      // Timestamp of last recovery start
              lastFailureTime: 0,       // Timestamp of last failed recovery for memory window
              totalRecoveryTime: 0      // Cumulative time in recovery for this stuck episode
            };
          }
          return car.aiRecovery;
        }
        function getCarSpeed(car) {
          if (!car) return 0;
          const vx = (car.physics && car.physics.vx) || car.vx || 0;
          const vy = (car.physics && car.physics.vy) || car.vy || 0;
          return Math.hypot(vx, vy);
        }
        // Check if reversing would take the car off-track (predict position looking backwards from car's heading)
        function wouldHitEdgeReversing(car, lookaheadTime) {
          if (!car) return false;
          const speed = getCarSpeed(car);
          if (speed < AI_RECOVERY_CFG.edgeMinSpeed) return false; // Not moving fast enough to matter
          
          // Use car's heading angle to determine backward direction (more reliable than velocity during recovery)
          const angle = car.angle || 0;
          const backX = -Math.cos(angle);  // Opposite of car's forward direction
          const backY = -Math.sin(angle);
          
          // Predict position if continuing to move backward
          const predictDist = speed * lookaheadTime + AI_RECOVERY_CFG.edgeSafetyMargin;
          const futureX = car.x + backX * predictDist;
          const futureY = car.y + backY * predictDist;
          // Check if predicted position is off-road (safeOnRoad returns true as fallback)
          return !safeOnRoad(futureX, futureY);
        }
        // Helper to check if reverse should stop due to edge proximity or excessive speed
        function shouldStopReversing(car, forwardSpeed) {
          const wouldHitEdge = wouldHitEdgeReversing(car, AI_RECOVERY_CFG.edgeLookahead);
          const reversingTooFast = forwardSpeed < -AI_RECOVERY_CFG.maxReverseSpeed;
          return { shouldStop: wouldHitEdge || reversingTooFast, wouldHitEdge, reversingTooFast };
        }
        // Determine optimal steering direction during reverse - returns best steer value (-1 to 1)
        // Uses steering commitment to prevent oscillation
        function getOptimalReverseSteer(car, headingInfo, state) {
          if (!car || !headingInfo) return 0;
          const recoveryState = state || ensureAiRecoveryState(car);
          
          // Target heading we want to face (toward racing line)
          const targetHeading = headingInfo.toNodeHeading;
          const carAngle = car.angle || 0;
          // Calculate the angle difference (normalized to -PI to PI)
          const angleDiff = safeNormalizeAngle(targetHeading - carAngle);
          
          // Calculate the ideal steering direction
          const idealSteer = safeClamp(angleDiff / (Math.PI * AI_RECOVERY_CFG.reverseSteerGain), -1, 1);
          const idealDir = idealSteer > 0.1 ? 1 : (idealSteer < -0.1 ? -1 : 0);
          
          // Check if we should commit to a new direction or maintain current commitment
          if (recoveryState) {
            const currentCommit = recoveryState.committedSteerDir || 0;
            const commitTimer = recoveryState.steerCommitTimer || 0;
            
            // If no commitment or commitment has expired, set new direction
            if (currentCommit === 0 || commitTimer >= AI_RECOVERY_CFG.steerCommitTime) {
              recoveryState.committedSteerDir = idealDir;
              recoveryState.steerCommitTimer = 0;
            }
            // Use committed direction if still within commit window
            if (recoveryState.committedSteerDir !== 0 && commitTimer < AI_RECOVERY_CFG.steerCommitTime) {
              return recoveryState.committedSteerDir * Math.min(1, Math.abs(idealSteer) + AI_RECOVERY_CFG.steerCommitBoost);
            }
          }
          
          return idealSteer;
        }
        // Check if car is in a reasonable position to start racing - SUPER lenient
        function isReadyToRace(car, headingInfo) {
          if (!car) return false;
          const onRoad = safeOnRoad(car.x, car.y);
          
          // If on road and not facing completely backwards, we're ready
          if (onRoad) {
            if (!headingInfo) return true; // No info? Just go.
            // As long as we're not facing backwards, we're good
            return headingInfo.dot > AI_RECOVERY_CFG.backwardsThreshold;
          }
          
          return false;
        }
        const safeLoopIndex = (value, len) => {
          if (typeof loopIndex === "function") return loopIndex(value, len);
          const L = Math.max(1, len || 1);
          return ((value % L) + L) % L;
        };
        function findNearestRacingLineIndex(line, x, y, seedIndex = 0, windowSize = 160) {
          if (!line || !line.length) return 0;
          const count = line.length;
          const seed = safeLoopIndex(seedIndex, count);
          const window = Math.min(count - 1, Math.max(20, windowSize | 0));
          let bestIdx = seed;
          let bestDist = Infinity;
          for (let offset = -window; offset <= window; offset++) {
            const idx = safeLoopIndex(seed + offset, count);
            const node = line[idx];
            if (!node) continue;
            const dx = node.x - x;
            const dy = node.y - y;
            const dist = dx * dx + dy * dy;
            if (dist < bestDist) {
              bestDist = dist;
              bestIdx = idx;
            }
          }
          return bestIdx;
        }
        const safeNormalizeAngle = (value) => {
          if (typeof normalizeAngle === "function") return normalizeAngle(value);
          let a = value;
          while (a > Math.PI) a -= Math.PI * 2;
          while (a < -Math.PI) a += Math.PI * 2;
          return a;
        };
        function computeHeadingInfo(line, idx, car) {
          if (!line || !line.length || !car) return null;
          const count = line.length;
          const node = line[safeLoopIndex(idx, count)];
          if (!node) return null;
          let tx = node.tangent && Number.isFinite(node.tangent.x) ? node.tangent.x : null;
          let ty = node.tangent && Number.isFinite(node.tangent.y) ? node.tangent.y : null;
          if (tx === null || ty === null) {
            const next = line[(safeLoopIndex(idx + 1, count))];
            const dx = (next && Number.isFinite(next.x) ? next.x : node.x) - node.x;
            const dy = (next && Number.isFinite(next.y) ? next.y : node.y) - node.y;
            const len = Math.hypot(dx, dy) || 1;
            tx = dx / len;
            ty = dy / len;
          }
          const desiredHeading = Math.atan2(ty, tx);
          const diff = safeNormalizeAngle(desiredHeading - car.angle);
          const fwd = { x: Math.cos(car.angle), y: Math.sin(car.angle) };
          const dot = safeClamp(fwd.x * tx + fwd.y * ty, -1, 1);
          const vecX = node.x - car.x;
          const vecY = node.y - car.y;
          const dist = Math.hypot(vecX, vecY) || 1;
          const toNodeX = vecX / dist;
          const toNodeY = vecY / dist;
          const toNodeHeading = Math.atan2(vecY, vecX);
          const vecDot = safeClamp(fwd.x * toNodeX + fwd.y * toNodeY, -1, 1);
          const vecDiff = safeNormalizeAngle(toNodeHeading - car.angle);
          return { desiredHeading, diff, dot, toNodeHeading, toNodeDiff: vecDiff, toNodeDot: vecDot, distance: dist };
        }
        function beginAiRecovery(state, car, mode, currentTime) {
          if (!state) return;
          const targetCar = car || null;
          
          // Store recovery start time for tracking failures
          const now = currentTime || 0;
          state.lastRecoveryTime = now;
          
          state.active = true;
          state.mode = mode || "turn";
          state.timer = 0;
          state.reverseTimer = 0;
          state.cooldown = AI_RECOVERY_CFG.cooldown;
          state.stuckTimer = 0;
          state.phaseTimer = 0;
          state.committedSteerDir = 0;
          state.steerCommitTimer = 0;
          state.edgeHugTimer = 0;
          // Set phase based on mode: "reverse" mode starts with reverseOut phase, others start with "turn"
          state.phase = mode === "reverse" ? "reverseOut" : "turn";
          if (targetCar && targetCar.physics) {
            targetCar.physics.dir = 1;
          }
          if (targetCar && targetCar.gearbox && typeof targetCar.gearbox.shiftUp === "function") {
            try { targetCar.gearbox.shiftUp(); targetCar.gearbox.shiftUp(); } catch(_){ }
          }
        }
        function endAiRecovery(state, car, success, currentTime) {
          if (!state) return;
          
          // Track failed recoveries within memory window
          const now = currentTime || 0;
          if (!success) {
            // Check if this failure is within the memory window of previous failures
            if (state.lastFailureTime && (now - state.lastFailureTime) < AI_RECOVERY_CFG.recoveryMemoryTime) {
              state.failedRecoveries = (state.failedRecoveries || 0) + 1;
            } else {
              // Memory window expired, start fresh count
              state.failedRecoveries = 1;
            }
            state.lastFailureTime = now;
            
            // Apply escalated cooldown after multiple consecutive failures
            if (state.failedRecoveries >= AI_RECOVERY_CFG.failedRecoveryCount) {
              state.cooldown = AI_RECOVERY_CFG.cooldown * AI_RECOVERY_CFG.failureCooldownMult;
            }
          } else {
            // Successful recovery - reset failure counter
            state.failedRecoveries = 0;
          }
          
          state.active = false;
          state.mode = null;
          state.timer = 0;
          state.phase = null;
          state.reverseTimer = 0;
          state.phaseTimer = 0;
          state.backwardsTimer = 0;
          state.committedSteerDir = 0;
          state.steerCommitTimer = 0;
          state.edgeHugTimer = 0;
          state.lineIdx = Number.isFinite(state.lineIdx) ? state.lineIdx : 0;
          if (car && car.physics) {
            car.physics.dir = 1;
          }
        }
        // Override AI inputs when a car is stuck so it can perform a turn or reverse maneuver.
        function applyAiRecoveryControl(car, baseControl, dt, line, gameTime) {
          if (!car) return baseControl || { throttle: 0, brake: 0, steer: 0 };
          const state = ensureAiRecoveryState(car);
          if (!state) return baseControl || { throttle: 0, brake: 0, steer: 0 };
          state.cooldown = Math.max(0, (state.cooldown || 0) - dt);
          const speed = getCarSpeed(car);
          
          // Update steering commit timer
          if (state.active) {
            state.steerCommitTimer = (state.steerCommitTimer || 0) + dt;
          }
          
          if (!state.active) {
            state.stuckTimer = speed < AI_RECOVERY_CFG.stuckSpeed ? (state.stuckTimer + dt) : 0;
          } else {
            state.stuckTimer = 0;
          }
          let headingInfo = null;
          if (line && line.length) {
            const seed = Number.isFinite(state.lineIdx) ? state.lineIdx : (car.targetIndex || 0);
            state.lineIdx = findNearestRacingLineIndex(line, car.x, car.y, seed, AI_RECOVERY_CFG.searchWindow);
            headingInfo = computeHeadingInfo(line, state.lineIdx, car);
          }
          const wrongHeading = headingInfo ? headingInfo.dot < AI_RECOVERY_CFG.wrongHeadingDot : false;
          const backwards = headingInfo ? headingInfo.dot < AI_RECOVERY_CFG.backwardsDot : false;
          const offTrack = !safeOnRoad(car.x, car.y);
          const farFromLine = headingInfo ? headingInfo.distance > AI_RECOVERY_CFG.lineAimDistance : false;
          const driftingAway = headingInfo ? headingInfo.toNodeDot < 0.1 : false;
          const stuck = speed < AI_RECOVERY_CFG.stuckSpeed;
          
          // Detect edge hugging - car moving slowly but not completely stuck
          const isEdgeHugging = !state.active && speed > 0 && speed < AI_RECOVERY_CFG.edgeHugSpeed && 
                               (offTrack || (headingInfo && headingInfo.distance > AI_RECOVERY_CFG.lineCloseDistance));
          if (isEdgeHugging) {
            state.edgeHugTimer = (state.edgeHugTimer || 0) + dt;
          } else if (!state.active) {
            state.edgeHugTimer = 0;
          }
          
          // Track how long car has been racing backwards (facing opposite direction of racing line)
          if (!state.active) {
            state.backwardsTimer = backwards && speed > AI_RECOVERY_CFG.stuckSpeed ? (state.backwardsTimer || 0) + dt : 0;
          } else {
            state.backwardsTimer = 0;
          }
          if (!state.active && state.cooldown <= 0) {
            const wrongWayTrigger = stuck && headingInfo && headingInfo.dot < AI_RECOVERY_CFG.wrongHeadingDot && state.stuckTimer > AI_RECOVERY_CFG.stuckTime;
            const offTrackTrigger = stuck && offTrack && state.stuckTimer > AI_RECOVERY_CFG.offTrackTime;
            const driftTrigger = stuck && headingInfo && headingInfo.distance > 80 && headingInfo.toNodeDot < 0.3 && state.stuckTimer > 0.5;
            // Trigger recovery when racing backwards at speed for too long
            const backwardsRacingTrigger = backwards && speed > AI_RECOVERY_CFG.stuckSpeed && state.backwardsTimer > AI_RECOVERY_CFG.backwardsTime;
            // Trigger for edge hugging - car slowly driving along edge
            const edgeHugTrigger = state.edgeHugTimer > AI_RECOVERY_CFG.edgeHugTime;
            
            if (wrongWayTrigger || offTrackTrigger || driftTrigger || backwardsRacingTrigger || edgeHugTrigger) {
              // Only use reverse mode if facing almost completely backwards (mustReverseDot)
              // Otherwise, always try "turn" mode first - it's usually sufficient
              const mustReverse = headingInfo && headingInfo.dot < AI_RECOVERY_CFG.mustReverseDot;
              beginAiRecovery(state, car, mustReverse ? "reverse" : "turn", gameTime || 0);
            }
          }
          const control = {
            throttle: baseControl && Number.isFinite(baseControl.throttle) ? baseControl.throttle : 0,
            brake: baseControl && Number.isFinite(baseControl.brake) ? baseControl.brake : 0,
            steer: baseControl && Number.isFinite(baseControl.steer) ? baseControl.steer : 0
          };
          if (!state.active) {
            return control;
          }
          state.timer += dt;
          state.phaseTimer = (state.phaseTimer || 0) + dt;
          
          const onRoadNow = safeOnRoad(car.x, car.y);
          const notBackwards = headingInfo ? headingInfo.dot > AI_RECOVERY_CFG.backwardsThreshold : true;
          
          // Calculate forward velocity (velocity component along car's heading direction)
          const vx = (car.physics && car.physics.vx) || car.vx || 0;
          const vy = (car.physics && car.physics.vy) || car.vy || 0;
          const fwdX = Math.cos(car.angle || 0);
          const fwdY = Math.sin(car.angle || 0);
          const forwardSpeed = vx * fwdX + vy * fwdY;
          
          // EXIT CONDITIONS:
          // 1. On road, not facing backwards, and have some forward momentum
          // 2. Hard timeout after maxDuration
          const hasForwardMomentum = forwardSpeed > AI_RECOVERY_CFG.forwardExitSpeed;
          const readyToExit = onRoadNow && notBackwards && hasForwardMomentum;
          const timedOut = state.timer > AI_RECOVERY_CFG.maxDuration;
          
          if (readyToExit) {
            // Successful recovery - clear failed counter
            state.failedRecoveries = 0;
            endAiRecovery(state, car, true, gameTime);
            control.throttle = AI_RECOVERY_CFG.exitThrottle;
            control.brake = 0;
            // Steer toward racing line
            if (headingInfo) {
              const headingDiff = safeNormalizeAngle(headingInfo.desiredHeading - car.angle);
              control.steer = safeClamp(headingDiff / (Math.PI * AI_RECOVERY_CFG.steerGainTurn), -1, 1);
            }
            return control;
          }
          
          if (timedOut) {
            // Timed out - this counts as a failed recovery
            endAiRecovery(state, car, false, gameTime);
            control.throttle = AI_RECOVERY_CFG.exitThrottle;
            control.brake = 0;
            if (headingInfo) {
              const headingDiff = safeNormalizeAngle(headingInfo.desiredHeading - car.angle);
              control.steer = safeClamp(headingDiff / (Math.PI * AI_RECOVERY_CFG.steerGainTurn), -1, 1);
            }
            return control;
          }
          
          // Still in recovery - try to get into a good position
          // Only switch to reverse if:
          // 1. We've been trying "turn" mode for long enough (reverseSwitch time)
          // 2. We're facing almost completely backwards (mustReverseDot threshold)
          // 3. We're making no progress (still stuck)
          const trulyBackwards = headingInfo && headingInfo.dot < AI_RECOVERY_CFG.mustReverseDot;
          const shouldSwitchToReverse = state.mode === "turn" && trulyBackwards && 
                                        state.timer > AI_RECOVERY_CFG.reverseSwitch && stuck;
          if (shouldSwitchToReverse) {
            state.mode = "reverse";
            state.phase = "reverseOut";
            state.reverseTimer = 0;
            state.phaseTimer = 0;
            state.committedSteerDir = 0; // Reset steering commitment on mode change
          }
          
          if (state.phase === "reverseOut") {
            // Use optimal steering direction with commitment (prevents oscillation)
            control.steer = getOptimalReverseSteer(car, headingInfo, state);
            control.throttle = 0;
            
            // Check if we should stop reversing
            const reverseCheck = shouldStopReversing(car, forwardSpeed);
            
            if (reverseCheck.shouldStop) {
              // About to hit edge or going too fast - stop reversing immediately
              control.brake = reverseCheck.reversingTooFast ? AI_RECOVERY_CFG.lightBrakeForce : 0;
              state.phase = "turn";
              state.mode = "turn";
              state.phaseTimer = 0;
              state.committedSteerDir = 0;
              control.throttle = AI_RECOVERY_CFG.exitThrottle;
              return control;
            }
            
            // Not near edge - reverse with controlled braking
            control.brake = Math.max(AI_RECOVERY_CFG.reverseBrake, control.brake || 0);
            
            state.reverseTimer = (state.reverseTimer || 0) + dt;
            // Exit reverse phase when duration is met
            const reversedEnough = state.reverseTimer > AI_RECOVERY_CFG.reverseDuration;
            const forcedExit = state.reverseTimer > AI_RECOVERY_CFG.reverseDuration * AI_RECOVERY_CFG.reverseExitMultiplier;
            if (reversedEnough || forcedExit) {
              state.phase = "turn";
              state.mode = "turn";
              state.phaseTimer = 0;
              state.committedSteerDir = 0;
            }
            return control;
          }
          
          // Turn mode - accelerate forward and steer toward racing line
          const headingTarget = headingInfo ? headingInfo.desiredHeading : car.angle;
          const headingDiff = safeNormalizeAngle(headingTarget - car.angle);
          const steerTarget = safeClamp(headingDiff / (Math.PI * AI_RECOVERY_CFG.steerGainTurn), -1, 1);
          control.steer = steerTarget;
          if (state.mode === "reverse") {
            // Use optimal steering direction for shortest path (with commitment)
            control.steer = getOptimalReverseSteer(car, headingInfo, state);
            
            // Check if we should stop reversing
            const reverseCheck = shouldStopReversing(car, forwardSpeed);
            
            if (reverseCheck.shouldStop) {
              // About to hit edge or too fast - stop reversing and go forward
              control.throttle = AI_RECOVERY_CFG.exitThrottle;
              control.brake = reverseCheck.reversingTooFast ? AI_RECOVERY_CFG.moderateBrakeForce : 0;
              state.mode = "turn";
              state.phase = "turn";
              state.committedSteerDir = 0;
            } else {
              // Not near edge - reverse with controlled speed
              control.throttle = 0;
              control.brake = Math.max(AI_RECOVERY_CFG.reverseBrake, control.brake || 0);
            }
          } else {
            // Turn mode - accelerate forward aggressively while steering toward racing line
            // Use stronger throttle regardless of turn amount
            control.throttle = Math.max(AI_RECOVERY_CFG.turnThrottle, control.throttle || 0);
            control.brake = 0; // No braking in turn mode - we need to get moving
          }
          return control;
        }
        function getLineDefaults(){
          const api = window.RacerAI;
          if (api && api.DEFAULT_LINE_CFG) return { ...api.DEFAULT_LINE_CFG };
          return { apexAggression: 0.10, maxOffset: 0.65 };
        }
        const modeDefault = gripModeConfig && gripModeConfig.ai && gripModeConfig.ai.defaultDifficulty ? gripModeConfig.ai.defaultDifficulty : null;
        const initialAIDifficulty = loadStoredDifficulty() || sanitizeDifficulty(modeDefault) || sanitizeDifficulty("hard") || AVAILABLE_AI_DIFFICULTIES[0];
        const canvasRef = useRef(null);
            const trackMapRef = useRef(null);
            const [running, setRunning] = useState(false);
            const runningRef = useRef(running);
        const [status, setStatus] = useState("");
        const statusRef = useRef(status);
        const [trackName, setTrackName] = useState(getInitialTrack()); // default to Le Mans
  const [hudTip, setHudTip] = useState("");
          const [countdownOverlay, setCountdownOverlay] = useState(null);
            const countdownOverlayRef = useRef(countdownOverlay);
          const countdownTimersRef = useRef([]);
          const countdownActiveRef = useRef(false);
        const [devPanelOpen, setDevPanelOpen] = useState(false);
        const [geoScaleInput, setGeoScaleInput] = useState(() => clampScale(GEO_SCALE));
        const [widthScaleInput, setWidthScaleInput] = useState(() => clampScale(WIDTH_SCALE));
      const [cameraDistance, setCameraDistance] = useState(() => clampCamera(readCameraDistance(CAMERA_DEFAULT)));
      const [zoomMaxDelta, setZoomMaxDelta] = useState(() => ZOOM_INIT.maxDelta);
      const [zoomResponseRate, setZoomResponseRate] = useState(() => ZOOM_INIT.response);
      const [zoomStartSpeed, setZoomStartSpeed] = useState(() => ZOOM_INIT.start);
      const [zoomFullSpeed, setZoomFullSpeed] = useState(() => ZOOM_INIT.full);

        function readDecorSetting(key, fallback) {
          try {
            const stored = localStorage.getItem(key);
            if (stored === null) return fallback;
            const parsed = parseFloat(stored);
            return Number.isFinite(parsed) ? parsed : fallback;
          } catch (_) {
            return fallback;
          }
        }

        const decorDefaults = (typeof Decor !== "undefined" && Decor.defaults) ? Decor.defaults : { treeDensity: 0.55, buildingDensity: 0.4, kerbWidthScale: 1.0, shadowStrength: 0.55 };
        const [treeDensity, setTreeDensity] = useState(() => readDecorSetting("decorTreeDensity", decorDefaults.treeDensity));
        const [buildingDensity, setBuildingDensity] = useState(() => readDecorSetting("decorBuildingDensity", decorDefaults.buildingDensity));
        const [kerbWidthScaleParam, setKerbWidthScaleParam] = useState(() => readDecorSetting("decorKerbWidthScale", decorDefaults.kerbWidthScale));
        const [shadowStrengthParam, setShadowStrengthParam] = useState(() => readDecorSetting("decorShadowStrength", decorDefaults.shadowStrength));
        const [decorSeedOffset, setDecorSeedOffset] = useState(() => {
          try {
            const stored = localStorage.getItem("decorSeedOffset");
            return stored === null ? 0 : parseInt(stored, 10) || 0;
          } catch (_) {
            return 0;
          }
        });
        const [aiPanelOpen, setAiPanelOpen] = useState(false);
        const [devMenuOpen, setDevMenuOpen] = useState(false);
        const [activeDevPanel, setActiveDevPanel] = useState(null); // 'scales', 'ai', 'devtools', 'gbx', 'tweaker'
        const [aiControls, setAIControls] = useState(() => {
          const lineDefaults = getLineDefaults();
          const skillDefaults = getAISkillDefaults(initialAIDifficulty);
          return {
            difficulty: initialAIDifficulty,
            apexAggression: lineDefaults.apexAggression ?? 0.10,
            maxOffset: lineDefaults.maxOffset ?? 0.65,
            lookaheadBase: skillDefaults.lookaheadBase ?? 50,
            lookaheadSpeed: skillDefaults.lookaheadSpeed ?? 0.16,
            steerP: skillDefaults.steerP ?? 3.2,
            maxThrottle: skillDefaults.maxThrottle ?? 1.2,
            brakeAggro: skillDefaults.brakeAggro ?? 0.62,
            cornerMargin: skillDefaults.cornerMargin ?? 0
          };
        });
        const aiControlsRef = useRef(aiControls);
        useEffect(() => {
          aiControlsRef.current = aiControls;
        }, [aiControls]);
        const [showAiLine, setShowAiLine] = useState(() => loadStoredLineVisibility());
        const showAiLineRef = useRef(showAiLine);
        useEffect(() => {
          showAiLineRef.current = showAiLine;
          try { localStorage.setItem(AI_LINE_VIS_KEY, showAiLine ? "1" : "0"); } catch(_){ }
        }, [showAiLine]);
        // Racing line mode and visualization
        const RACING_LINE_MODE_KEY = 'racingLineMode';
        const LINE_VIS_MODE_KEY = 'racingLineVisMode';
        const [racingLineMode, setRacingLineMode] = useState(() => {
          try {
            const stored = localStorage.getItem(RACING_LINE_MODE_KEY);
            return stored === 'mcp' ? 'mcp' : 'anchor';
          } catch(_) { return 'anchor'; }
        });
        const racingLineModeRef = useRef(racingLineMode);
        useEffect(() => {
          racingLineModeRef.current = racingLineMode;
          try { localStorage.setItem(RACING_LINE_MODE_KEY, racingLineMode); } catch(_){ }
        }, [racingLineMode]);
        const [lineVisMode, setLineVisMode] = useState(() => {
          try {
            const stored = localStorage.getItem(LINE_VIS_MODE_KEY);
            if (stored === 'anchor' || stored === 'mcp' || stored === 'both') return stored;
          } catch(_) {}
          return 'anchor';
        });
        const lineVisModeRef = useRef(lineVisMode);
        useEffect(() => {
          lineVisModeRef.current = lineVisMode;
          try { localStorage.setItem(LINE_VIS_MODE_KEY, lineVisMode); } catch(_){ }
        }, [lineVisMode]);
        const [showValidationMetrics, setShowValidationMetrics] = useState(false);
        const [clonePlayerGearbox, setClonePlayerGearbox] = useState(() => loadStoredCloneGearbox());
        const clonePlayerGearboxRef = useRef(clonePlayerGearbox);
        useEffect(() => {
          clonePlayerGearboxRef.current = clonePlayerGearbox;
          try { localStorage.setItem(AI_CLONE_GEARBOX_KEY, clonePlayerGearbox ? "1" : "0"); } catch(_){ }
        }, [clonePlayerGearbox]);
        function getCurrentMaxThrottle() {
          const current = aiControlsRef.current;
          if (current && Number.isFinite(current.maxThrottle)) return current.maxThrottle;
          const defaults = getAISkillDefaults((current && current.difficulty) || aiDifficulty);
          return defaults.maxThrottle ?? 1;
        }
        const applyAiLineOverridesRef = useRef(() => {});
        const rebuildAIControllersRef = useRef(() => {});
        const syncAIGearboxesRef = useRef(() => {});
        const setAIDifficultyRef = useRef(() => false);
        const updateAiControlValueRef = useRef(() => {});
        useEffect(() => { runningRef.current = running; }, [running]);
        useEffect(() => { countdownOverlayRef.current = countdownOverlay; }, [countdownOverlay]);
        useEffect(() => { statusRef.current = status; }, [status]);
        function runApplyAiLineOverrides(options) {
          const fn = applyAiLineOverridesRef.current;
          if (typeof fn === "function") {
            fn(options || {});
          }
        }
        function runRebuildAiControllers() {
          const fn = rebuildAIControllersRef.current;
          if (typeof fn === "function") {
            fn();
          }
        }
        function runSyncAIGearboxes() {
          const fn = syncAIGearboxesRef.current;
          if (typeof fn === "function") {
            fn();
          }
        }
        function handleSetAIDifficulty(level, persist = true, options) {
          const fn = setAIDifficultyRef.current;
          if (typeof fn === "function") {
            return fn(level, persist, options);
          }
          return false;
        }
        function handleAiControlChange(key, value) {
          const fn = updateAiControlValueRef.current;
          if (typeof fn === "function") {
            fn(key, value);
          }
        }

        function clearCountdownTimers(){
          const timers = countdownTimersRef.current || [];
          for (const id of timers) clearTimeout(id);
          countdownTimersRef.current = [];
          countdownActiveRef.current = false;
        }

        function cancelCountdown(){
          clearCountdownTimers();
          countdownOverlayRef.current = null;
          setCountdownOverlay(null);
        }

        function startRaceCountdown(){
          cancelCountdown();
          countdownActiveRef.current = true;
          runningRef.current = false;
          setRunning(false);
          const baseDelay = 320;
          const gap = 900;
          const sequence = [
            { label: "3", color: "#f87171", freq: 420, accent: 0.9 },
            { label: "2", color: "#fb923c", freq: 520, accent: 1.0 },
            { label: "1", color: "#fde047", freq: 640, accent: 1.1 },
            { label: "GO", color: "#4ade80", freq: 780, accent: 1.4, final: true }
          ];
          sequence.forEach((step, idx) => {
            const timer = setTimeout(() => {
              const overlayState = {
                label: step.label,
                color: step.color,
                startedAt: performance.now(),
                duration: step.final ? 900 : gap - 40,
                final: !!step.final
              };
              countdownOverlayRef.current = overlayState;
              setCountdownOverlay(overlayState);
              playCountdownBeep(step.freq, step.final ? 0.55 : 0.35, step.accent || 1);
              if (step.final) {
                countdownActiveRef.current = false;
                runningRef.current = true;
                setRunning(true);
                const hideId = setTimeout(() => {
                  countdownOverlayRef.current = null;
                  setCountdownOverlay(null);
                }, 750);
                countdownTimersRef.current.push(hideId);
              }
            }, baseDelay + idx * gap);
            countdownTimersRef.current.push(timer);
          });
        }

        useEffect(() => () => { clearCountdownTimers(); }, []);

        const trackSurfaceRef = useRef({ canvas: null });
        const decorParamsRef = useRef({
          treeDensity,
          buildingDensity,
          kerbWidthScale: kerbWidthScaleParam,
          shadowStrength: shadowStrengthParam,
        });
        const decorLayerRef = useRef({ decorCanvas: null, shadowCanvas: null, metadata: null });
        const decorSourceRef = useRef(null);
        const decorAtlasRef = useRef(null);
        const decorSignatureRef = useRef(null);
        const activeTrackRef = useRef(null);
  // motion steering analog value -1..1
  // Gyroscope removed: simplifying to keyboard / touch buttons only
  // camera state
  const camRef = useRef({ x: 0, y: 0, scale: CAM_BASE_ZOOM, targetScale: CAM_BASE_ZOOM });
  const displayScaleRef = useRef(1);
  const baseDisplayScaleRef = useRef(1);
  const camInitRef = useRef(false);
        const loadTrackRef = useRef(() => {});
        useEffect(() => {
          if (!hudTip) return;
          const timer = setTimeout(() => setHudTip(""), 2600);
          return () => clearTimeout(timer);
        }, [hudTip]);
        useEffect(() => {
          runApplyAiLineOverrides();
        }, [aiControls.apexAggression, aiControls.maxOffset, aiControls.maxThrottle]);
        useEffect(() => {
          runRebuildAiControllers();
        }, [aiControls.difficulty, aiControls.lookaheadBase, aiControls.lookaheadSpeed, aiControls.steerP, aiControls.maxThrottle, aiControls.brakeAggro, aiControls.cornerMargin]);
        function reloadTrack() {
          const loader = loadTrackRef.current;
          if (typeof loader === "function") {
            loader(trackName);
          }
        }
        function applyGeoScaleChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampScale(parsed);
          if (Math.abs(clamped - GEO_SCALE) < 1e-4) {
            setGeoScaleInput(clamped);
            return;
          }
          GEO_SCALE = clamped;
          setGeoScaleInput(clamped);
          writeScale("geoScale", clamped);
          reloadTrack();
        }
        function applyWidthScaleChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampScale(parsed);
          if (Math.abs(clamped - WIDTH_SCALE) < 1e-4) {
            setWidthScaleInput(clamped);
            return;
          }
          WIDTH_SCALE = clamped;
          setWidthScaleInput(clamped);
          writeScale("widthScale", clamped);
          reloadTrack();
        }

        function applyCameraDistanceChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampCamera(parsed);
          setCameraDistance(clamped);
          writeCameraDistance(clamped);
        }

        function handleZoomMaxDeltaChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampZoomDelta(parsed);
          setZoomMaxDelta(clamped);
          writeZoomSetting('maxDelta', clamped);
        }

        function handleZoomStartSpeedChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          let clamped = clampZoomSpeed(parsed);
          const maxAllowed = Math.max(ZOOM_SPEED_MIN, zoomFullSpeed - ZOOM_SPEED_GAP);
          if (clamped > maxAllowed) clamped = maxAllowed;
          setZoomStartSpeed(clamped);
          writeZoomSetting('startSpeed', clamped);
        }

        function handleZoomFullSpeedChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          let clamped = clampZoomSpeed(parsed);
          const minAllowed = Math.min(ZOOM_SPEED_MAX, zoomStartSpeed + ZOOM_SPEED_GAP);
          if (clamped < minAllowed) clamped = minAllowed;
          setZoomFullSpeed(clamped);
          writeZoomSetting('fullSpeed', clamped);
        }

        function handleZoomResponseChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampZoomResponse(parsed);
          setZoomResponseRate(clamped);
          writeZoomSetting('response', clamped);
        }

        function fallbackHash(str) {
          let h = 0;
          for (let i = 0; i < str.length; i++) {
            h = (Math.imul(31, h) + str.charCodeAt(i)) | 0;
          }
          return h >>> 0;
        }

        function computeDecorSeed(trackKey, baseW, baseH) {
          const base = (typeof Decor !== "undefined" && typeof Decor.hash === "function")
            ? Decor.hash(`${trackKey}|${baseW}x${baseH}`)
            : fallbackHash(`${trackKey}|${baseW}x${baseH}`);
          return (base + (decorSeedOffset >>> 0)) >>> 0;
        }

        function runDecor(force = false) {
          if (typeof Decor === "undefined") return;
          const source = decorSourceRef.current;
          if (!source) return;
          const atlas = decorAtlasRef.current || Decor.getAtlas && Decor.getAtlas();
          const params = {
            treeDensity,
            buildingDensity,
            kerbWidthScale: kerbWidthScaleParam,
            shadowStrength: shadowStrengthParam,
          };
          const dpr = (typeof window !== "undefined" && window.devicePixelRatio) ? window.devicePixelRatio : 1;
          const worldScale = source.worldScale || 1;
          const seed = computeDecorSeed(source.trackKey, source.baseWorldWidth, source.baseWorldHeight);
          const signature = JSON.stringify({
            key: source.trackKey,
            seed,
            params,
            width: source.width,
            height: source.height,
            roadWidth: source.roadWidth,
            devicePixelRatio: dpr,
            worldScale,
              bounds: source.bounds ? [source.bounds.minX, source.bounds.minY, source.bounds.maxX, source.bounds.maxY] : null,
          });
          if (!force && decorSignatureRef.current === signature && decorLayerRef.current.decorCanvas) {
            return;
          }
          try {
            const existing = source.track && source.track.decor ? source.track.decor : null;
            const result = Decor.generate({
              width: source.width,
              height: source.height,
              baseWorldWidth: source.baseWorldWidth,
              baseWorldHeight: source.baseWorldHeight,
              roadWidth: source.roadWidth,
              centerline: source.centerline,
              maskCanvas: source.maskCanvas,
              params,
              atlas,
              seed,
              existing,
              force: force || !existing,
              worldScale,
              devicePixelRatio: dpr,
                bounds: source.bounds,
            });
            decorLayerRef.current = {
              decorCanvas: result.decorCanvas,
              shadowCanvas: result.shadowCanvas,
              metadata: result.metadata,
            };
            decorSignatureRef.current = signature;
            if (source.track) {
              source.track.decor = result.metadata;
            }
          } catch (err) {
            console.warn("Decor generation failed:", err);
            decorLayerRef.current = { decorCanvas: null, shadowCanvas: null, metadata: null };
            decorSignatureRef.current = null;
          }
        }

        function scheduleDecorGeneration(force = false) {
          if (!decorSourceRef.current) return;
          if (typeof requestIdleCallback === "function") {
            requestIdleCallback(() => runDecor(force));
          } else {
            setTimeout(() => runDecor(force), 0);
          }
        }

        function computeCameraZoom(speed) {
          const rawMax = 1.10;
          const startPx = mphToPx(clampZoomSpeed(zoomStartSpeed));
          const endPx = mphToPx(clampZoomSpeed(zoomFullSpeed));
          const start = Math.min(startPx, endPx);
          const end = Math.max(startPx, endPx);
          const range = Math.max(1, end - start);
          const normalized = speed <= start ? 0 : Math.min(1, (speed - start) / range);
          const span = resolveZoomSpan(zoomMaxDelta);
          const rawMin = Math.max(ZOOM_RAW_MIN_FLOOR, rawMax - span);
          const desired = rawMax - normalized * span;
          const rawTarget = Math.max(rawMin, Math.min(rawMax, desired));
          // Use base display scale (computed with fixed BASE_WORLD_W = 1000px) for consistent camera distance
          const baseDisplayScale = baseDisplayScaleRef.current || 1;
          const zoomFactor = cameraDistance || CAMERA_DEFAULT;
          const zoomBase = (CAM_BASE_ZOOM * zoomFactor) / ((baseDisplayScale > 0) ? baseDisplayScale : 1);
          const minZoom = rawMin * zoomBase;
          const maxZoom = rawMax * zoomBase;
          const targetZoom = Math.max(minZoom, Math.min(maxZoom, rawTarget * zoomBase));
          return { minZoom, maxZoom, targetZoom };
        }

        useEffect(() => {
          decorParamsRef.current = {
            treeDensity,
            buildingDensity,
            kerbWidthScale: kerbWidthScaleParam,
            shadowStrength: shadowStrengthParam,
          };
          try { localStorage.setItem("decorTreeDensity", String(treeDensity)); } catch (_) {}
          try { localStorage.setItem("decorBuildingDensity", String(buildingDensity)); } catch (_) {}
          try { localStorage.setItem("decorKerbWidthScale", String(kerbWidthScaleParam)); } catch (_) {}
          try { localStorage.setItem("decorShadowStrength", String(shadowStrengthParam)); } catch (_) {}
          scheduleDecorGeneration(true);
        }, [treeDensity, buildingDensity, kerbWidthScaleParam, shadowStrengthParam]);

        useEffect(() => {
          try { localStorage.setItem("decorSeedOffset", String(decorSeedOffset)); } catch (_) {}
          scheduleDecorGeneration(true);
        }, [decorSeedOffset]);

        useEffect(() => {
          if (typeof Decor === "undefined" || typeof Decor.loadAtlas !== "function") return;
          Decor.loadAtlas().then((img) => {
            decorAtlasRef.current = img;
            scheduleDecorGeneration(false);
          });
        }, []);

        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          const BASE_WORLD_W = 1000;
          const BASE_WORLD_H = 700;
          let W = BASE_WORLD_W, H = BASE_WORLD_H; // logical simulation size (was missing after refactor)
          // Offscreen track mask canvas (needed for onRoad() sampling) – was accidentally removed causing tctx reference errors
          const trackMap = document.createElement('canvas');
          trackMap.width = W; trackMap.height = H;
          trackMapRef.current = trackMap;
          const tctx = trackMap.getContext('2d');

          function sizeBackbufferToViewport() {
            const { w: vpW, h: vpH } = getViewportSize();
            const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
            const MAXW = 1920;
            const MAXH = 1080;

            // Target aspect ratio is 16:9 (1.78) which works well on desktop
            const TARGET_ASPECT = 16 / 9;
            const viewportAspect = vpW / vpH;

            let scaledW, scaledH;
            // Only apply aspect ratio correction for very wide screens (mobile landscape with notch, etc.)
            // Screens wider than 18:9 (2.0) get constrained to prevent stretching
            if (viewportAspect > 2.0) {
              // Viewport is much wider than 16:9 - fit to height with 16:9 aspect ratio
              scaledH = Math.max(240, Math.round(vpH));
              scaledW = Math.max(320, Math.round(scaledH * TARGET_ASPECT));
            } else {
              // Normal desktop/tablet aspect ratios - fill viewport as before
              scaledW = Math.max(320, Math.round(vpW));
              scaledH = Math.max(240, Math.round(vpH));
            }

            canvas.width = Math.min(Math.round(scaledW * dpr), MAXW);
            canvas.height = Math.min(Math.round(scaledH * dpr), MAXH);
            canvas.style.width = scaledW + 'px';
            canvas.style.height = scaledH + 'px';
            canvas.style.position = 'fixed';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            const pixelPerWorld = W > 0 ? (canvas.width / W) : 1;
            displayScaleRef.current = pixelPerWorld > 0 ? pixelPerWorld : 1;
            // Store base display scale (using fixed BASE_WORLD_W = 1000px) for consistent camera distance
            const pixelPerBaseWorld = BASE_WORLD_W > 0 ? (canvas.width / BASE_WORLD_W) : 1;
            baseDisplayScaleRef.current = pixelPerBaseWorld > 0 ? pixelPerBaseWorld : 1;
          }

          function adjustCanvasSize(){
            sizeBackbufferToViewport();
          }

          function applyWorldSize(width, height){
            const minW = 600;
            const minH = 420;
            const newW = Math.max(minW, Math.round(width || 1000));
            const newH = Math.max(minH, Math.round(height || 700));
            W = newW; H = newH;
            trackMap.width = W;
            trackMap.height = H;
            adjustCanvasSize();
          }

          // Attempt fullscreen upon first user interaction
          const fsOnce = () => { requestFullscreen(document.documentElement); adjustCanvasSize(); window.removeEventListener('pointerdown', fsOnce); };
          window.addEventListener('pointerdown', fsOnce, { once:true });
          window.addEventListener('resize', adjustCanvasSize);
          if (window.visualViewport) window.visualViewport.addEventListener('resize', adjustCanvasSize);
          adjustCanvasSize();

          // ====== State that depends on the active track ======
          // ===== Track Library (centerline points in pixels) =====
          const Tracks = {
            Silverstone: {
              spawn: { player: { x: 750, y: 145, angle: Math.PI }, ai: { x: 730, y: 145, angle: Math.PI } },
              startLine: { a: { x: 760, y: 95 }, b: { x: 760, y: 165 } },
              points: [
                { x: 780, y: 130 }, { x: 700, y: 120 }, { x: 650, y: 125 }, { x: 610, y: 150 },
                { x: 560, y: 190 }, { x: 540, y: 230 }, { x: 520, y: 280 }, { x: 500, y: 330 },
                { x: 460, y: 360 }, { x: 380, y: 380 }, { x: 310, y: 370 }, { x: 265, y: 340 },
                { x: 250, y: 300 }, { x: 270, y: 260 }, { x: 320, y: 240 }, { x: 380, y: 240 },
                { x: 440, y: 230 }, { x: 500, y: 220 }, { x: 460, y: 180 }, { x: 420, y: 150 },
                { x: 360, y: 140 }, { x: 305, y: 150 }, { x: 260, y: 180 }, { x: 240, y: 220 },
                { x: 250, y: 260 }, { x: 300, y: 300 }, { x: 380, y: 330 }, { x: 480, y: 360 },
                { x: 580, y: 380 }, { x: 680, y: 380 }, { x: 720, y: 360 }, { x: 740, y: 320 },
                { x: 730, y: 280 }, { x: 700, y: 250 }, { x: 660, y: 240 }, { x: 620, y: 230 },
                { x: 600, y: 200 }, { x: 610, y: 160 }, { x: 650, y: 130 }, { x: 700, y: 120 },
                { x: 780, y: 130 }
              ],
              speedZones: [
                [0, 32, 220], [32, 40, 170], [40, 60, 280], [60, 80, 180], [80, 100, 160]
              ],
              labels: [
                ["Hamilton", 730, 85], ["Village", 520, 230], ["Wellington", 340, 400],
                ["Luffield", 280, 250], ["Copse", 390, 135], ["Maggots/Becketts", 255, 170],
                ["Hangar", 610, 400], ["Stowe", 720, 350], ["Club", 640, 220]
              ],
              roadWidth: 80
            },

            // Le Mans – Bugatti layout approximation (based on provided image)
            "Le Mans": {
              spawn: { player: { x: 700, y: 520, angle: Math.PI }, ai: { x: 680, y: 520, angle: Math.PI } },
              startLine: { a: { x: 660, y: 490 }, b: { x: 660, y: 550 } },
              points: [
                { x: 720, y: 520 }, { x: 680, y: 520 }, { x: 640, y: 520 }, { x: 600, y: 520 },
                { x: 560, y: 520 }, { x: 520, y: 515 }, { x: 470, y: 510 }, { x: 420, y: 500 },
                { x: 380, y: 490 }, { x: 350, y: 480 }, { x: 320, y: 450 }, { x: 300, y: 420 }, { x: 290, y: 390 },
                { x: 280, y: 350 }, { x: 300, y: 320 }, { x: 340, y: 300 }, { x: 360, y: 330 }, { x: 380, y: 370 }, { x: 370, y: 420 }, { x: 350, y: 460 },
                { x: 330, y: 500 }, { x: 360, y: 520 }, { x: 400, y: 540 }, { x: 450, y: 530 }, { x: 480, y: 500 }, { x: 500, y: 470 },
                { x: 560, y: 450 }, { x: 620, y: 430 }, { x: 680, y: 420 }, { x: 740, y: 420 },
                { x: 720, y: 380 }, { x: 740, y: 340 }, { x: 770, y: 360 }, { x: 790, y: 390 },
                { x: 830, y: 420 }, { x: 880, y: 450 }, { x: 920, y: 490 }, { x: 900, y: 520 }, { x: 850, y: 520 }, { x: 800, y: 520 }, { x: 760, y: 520 },
                { x: 720, y: 520 }
              ],
              speedZones: [
                [0, 10, 280], [10, 18, 160], [18, 26, 170], [26, 30, 300], [30, 36, 180], [36, 41, 240], [41, 48, 220]
              ],
              labels: [
                ["Dunlop", 300, 345], ["La Chapelle", 320, 470], ["Musée", 390, 555], ["Garage Vert", 470, 520], ["Chemin aux Boeufs", 730, 350], ["S Bleus", 860, 420], ["Raccordement", 880, 510]
              ],
              roadWidth: 78
            },

            // New large kart-style track cloned from aerial image
            "Kart Park": {
              name: "Kart Park",
              ppm: 11, // pixels per meter (approx), 10 m road ≈ 110 px
              spawn: { player: { x: 220, y: 620, angle: 0 }, ai: { x: 200, y: 620, angle: 0 } },
              startLine: { a: { x: 250, y: 590 }, b: { x: 250, y: 650 } },
              points: [
                // Bottom straight → right hairpin → flowing S → left sector → back to straight
                {x: 150,y: 620}, {x: 240,y: 620}, {x: 360,y: 620}, {x: 500,y: 620}, {x: 640,y: 620}, {x: 780,y: 620},
                {x: 860,y: 610}, {x: 910,y: 590}, {x: 940,y: 555}, {x: 952,y: 510}, {x: 955,y: 470},
                {x: 943,y: 430}, {x: 915,y: 400}, {x: 870,y: 380}, {x: 810,y: 370}, {x: 740,y: 368},
                {x: 675,y: 378}, {x: 620,y: 402}, {x: 585,y: 438}, {x: 570,y: 480}, {x: 575,y: 520},
                {x: 600,y: 555}, {x: 640,y: 580}, {x: 700,y: 592}, {x: 760,y: 588}, {x: 810,y: 570},
                {x: 840,y: 540}, {x: 835,y: 505}, {x: 800,y: 475}, {x: 750,y: 455}, {x: 690,y: 445},
                {x: 620,y: 438}, {x: 560,y: 432}, {x: 500,y: 426}, {x: 440,y: 424}, {x: 380,y: 428},
                {x: 330,y: 442}, {x: 285,y: 470}, {x: 250,y: 505}, {x: 230,y: 545}, {x: 225,y: 585},
                {x: 235,y: 610}, {x: 260,y: 625}, {x: 300,y: 632}, {x: 350,y: 630}, {x: 410,y: 625},
                {x: 470,y: 622}, {x: 520,y: 620}, {x: 640,y: 620}, {x: 780,y: 620}, {x: 860,y: 610},
                {x: 150,y: 620}
              ],
              speedZones: [
                [0, 8, 300],     // bottom straight
                [8, 15, 150],    // right hairpin
                [15, 23, 200],   // flowing S
                [23, 30, 170],   // inner left
                [30, 40, 210],   // mid back to straight
                [40, 48, 260],   // accelerate to straight
                [48, 60, 300]
              ],
              labels: [
                ["Pits", 210, 570], ["Hairpin R", 940, 480], ["S-curve", 720, 380], ["Inner", 560, 510], ["Back straight", 700, 610]
              ],
              roadWidth: 80,
              kerbs: true,
              kerbColors: ["#d94848", "#ffffff"],
              drawScenery: function(ctx){
                // Parking at left-bottom
                ctx.save();
                ctx.fillStyle = "#2a2f36"; ctx.strokeStyle = "#3b4552"; ctx.lineWidth = 1.5;
                ctx.fillRect(110, 640, 240, 40); ctx.strokeRect(110, 640, 240, 40);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1; for(let i=0;i<8;i++){ const x=120+i*28; ctx.beginPath(); ctx.moveTo(x,642); ctx.lineTo(x,678); ctx.stroke(); }
                // Paddock/garage top-left
                ctx.fillStyle = "#2a2f36"; ctx.fillRect(120, 460, 150, 80); ctx.strokeStyle="#3b4552"; ctx.strokeRect(120,460,150,80);
                // Trees top border
                ctx.fillStyle = "#1d4222"; for(let i=0;i<20;i++){ const x=40+i*48; ctx.beginPath(); ctx.arc(x, 40, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                ctx.restore();
              }
            },

            // Precise clone of provided aerial track (Windey.png)
            "Windey": {
              name: "Windey",
              ppm: 11, // ~11 px per meter; road ≈ 10m → ~110 px
              spawn: { player: { x: 260, y: 620, angle: 0 }, ai: { x: 240, y: 620, angle: 0 } },
              startLine: { a: { x: 250, y: 590 }, b: { x: 250, y: 650 } },
              // Centerline traced against image proportions (fits 1000x700 canvas)
              points: [
                {x:140,y:618}, {x:220,y:620}, {x:300,y:622}, {x:380,y:626}, {x:460,y:628}, {x:540,y:628}, {x:620,y:626}, {x:700,y:624}, {x:780,y:622}, {x:860,y:616},
                {x:900,y:600}, {x:928,y:580}, {x:945,y:555}, {x:954,y:522}, {x:956,y:488}, {x:952,y:452}, {x:940,y:420}, {x:918,y:396}, {x:888,y:382}, {x:850,y:374},
                {x:806,y:372}, {x:760,y:374}, {x:710,y:384}, {x:668,y:404}, {x:634,y:432}, {x:612,y:468}, {x:606,y:506}, {x:614,y:544}, {x:640,y:573}, {x:680,y:592},
                {x:728,y:598}, {x:778,y:592}, {x:820,y:575}, {x:846,y:548}, {x:850,y:516}, {x:834,y:486}, {x:804,y:464}, {x:764,y:452}, {x:720,y:446}, {x:672,y:444},
                {x:626,y:444}, {x:578,y:442}, {x:530,y:438}, {x:482,y:432}, {x:438,y:428}, {x:394,y:430}, {x:352,y:438}, {x:314,y:456}, {x:283,y:482}, {x:260,y:514},
                {x:246,y:552}, {x:244,y:588}, {x:254,y:612}, {x:280,y:628}, {x:318,y:636}, {x:364,y:640}, {x:414,y:638}, {x:468,y:634}, {x:526,y:630}, {x:586,y:626},
                {x:650,y:624}, {x:720,y:624}, {x:800,y:622}, {x:880,y:616}, {x:920,y:602}, {x:140,y:618}
              ],
              speedZones: [
                [0, 10, 280],    // bottom straight
                [10, 20, 140],   // right hairpin climb
                [20, 30, 190],   // top sweep
                [30, 42, 170],   // mid technical
                [42, 52, 210],   // inner back
                [52, 66, 260]    // exit to straight
              ],
              labels: [["Pits", 210, 570], ["Hairpin", 930, 490], ["S sweep", 700, 420], ["Inner", 540, 520], ["Main straight", 600, 640]],
              roadWidth: 80, // base width before WIDTH_SCALE adjustment
              kerbs: true,
              kerbColors: ["#d94848", "#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                // Parking lot (left)
                ctx.fillStyle = "#2a2f36"; ctx.strokeStyle = "#3b4552"; ctx.lineWidth = 1.5;
                ctx.fillRect(80, 560, 260, 100); ctx.strokeRect(80, 560, 260, 100);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1; for(let i=0;i<8;i++){ const x=95+i*30; ctx.beginPath(); ctx.moveTo(x,565); ctx.lineTo(x,655); ctx.stroke(); }
                // Parked cars (scaled to GT size: ~18x38 px)
                function car(x,y,a){ ctx.save(); ctx.translate(x,y); ctx.rotate(a||0); const w=20, l=44; ctx.fillStyle="#1b1f27"; ctx.fillRect(-w/2,-l/2,w,l); ctx.fillStyle="#eaeef5"; ctx.fillRect(-w*0.35,-l*0.35,w*0.70,l*0.22); ctx.restore(); }
                car(120,585,0); car(150,585,0); car(180,585,0); car(210,585,0);
                // Paddock building near left edge
                ctx.fillStyle="#303744"; ctx.fillRect(90, 500, 180, 50); ctx.strokeStyle="#475166"; ctx.strokeRect(90,500,180,50);
                // Pit lane strip along bottom straight
                ctx.fillStyle = "#3a3f47"; ctx.fillRect(180, 602, 420, 22);
                // Trees top border
                ctx.fillStyle = "#1d4222"; for(let i=0;i<22;i++){ const x=40+i*44; ctx.beginPath(); ctx.arc(x, 40, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                // Tire marks near inner and hairpin (faded)
                ctx.strokeStyle = "rgba(0,0,0,0.18)"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(760,470); ctx.quadraticCurveTo(700,500,660,560); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(930,520); ctx.quadraticCurveTo(900,470,850,440); ctx.stroke();
                ctx.restore();
              }
            },

            // Exact clone attempt of Windey.png (closer tracing)
            "Windey Clone": {
              name: "Windey Clone",
              ppm: 11,
              spawn: { player: { x: 210, y: 640, angle: 0 }, ai: { x: 190, y: 640, angle: 0 } },
              startLine: { a: { x: 235, y: 612 }, b: { x: 235, y: 668 } },
              points: [
                // Bottom main straight (left → right)
                {x:140,y:646},{x:200,y:646},{x:260,y:646},{x:320,y:646},{x:380,y:646},{x:440,y:646},{x:500,y:646},{x:560,y:646},{x:620,y:646},{x:680,y:646},{x:740,y:644},{x:800,y:642},{x:860,y:636},{x:900,y:624},
                // Up to top-right hairpin
                {x:930,y:600},{x:952,y:568},{x:962,y:530},{x:964,y:492},{x:960,y:456},{x:946,y:420},{x:920,y:396},
                // Upper sweep (right → left)
                {x:884,y:382},{x:842,y:372},{x:796,y:366},{x:748,y:364},{x:702,y:366},{x:656,y:374},{x:616,y:392},{x:584,y:418},{x:562,y:450},
                // Drop to inner straight then curve around central island clockwise
                {x:556,y:486},{x:564,y:520},{x:588,y:550},{x:620,y:570},{x:662,y:582},{x:702,y:584},{x:736,y:578},{x:768,y:564},{x:790,y:544},{x:800,y:520},{x:796,y:494},{x:780,y:470},{x:754,y:454},{x:720,y:446},{x:682,y:444},{x:642,y:448},{x:604,y:458},{x:568,y:472},
                // Exit inner to left side and down toward main straight
                {x:532,y:492},{x:500,y:516},{x:476,y:546},{x:464,y:576},{x:464,y:606},{x:476,y:628},{x:504,y:640},{x:542,y:646},{x:586,y:648},{x:632,y:648},{x:680,y:648},{x:728,y:646},{x:776,y:642},{x:824,y:638},{x:872,y:634},{x:900,y:626},
                // Close loop back along main straight
                {x:820,y:642},{x:760,y:646},{x:700,y:648},{x:640,y:648},{x:580,y:648},{x:520,y:648},{x:460,y:648},{x:400,y:648},{x:340,y:648},{x:280,y:648},{x:220,y:648},{x:160,y:648},{x:140,y:646}
              ],
              speedZones: [
                [0, 14, 300],     // main straight
                [14, 22, 140],    // hairpin
                [22, 31, 200],    // upper sweep
                [31, 46, 180],    // inner loop
                [46, 60, 220]     // exit to straight
              ],
              labels: [["Pits", 210, 600],["Hairpin", 950, 490],["S sweep", 700, 370],["Inner", 600, 530],["Main straight", 520, 660]],
              roadWidth: 80,
              kerbs: true,
              kerbColors: ["#d94848","#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                // Parking + paddock (top-left)
                ctx.fillStyle="#b7bcc4"; ctx.fillRect(60, 510, 300, 170); // light concrete
                ctx.strokeStyle="#3b4552"; ctx.lineWidth=1.5; ctx.strokeRect(60,510,300,170);
                // Pit building (long dark bar)
                ctx.fillStyle="#2f3540"; ctx.fillRect(120, 520, 220, 40); ctx.strokeStyle="#475166"; ctx.strokeRect(120,520,220,40);
                // Grid boxes on main straight near left
                ctx.strokeStyle="#9aa5b1"; ctx.lineWidth=1; for(let i=0;i<10;i++){ const gx=190+i*32; ctx.beginPath(); ctx.moveTo(gx,632); ctx.lineTo(gx,664); ctx.stroke(); }
                // Trees top border
                ctx.fillStyle="#1d4222"; for(let i=0;i<22;i++){ const x=40+i*44; ctx.beginPath(); ctx.arc(x, 36, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                // Parked cars
                function car(x,y,a){ ctx.save(); ctx.translate(x,y); ctx.rotate(a||0); const w=20,l=44; ctx.fillStyle="#1b1f27"; ctx.fillRect(-w/2,-l/2,w,l); ctx.fillStyle="#eaeef5"; ctx.fillRect(-w*0.35,-l*0.35,w*0.7,l*0.22); ctx.restore(); }
                car(100,560,0); car(130,560,0); car(160,560,0); car(190,560,0); car(220,560,0);
                // Mown grass diagonal lines inside infield
                ctx.strokeStyle="rgba(255,255,255,0.07)"; ctx.lineWidth=1; for(let i=0;i<6;i++){ ctx.beginPath(); ctx.moveTo(520+i*24, 460); ctx.lineTo(720+i*24, 600); ctx.stroke(); }
                // Tire marks (hairpin and inside loop)
                ctx.strokeStyle="rgba(0,0,0,0.18)"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(945,520); ctx.quadraticCurveTo(900,460,850,430); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(760,470); ctx.quadraticCurveTo(700,510,660,560); ctx.stroke();
                ctx.restore();
              }
            },

            "Windey Circuit": {
              name: "Windey Circuit",
              ppm: 11,
              spawn: { player: { x: 250, y: 640, angle: 0 }, ai: { x: 230, y: 640, angle: 0 } },
              startLine: { a: { x: 240, y: 608 }, b: { x: 240, y: 664 } },
              points: [
                {x:210,y:642},{x:260,y:650},{x:320,y:656},{x:380,y:660},{x:440,y:662},{x:500,y:664},{x:560,y:662},{x:620,y:656},{x:680,y:646},{x:740,y:632},{x:800,y:612},{x:860,y:586},{x:902,y:556},{x:932,y:522},{x:950,y:484},{x:954,y:444},{x:942,y:404},{x:916,y:368},{x:878,y:342},{x:832,y:328},{x:780,y:322},{x:724,y:324},{x:670,y:332},{x:620,y:348},{x:578,y:370},{x:542,y:398},{x:514,y:432},{x:498,y:470},{x:494,y:510},{x:504,y:548},{x:528,y:584},{x:564,y:612},{x:608,y:628},{x:656,y:634},{x:704,y:632},{x:750,y:622},{x:792,y:604},{x:820,y:580},{x:832,y:548},{x:826,y:516},{x:806,y:488},{x:774,y:468},{x:732,y:456},{x:688,y:452},{x:642,y:456},{x:598,y:468},{x:560,y:486},{x:528,y:512},{x:502,y:544},{x:488,y:580},{x:486,y:620},{x:498,y:656},{x:522,y:686},{x:556,y:706},{x:600,y:714},{x:648,y:712},{x:694,y:700},{x:736,y:680},{x:772,y:652},{x:796,y:620},{x:804,y:584},{x:796,y:552},{x:772,y:524},{x:736,y:506},{x:692,y:498},{x:646,y:500},{x:602,y:510},{x:562,y:530},{x:528,y:558},{x:502,y:592},{x:486,y:630},{x:474,y:662},{x:452,y:680},{x:416,y:686},{x:372,y:682},{x:324,y:670},{x:276,y:654},{x:232,y:642}
              ],
              speedZones: [
                [0, 12, 300],
                [12, 20, 150],
                [20, 30, 190],
                [30, 46, 200],
                [46, 66, 230]
              ],
              labels: [["Pits", 220, 602], ["Hairpin", 948, 500], ["North Sweep", 720, 336], ["Inner Loop", 600, 540], ["Main Straight", 540, 676]],
              roadWidth: 82,
              kerbs: true,
              kerbColors: ["#d94848", "#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle = "#bfc5cc";
                ctx.fillRect(60, 508, 300, 174);
                ctx.strokeStyle = "#8f96a5"; ctx.lineWidth = 1.4; ctx.strokeRect(60, 508, 300, 174);

                ctx.fillStyle = "#2f3540"; ctx.fillRect(118, 520, 232, 38);
                ctx.strokeStyle = "#475166"; ctx.strokeRect(118, 520, 232, 38);
                ctx.fillStyle = "#dcd6c8"; ctx.fillRect(120, 562, 74, 18);

                ctx.fillStyle = "#3a3f33"; ctx.fillRect(72, 598, 86, 72);
                ctx.fillStyle = "#d2c59a"; ctx.fillRect(86, 606, 58, 34);

                ctx.fillStyle = "#3f434a"; ctx.fillRect(200, 628, 420, 20);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1;
                for (let i = 0; i < 11; i++) {
                  const gx = 210 + i * 36;
                  ctx.beginPath(); ctx.moveTo(gx, 624); ctx.lineTo(gx, 666); ctx.stroke();
                }

                ctx.fillStyle = "#1c3f1f";
                for (let i = 0; i < 24; i++) {
                  const x = 40 + i * 42;
                  ctx.beginPath(); ctx.arc(x, 34 + (i % 2) * 2, 10 + (i % 3), 0, Math.PI * 2); ctx.fill();
                }

                ctx.fillStyle = "rgba(180,190,120,0.4)";
                ctx.beginPath(); ctx.moveTo(520, 428); ctx.lineTo(700, 612); ctx.lineTo(540, 624); ctx.lineTo(500, 500); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                  ctx.beginPath();
                  ctx.moveTo(540 + i * 26, 420);
                  ctx.lineTo(700 + i * 18, 610);
                  ctx.stroke();
                }

                function car(x, y, angle) {
                  ctx.save();
                  ctx.translate(x, y); ctx.rotate(angle || 0);
                  const w = 20, l = 44;
                  ctx.fillStyle = "#1a1f27"; ctx.fillRect(-w / 2, -l / 2, w, l);
                  ctx.fillStyle = "#e8edf4"; ctx.fillRect(-w * 0.35, -l * 0.35, w * 0.7, l * 0.22);
                  ctx.restore();
                }
                for (let i = 0; i < 7; i++) car(110 + i * 32, 560, 0);
                car(98, 612, -0.05); car(138, 614, 0.02);

                ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(944, 520); ctx.quadraticCurveTo(900, 460, 838, 430); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(780, 480); ctx.quadraticCurveTo(720, 520, 660, 570); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(600, 612); ctx.quadraticCurveTo(560, 592, 520, 552); ctx.stroke();

                ctx.restore();
              }
            },

            "Night Loop": {
              name: "Night Loop",
              ppm: 12.5, // ~12.5 px/m so 116 * 1.375 ≈ 160 px ≈ 8x car width
              spawn: { player: { x: 260, y: 640, angle: 0 }, ai: { x: 240, y: 640, angle: 0 } },
              startLine: { a: { x: 250, y: 604 }, b: { x: 250, y: 664 } },
              points: [
                {x:150,y:640},{x:220,y:652},{x:300,y:658},{x:380,y:660},{x:460,y:658},{x:540,y:652},{x:620,y:640},{x:690,y:618},{x:740,y:582},{x:780,y:536},{x:810,y:486},{x:830,y:430},{x:840,y:370},{x:832,y:320},{x:800,y:280},{x:750,y:258},{x:690,y:260},{x:640,y:286},{x:600,y:326},{x:560,y:366},{x:510,y:396},{x:460,y:402},{x:410,y:382},{x:360,y:350},{x:312,y:320},{x:268,y:310},{x:230,y:328},{x:206,y:364},{x:190,y:412},{x:182,y:468},{x:184,y:530},{x:198,y:586},{x:224,y:618},{x:260,y:632},{x:310,y:640}
              ],
              speedZones: [
                [0, 8, 300],
                [8, 16, 220],
                [16, 22, 180],
                [22, 28, 200],
                [28, 35, 240]
              ],
              labels: [["Pit Entry", 240, 608],["North Rim", 805, 300],["Esses", 600, 340],["Carousel", 450, 392],["Night Straight", 500, 648]],
              roadWidth: 116,
              kerbs: true,
              kerbColors: ["#ff6b6b", "#f4f1de"],
              drawScenery: function(ctx){
                ctx.save();
                // Background night canvas
                ctx.fillStyle = "#04070d";
                ctx.fillRect(0, 0, 1000, 700);

                // Halo glow around circuit using broad stroke
                ctx.strokeStyle = "rgba(40,60,120,0.25)";
                ctx.lineWidth = 220;
                ctx.lineJoin = "round";
                ctx.beginPath();
                for (let i = 0; i < centerline.length; i++) {
                  const p = centerline[i];
                  if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.stroke();

                // Pit boxes on main straight
                ctx.fillStyle = "#2a2e39";
                ctx.fillRect(200, 622, 420, 26);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                  const x = 210 + i * 34;
                  ctx.beginPath(); ctx.moveTo(x, 620); ctx.lineTo(x, 650); ctx.stroke();
                }

                // Barriers along outside (simple dashed arcs)
                ctx.save();
                ctx.strokeStyle = "rgba(255,255,255,0.18)";
                ctx.lineWidth = 8; ctx.setLineDash([16, 12]);
                ctx.beginPath();
                for (let i = 0; i < centerline.length; i++) {
                  const p = centerline[i];
                  if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();

                // Soft lights speckled around track edges
                ctx.fillStyle = "rgba(255,214,120,0.35)";
                const lightPoints = [
                  [195,630],[230,645],[320,658],[410,656],[500,650],[585,640],[660,622],[712,590],[752,548],[790,498],[812,440],[820,380],[804,330],[760,300],[706,296],[640,315],[590,356],[540,396],[480,410],[420,390],[360,350],[300,320],[240,330],[206,380],[196,440],[198,512],[212,570],[240,606]
                ];
                for (const [x,y] of lightPoints){ ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill(); }

                ctx.restore();
              }
            }
          };
          let ROAD_WIDTH = 80 * WIDTH_SCALE;
          let centerline = [];
          let startLine = null;
          let startGrid = null;
          let waypoints = [];
          let labels = [];
          const customTrackCache = new Map();
          const customTrackPromises = new Map();
          let trackData = null;
          let activeTrack = null; // keep current track config
          let trackBounds = null; // world-space bbox
          let checkpoints = [];   // [{a:{x,y}, b:{x,y}}]
          let planckSegments = [];
          let planckPPM = 30;
          let planckNeedsSync = false;

          // Cars and sim state
          function makeCar({ x, y, angle, color, kind = 'GT', steeringMode }) {
            const prof = CarProfiles[kind] || CarProfiles.GT;
            const width = prof.width, length = prof.length;
            const colliderWidth = prof.colliderWidth ?? width;
            const colliderLength = prof.colliderLength ?? length;
            const stats = { maxK: prof.maxK, accelK: prof.accelK, brakeK: prof.brakeK, turnK: prof.turnK };
            if (!color) color = prof.color;
            const mode = steeringMode === "touch" ? "touch" : "manual";
            const car = { x, y, angle, speed: 0, width, length, colliderWidth, colliderLength, color, kind, stats,
                          lap: 0, lastCross: 0, bestLap: null, lapStart: performance.now(),
                          vx: 0, vy: 0, targetIndex: 0, speedBias: 0,
                          steerVis: 0, skidLPrev: null, skidRPrev: null, steeringMode: mode,
                          aiController: null };
            try { if (window.RacerPhysics) window.RacerPhysics.initCar(car, kind); } catch(_){}
            return car;
          }
          const steeringModePreference = getSteeringModeSetting();
          const player = makeCar({ x: 0, y: 0, angle: 0, color: "#e53935", kind: getInitialCar(), steeringMode: steeringModePreference });
          // --- Speedometer init ---
          let speedoCtrl = null;
          let speedoScriptRequested = false;
          function ensureSpeedometerScript(){
            if (window.RacerUI && window.RacerUI.Speedometer) return true;
            if (speedoScriptRequested) return false;
            const script = document.createElement('script');
            script.src = `ui/speedometer.js?v=${Date.now()}`;
            script.defer = true;
            script.onload = () => {
              speedoScriptRequested = false;
              tryInitSpeedometer();
            };
            script.onerror = () => { speedoScriptRequested = false; };
            document.head.appendChild(script);
            speedoScriptRequested = true;
            return false;
          }
          function tryInitSpeedometer(){
            if (speedoCtrl) return;
            if (!(window.RacerUI && window.RacerUI.Speedometer)) {
              ensureSpeedometerScript();
              return;
            }
            try {
              speedoCtrl = window.RacerUI.Speedometer.init({ bottomOffset: 10, width: 420, mphMax: 180, smoothing: 0.18 });
            } catch (err) {
              console.warn('Speedometer init failed', err);
            }
          }
          ensureSpeedometerScript();
          tryInitSpeedometer();
          window.playerCar = player;
          const loadGearboxModule = () => {
            if (window.GearboxModule) return Promise.resolve(window.GearboxModule);
            if (window.__gearboxModulePromise) return window.__gearboxModulePromise;
            let loader;
            if (typeof window.importShim === 'function') {
              loader = window.importShim('./gearbox.js');
            } else {
              loader = eval('import("./gearbox.js")');
            }
            window.__gearboxModulePromise = loader.then((mod) => {
              window.GearboxModule = mod;
              return mod;
            }).catch((err) => {
              window.__gearboxModulePromise = null;
              throw err;
            });
            return window.__gearboxModulePromise;
          };
          loadGearboxModule().then(mod => {
            const { Gearbox, gearboxDefaults } = mod;
            window.GEARBOX_DEFAULTS = { ...gearboxDefaults };
            let stored = null;
            try { stored = JSON.parse(localStorage.getItem('gearboxCfg_activeProfile') || 'null'); } catch(_){}
            const gbxCfg = stored ? { ...gearboxDefaults, ...stored } : { ...gearboxDefaults };
            player.gearbox = new Gearbox(gbxCfg);
            try { if (window.RacerPhysics) window.RacerPhysics.initCar(player, player.kind); } catch(_){}
          }).catch(err => console.warn('Gearbox init failed', err));
          const DEFAULT_AI_CAR_COUNT = 9;
          const LAPS_TO_FINISH = 3;
          let aiCars = []; // array of AI cars
          let racingLine = [];
          let baseRacingLine = [];
          let anchorRacingLine = [];
          let mcpRacingLine = [];
          let anchorValidation = null;
          let mcpValidation = null;
          let aiDifficulty = initialAIDifficulty;
          function buildControllerPreset(){
            const overrides = aiControlsRef.current;
            if (!overrides) return aiDifficulty;
            const base = getAISkillDefaults(overrides.difficulty || aiDifficulty);
            return {
              ...base,
              maxThrottle: overrides.maxThrottle,
              brakeAggro: overrides.brakeAggro,
              steerP: overrides.steerP,
              lookaheadBase: overrides.lookaheadBase,
              lookaheadSpeed: overrides.lookaheadSpeed,
              cornerMargin: overrides.cornerMargin,
              id: (overrides.difficulty || base.id || aiDifficulty)
            };
          }
          function rebuildAIControllers(){
            const ready = racingLine.length && window.RacerAI && typeof window.RacerAI.createController === "function";
            if (!ready) {
              for (const car of aiCars) car.aiController = null;
              return;
            }
            const preset = buildControllerPreset();
            for (const car of aiCars){
              car.aiController = window.RacerAI.createController(racingLine, preset, car);
            }
          }
          // Sync AI car gearboxes to match player's gearbox config when "Clone Player Gearbox" is enabled
          function syncAIGearboxes(){
            const shouldClone = clonePlayerGearboxRef.current;
            if (!shouldClone || !player || !player.gearbox) return;
            const playerGbxConfig = player.gearbox.c;
            if (!playerGbxConfig) return;
            const GearboxClass = window.GearboxModule && window.GearboxModule.Gearbox;
            if (!GearboxClass) return;
            for (const car of aiCars){
              if (!car) continue;
              // Create a new gearbox with the player's config for this AI car
              car.gearbox = new GearboxClass({ ...playerGbxConfig });
            }
          }
          function setAIDifficulty(level, persist = true, options = {}){
            const next = sanitizeDifficulty(level);
            if (!next) return false;
            aiDifficulty = next;
            if (persist){
              try { localStorage.setItem(AI_DIFFICULTY_KEY, aiDifficulty); } catch(_){ }
            }
            if (options.syncControls !== false){
              const defaults = getAISkillDefaults(next);
              setAIControls((prev) => ({
                ...prev,
                difficulty: next,
                lookaheadBase: defaults.lookaheadBase ?? prev.lookaheadBase,
                lookaheadSpeed: defaults.lookaheadSpeed ?? prev.lookaheadSpeed,
                steerP: defaults.steerP ?? prev.steerP,
                maxThrottle: defaults.maxThrottle ?? prev.maxThrottle,
                brakeAggro: defaults.brakeAggro ?? prev.brakeAggro,
                cornerMargin: defaults.cornerMargin ?? prev.cornerMargin
              }));
            }
            rebuildAIControllers();
            return true;
          }
          function applyAiLineOverrides({ forceCustom = false } = {}){
            if (!centerline.length) return;
            const defaults = getLineDefaults();
            const overrides = aiControlsRef.current;
            const skillDefaults = getAISkillDefaults((overrides && overrides.difficulty) || aiDifficulty);
            const apex = overrides ? overrides.apexAggression : defaults.apexAggression;
            const maxOffset = overrides ? overrides.maxOffset : defaults.maxOffset;
            const throttleSetting = overrides && Number.isFinite(overrides.maxThrottle)
              ? overrides.maxThrottle
              : (skillDefaults.maxThrottle ?? AI_SKILL_FALLBACK.maxThrottle ?? 1);
            const throttleScale = mapMaxThrottleToSpeedScale(throttleSetting);
            const canUseBase = baseRacingLine && baseRacingLine.length && !forceCustom &&
              approxEqual(apex, defaults.apexAggression ?? apex) &&
              approxEqual(maxOffset, defaults.maxOffset ?? maxOffset);
            const scaleLine = (source) => {
              if (!source || !source.length) return [];
              return source.map((node) => ({
                ...node,
                targetSpeed: Math.min(MAX_AI_TARGET_SPEED, (node.targetSpeed || 0) * throttleScale)
              }));
            };
            // Helper: Generate both racing lines and validation
            function generateBothRacingLines(opts) {
              const anchorOpts = { ...opts, mode: 'anchor' };
              const builtAnchorLine = window.RacerAI.generateRacingLine(centerline, ROAD_WIDTH, anchorOpts) || [];
              const scaledAnchor = scaleLine(builtAnchorLine);
              
              let scaledMcp = scaledAnchor; // Fallback
              let mcpVal = null;
              
              if (window.McpRacingLine && window.McpRacingLine.generateMcpLine) {
                const mcpOpts = { ...opts, mode: 'mcp' };
                const builtMcpLine = window.RacerAI.generateRacingLine(centerline, ROAD_WIDTH, mcpOpts) || [];
                scaledMcp = scaleLine(builtMcpLine);
                
                // Validate both lines
                if (window.RacingLineValidation && window.RacingLineValidation.validateRacingLine) {
                  mcpVal = window.RacingLineValidation.validateRacingLine(centerline, ROAD_WIDTH, builtMcpLine);
                }
              }
              
              const anchorVal = window.RacingLineValidation && window.RacingLineValidation.validateRacingLine
                ? window.RacingLineValidation.validateRacingLine(centerline, ROAD_WIDTH, builtAnchorLine)
                : null;
              
              return { scaledAnchor, scaledMcp, anchorVal, mcpVal };
            }
            
            if (canUseBase) {
              racingLine = scaleLine(baseRacingLine);
            } else {
              if (!window.RacerAI || typeof window.RacerAI.generateRacingLine !== "function") {
                const fallbackLine = baseRacingLine.length ? baseRacingLine : racingLine;
                racingLine = scaleLine(fallbackLine);
              } else {
                const opts = { straightSpeed: (window.RacerAI.DEFAULT_LINE_CFG && window.RacerAI.DEFAULT_LINE_CFG.straightSpeed) || 520 };
                if (typeof apex === "number") opts.apexAggression = apex;
                if (typeof maxOffset === "number") opts.maxOffset = maxOffset;
                
                const { scaledAnchor, scaledMcp, anchorVal, mcpVal } = generateBothRacingLines(opts);
                anchorRacingLine = scaledAnchor;
                mcpRacingLine = scaledMcp;
                anchorValidation = anchorVal;
                mcpValidation = mcpVal;
                
                // Use the selected mode for active racing line
                const currentMode = racingLineModeRef.current || 'anchor';
                racingLine = currentMode === 'mcp' ? mcpRacingLine : anchorRacingLine;
              }
            }
            if (activeTrack) {
              activeTrack.racingLine = racingLine;
              activeTrack.anchorRacingLine = anchorRacingLine;
              activeTrack.mcpRacingLine = mcpRacingLine;
            }
            rebuildAIControllers();
          }
          function updateAiControlValue(key, value){
            if (!Number.isFinite(value)) return;
            const limits = AI_CONTROL_LIMITS[key];
            const bounded = limits ? clamp(value, limits.min, limits.max) : value;
            setAIControls((prev) => {
              if (prev[key] === bounded) return prev;
              return { ...prev, [key]: bounded };
            });
          }
          applyAiLineOverridesRef.current = applyAiLineOverrides;
          rebuildAIControllersRef.current = rebuildAIControllers;
          syncAIGearboxesRef.current = syncAIGearboxes;
          setAIDifficultyRef.current = setAIDifficulty;
          updateAiControlValueRef.current = updateAiControlValue;
          (function exposeAISettings(){
            const api = window.RacerAISettings || (window.RacerAISettings = {});
            api.getDifficulty = () => aiDifficulty;
            api.setDifficulty = (value) => setAIDifficulty(value, true);
            api.listDifficulties = () => AVAILABLE_AI_DIFFICULTIES.slice();
          })();

          const keys = { w: false, s: false, a: false, d: false };
          const gamepadShiftPrev = { up: false, down: false };

          // Normalized handling constants (reduced from earlier boosted values for mobile stability)
          const MAX_SPEED_ROAD = 340, MAX_SPEED_GRASS = 135; // lowered top speed
          const ACCEL = 480, BRAKE = 400; // gentler acceleration/braking
          const FRICTION_ROAD = 0.985, FRICTION_GRASS = 0.93; // slight extra damping
          const TURN_RATE = 3.4; // reduced steering responsiveness

          function interpolate(points, step = 6) {
            const pts = [];
            for (let i = 0; i < points.length - 1; i++) {
              const a = points[i], b = points[i + 1];
              const dx = b.x - a.x, dy = b.y - a.y;
              const dist = Math.hypot(dx, dy);
              const n = Math.max(1, Math.floor(dist / step));
              for (let j = 0; j < n; j++) {
                const t = j / n;
                pts.push({ x: a.x + dx * t, y: a.y + dy * t });
              }
            }
            return pts;
          }

          function buildWaypoints(centerline, zones) {
            const pts = [];
            for (let i = 0; i < centerline.length; i += 24) {
              const pt = centerline[i];
              // default
              let speed = 240;
              for (const [a,b,s] of zones) {
                if (i/24 >= a && i/24 < b) { speed = s; break; }
              }
              pts.push({ x: pt.x, y: pt.y, speed });
            }
            return pts;
          }

          function scalePoint(p, cx, cy, scale) {
            return { x: cx + (p.x - cx) * scale, y: cy + (p.y - cy) * scale };
          }

          function bbox(pts){
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            for (const p of pts){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
            return {minX, minY, maxX, maxY, w:maxX-minX, h:maxY-minY};
          }

          function drawLayerImage(ctx, image, mapping, regionX, regionY, regionW, regionH) {
            if (!image) return;
            ctx.imageSmoothingEnabled = false;
            const hasMapping = mapping && typeof mapping.worldToTex === "number" && mapping.worldToTex > 0;
            if (!hasMapping) {
              const imgW = image.width || 0;
              const imgH = image.height || 0;
              const srcX0 = Math.max(0, regionX);
              const srcY0 = Math.max(0, regionY);
              const srcX1 = Math.min(imgW, regionX + regionW);
              const srcY1 = Math.min(imgH, regionY + regionH);
              const srcW = srcX1 - srcX0;
              const srcH = srcY1 - srcY0;
              if (srcW <= 0 || srcH <= 0) return;
              ctx.drawImage(image, srcX0, srcY0, srcW, srcH, srcX0, srcY0, srcW, srcH);
              return;
            }

            const worldMinX = mapping.worldMinX || 0;
            const worldMinY = mapping.worldMinY || 0;
            const worldWidth = mapping.worldWidth || (image.width * (mapping.texToWorld || 1));
            const worldHeight = mapping.worldHeight || (image.height * (mapping.texToWorld || 1));
            const worldMaxX = worldMinX + worldWidth;
            const worldMaxY = worldMinY + worldHeight;
            const clipX0 = Math.max(regionX, worldMinX);
            const clipY0 = Math.max(regionY, worldMinY);
            const clipX1 = Math.min(regionX + regionW, worldMaxX);
            const clipY1 = Math.min(regionY + regionH, worldMaxY);
            const clipW = clipX1 - clipX0;
            const clipH = clipY1 - clipY0;
            if (clipW <= 0 || clipH <= 0) return;

            const worldToTex = mapping.worldToTex || 1;
            const srcX = Math.max(0, Math.floor((clipX0 - worldMinX) * worldToTex));
            const srcY = Math.max(0, Math.floor((clipY0 - worldMinY) * worldToTex));
            const srcW = Math.min(image.width - srcX, Math.ceil(clipW * worldToTex));
            const srcH = Math.min(image.height - srcY, Math.ceil(clipH * worldToTex));
            if (srcW <= 0 || srcH <= 0) return;

            ctx.drawImage(image, srcX, srcY, srcW, srcH, clipX0, clipY0, clipW, clipH);
          }

          function clamp(value, min, max){
            return Math.min(max, Math.max(min, value));
          }
          function approxEqual(a, b, eps = 1e-3){
            return Math.abs((a || 0) - (b || 0)) <= eps;
          }

          function convertCustomEntry(entry){
            if (!entry || !entry.data) throw new Error("Track bundle missing data");
            const data = entry.data;
            const rawPoints = Array.isArray(data.points) ? data.points : [];
            const points = rawPoints.map((p) => ({ x: Number(p && p.x) || 0, y: Number(p && p.y) || 0 }));
            const worldSrc = data.world || {};
            const world = {
              width: Number(worldSrc.width) || 1000,
              height: Number(worldSrc.height) || 700,
              scale: Number(worldSrc.scale) || undefined
            };
            const name = data.name || entry.name || "Custom Track";
            const speedZones = Array.isArray(data.speedZones) && data.speedZones.length ? data.speedZones : [[0, Math.max(1, Math.floor(points.length / 24) || 1), 220]];
            const labels = Array.isArray(data.labels) && data.labels.length ? data.labels : [[name, world.width * 0.5, world.height * 0.5]];
            const fallbackA = points[0] || { x: world.width * 0.5, y: world.height * 0.5 };
            const fallbackB = points[1] || { x: fallbackA.x + 40, y: fallbackA.y };
            const clonePoint = (src, fallback) => ({
              x: Number(src && src.x) || fallback.x || 0,
              y: Number(src && src.y) || fallback.y || 0,
              angle: typeof (src && src.angle) === "number" ? src.angle : undefined
            });
            const startA = clonePoint(data.startLine && data.startLine.a, fallbackA);
            const startB = clonePoint(data.startLine && data.startLine.b, fallbackB);
            const defaultAngle = Math.atan2((startB.y || 0) - (startA.y || 0), (startB.x || 0) - (startA.x || 0));
            const spawnPlayerSrc = data.spawn && data.spawn.player;
            const spawnAiSrc = data.spawn && data.spawn.ai;
            const spawnPlayer = {
              x: Number(spawnPlayerSrc && spawnPlayerSrc.x) || startA.x,
              y: Number(spawnPlayerSrc && spawnPlayerSrc.y) || startA.y,
              angle: typeof (spawnPlayerSrc && spawnPlayerSrc.angle) === "number" ? spawnPlayerSrc.angle : defaultAngle
            };
            const spawnAi = {
              x: Number(spawnAiSrc && spawnAiSrc.x) || (spawnPlayer.x - Math.cos(defaultAngle) * 40),
              y: Number(spawnAiSrc && spawnAiSrc.y) || (spawnPlayer.y - Math.sin(defaultAngle) * 40),
              angle: typeof (spawnAiSrc && spawnAiSrc.angle) === "number" ? spawnAiSrc.angle : defaultAngle
            };
            return {
              name,
              points,
              startLine: { a: startA, b: startB },
              spawn: { player: spawnPlayer, ai: spawnAi },
              roadWidth: data.roadWidth || 80,
              textureId: data.textureId || 'default',
              world,
              mask: data.mask || entry.mask || null,
              speedZones,
              labels,
              decor: data.decor || entry.decor || null,
              source: { id: entry.id, createdAt: entry.createdAt, updatedAt: entry.updatedAt, origin: data.origin || entry.origin || "sketcher" },
              origin: data.origin || "sketcher",
              isCustom: true
            };
          }

          async function ensureCustomTrack(name){
            if (!name || !/^custom:/i.test(name)) return null;
            if (Tracks[name]) return Tracks[name];
            if (customTrackCache.has(name)) {
              const cached = customTrackCache.get(name);
              if (cached && typeof cached.then !== "function") return cached;
            }
            if (customTrackPromises.has(name)) {
              return customTrackPromises.get(name);
            }
            if (!window.TrackStore || typeof TrackStore.getTrack !== "function") {
              throw new Error("Track storage unavailable");
            }
            const id = name.slice(7);
            if (!id) throw new Error("Custom track id missing");
            const promise = TrackStore.getTrack(id).then((entry) => {
              if (!entry) throw new Error("Custom track not found");
              const track = convertCustomEntry(entry);
              Tracks[name] = track;
              customTrackCache.set(name, track);
              customTrackPromises.delete(name);
              return track;
            }).catch((err) => {
              customTrackPromises.delete(name);
              customTrackCache.delete(name);
              throw err;
            });
            customTrackPromises.set(name, promise);
            return promise;
          }

          function drawTrackMask() {
            tctx.save();
            tctx.clearRect(0, 0, W, H);
            tctx.fillStyle = "black";
            tctx.fillRect(0, 0, W, H);
            tctx.lineJoin = "round";
            tctx.lineCap = "round";
            tctx.strokeStyle = "white";
            tctx.lineWidth = ROAD_WIDTH;
            tctx.beginPath();
            for (let i = 0; i < centerline.length; i++) {
              const pt = centerline[i];
              if (i === 0) tctx.moveTo(pt.x, pt.y); else tctx.lineTo(pt.x, pt.y);
            }
            tctx.stroke();
            tctx.restore();

            trackData = tctx.getImageData(0, 0, W, H).data;
          }

          function strokeAiRacingLine(ctx, line, options = {}) {
            if (!ctx || !line || line.length < 2) return;
            const width = Number.isFinite(options.width) ? options.width : Math.max(2, ROAD_WIDTH * 0.15);
            const color = options.color || "rgba(96,165,250,0.85)";
            const dash = options.dash || [36, 24];
            const alpha = Number.isFinite(options.alpha) ? options.alpha : 0.9;
            const close = options.close !== false;
            ctx.save();
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            if (dash && dash.length) ctx.setLineDash(dash);
            ctx.beginPath();
            for (let i = 0; i < line.length; i++) {
              const node = line[i];
              if (!node) continue;
              if (i === 0) ctx.moveTo(node.x, node.y); else ctx.lineTo(node.x, node.y);
            }
            if (close) ctx.closePath();
            ctx.stroke();
            
            // Direction indicators (dots)
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.setLineDash([]);
            for (let i = 0; i < line.length; i += 8) {
              const node = line[i];
              if (!node) continue;
              ctx.beginPath();
              ctx.arc(node.x, node.y, width * 0.4, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.restore();
          }

          // Calculate track curvature at each point for tire mark intensity
          function calculateTrackCurvature(centerline) {
            if (!centerline || centerline.length < 3) return [];
            const n = centerline.length;
            const curvatures = [];
            for (let i = 0; i < n; i++) {
              const prev = centerline[(i - 1 + n) % n];
              const curr = centerline[i];
              const next = centerline[(i + 1) % n];
              // Calculate signed curvature using cross product
              const dx1 = curr.x - prev.x;
              const dy1 = curr.y - prev.y;
              const dx2 = next.x - curr.x;
              const dy2 = next.y - curr.y;
              const cross = dx1 * dy2 - dy1 * dx2;
              const len1 = Math.hypot(dx1, dy1) || 1;
              const len2 = Math.hypot(dx2, dy2) || 1;
              const curvature = Math.abs(cross / (len1 * len2 * Math.max(len1, len2)));
              curvatures.push(curvature);
            }
            return curvatures;
          }

          // Smooth curvature values for more natural tire marks
          function smoothCurvatures(curvatures, windowSize = 8) {
            if (!curvatures.length) return [];
            const n = curvatures.length;
            const smoothed = [];
            const count = 2 * windowSize + 1;
            for (let i = 0; i < n; i++) {
              let sum = 0;
              for (let j = -windowSize; j <= windowSize; j++) {
                const idx = (i + j + n) % n;
                sum += curvatures[idx];
              }
              smoothed.push(sum / count);
            }
            return smoothed;
          }

          // Seeded pseudo-random number generator for consistent texture patterns
          // Uses sine-based hash for deterministic output given a seed value
          const SEED_MULTIPLIER = 9999;
          const SEED_SCALE = 10000;
          function seededRandom(seed) {
            const x = Math.sin(seed * SEED_MULTIPLIER) * SEED_SCALE;
            return x - Math.floor(x);
          }

          // Track texture configurations
          // Each texture defines appearance characteristics for different track surface styles
          const TRACK_TEXTURES = {
            default: {
              id: 'default',
              name: 'Standard',
              baseColor: '#505558',
              centerLineColor: '#cfd8dc',
              tireMarkIntensityBase: 0.05,
              tireMarkIntensityBoost: 0.25,
              tireMarkIntensityMax: 0.35,
              tireMarkSkipThreshold: 0.3,
              tireMarkShadeMin: 40,
              tireMarkShadeRange: 25,
              noiseShadeMin: 55,
              noiseShadeRange: 35,
              noiseAlphaBase: 0.12,
              noiseAlphaRange: 0.15,
              noiseSizeBase: 1,
              noiseSizeRange: 2.5,
              noiseSpecklesMin: 4,
              noiseSpecklesRange: 4
            },
            vintage: {
              id: 'vintage',
              name: 'Vintage Circuit',
              baseColor: '#6e7075',  // Light grey - weathered asphalt
              centerLineColor: '#b8c0c5',  // Faded center line
              tireMarkIntensityBase: 0.12,  // More tire marks
              tireMarkIntensityBoost: 0.35,
              tireMarkIntensityMax: 0.55,  // Higher max for vintage worn appearance
              tireMarkSkipThreshold: 0.15,  // Fewer skips = more marks
              tireMarkShadeMin: 25,  // Darker tire marks (more worn in)
              tireMarkShadeRange: 20,
              noiseShadeMin: 70,  // Lighter noise patches (weathered)
              noiseShadeRange: 50,
              noiseAlphaBase: 0.18,  // More visible texture
              noiseAlphaRange: 0.20,
              noiseSizeBase: 1.5,  // Larger patches
              noiseSizeRange: 3.5,
              noiseSpecklesMin: 6,  // More weathering marks
              noiseSpecklesRange: 6,
              // Additional vintage-specific effects
              hasCracks: true,
              crackDensity: 0.15,
              hasOilStains: true,
              oilStainDensity: 0.08
            },
            modern: {
              id: 'modern',
              name: 'Modern GP',
              baseColor: '#454850',  // Medium grey - fresh tarmac
              centerLineColor: '#ffffff',  // Crisp white center line
              tireMarkIntensityBase: 0.02,  // Fewer tire marks
              tireMarkIntensityBoost: 0.15,
              tireMarkIntensityMax: 0.25,  // Lower max for clean appearance
              tireMarkSkipThreshold: 0.55,  // More skips = fewer marks
              tireMarkShadeMin: 35,
              tireMarkShadeRange: 15,
              noiseShadeMin: 45,  // Subtle noise
              noiseShadeRange: 20,
              noiseAlphaBase: 0.06,  // Less visible
              noiseAlphaRange: 0.08,
              noiseSizeBase: 0.8,
              noiseSizeRange: 1.5,
              noiseSpecklesMin: 2,
              noiseSpecklesRange: 3,
              // Modern track features
              hasRunoffZone: true,
              centerLineWidth: 3
            },
            night: {
              id: 'night',
              name: 'Night Race',
              baseColor: '#2a2d32',  // Dark asphalt
              centerLineColor: '#ffeb3b',  // Glowing yellow center line
              tireMarkIntensityBase: 0.08,
              tireMarkIntensityBoost: 0.30,
              tireMarkIntensityMax: 0.45,
              tireMarkSkipThreshold: 0.25,
              tireMarkShadeMin: 15,  // Very dark marks
              tireMarkShadeRange: 18,
              noiseShadeMin: 35,
              noiseShadeRange: 25,
              noiseAlphaBase: 0.10,
              noiseAlphaRange: 0.12,
              noiseSizeBase: 1.2,
              noiseSizeRange: 2.0,
              noiseSpecklesMin: 3,
              noiseSpecklesRange: 4,
              // Night-specific lighting effects
              hasReflectiveMarkers: true,
              markerColor: '#00e5ff',
              hasGlowEffect: true,
              glowColor: 'rgba(255,200,50,0.15)'
            }
          };

          // Get texture configuration by ID, falling back to default
          function getTextureConfig(textureId) {
            if (textureId && TRACK_TEXTURES[textureId]) {
              return TRACK_TEXTURES[textureId];
            }
            return TRACK_TEXTURES.default;
          }

          // Draw tire mark streaks along the track
          function drawTireMarks(ctx, centerline, curvatures, roadWidth, textureConfig) {
            if (!centerline || centerline.length < 2 || !curvatures.length) return;
            
            const tex = textureConfig || TRACK_TEXTURES.default;
            
            // Normalize curvatures to 0-1 range
            const maxCurv = Math.max(...curvatures, 0.001);
            const normalizedCurvatures = curvatures.map(c => Math.min(1, c / maxCurv));
            
            const n = centerline.length;
            
            // Draw multiple tire mark layers at different offsets from centerline
            const tireOffsets = [-0.35, -0.20, 0.20, 0.35]; // Relative to road width
            const tireWidths = [3, 4, 4, 3]; // Pixel widths
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            for (let tireIdx = 0; tireIdx < tireOffsets.length; tireIdx++) {
              const offset = tireOffsets[tireIdx] * roadWidth;
              const tireWidth = tireWidths[tireIdx];
              
              // Draw tire marks in segments for varied appearance
              let segmentStart = 0;
              while (segmentStart < n) {
                // Segment length varies based on curvature
                const baseCurv = normalizedCurvatures[segmentStart] || 0;
                const segLength = Math.max(3, Math.floor(8 + seededRandom(segmentStart + tireIdx * 1000) * 15));
                const segmentEnd = Math.min(segmentStart + segLength, n);
                
                // Calculate intensity based on curvature (more marks at corners)
                const avgCurvature = normalizedCurvatures.slice(segmentStart, segmentEnd)
                  .reduce((a, b) => a + b, 0) / (segmentEnd - segmentStart);
                
                // Base intensity + curvature boost (use texture-specific values)
                const baseIntensity = tex.tireMarkIntensityBase;
                const curvatureBoost = avgCurvature * tex.tireMarkIntensityBoost;
                const randomVariation = seededRandom(segmentStart * 7 + tireIdx * 13) * 0.08;
                const maxIntensity = tex.tireMarkIntensityMax || 0.45;
                const intensity = Math.min(maxIntensity, baseIntensity + curvatureBoost + randomVariation);
                
                // Skip some segments randomly for varied appearance (use texture-specific threshold)
                if (seededRandom(segmentStart * 3 + tireIdx * 5) > tex.tireMarkSkipThreshold + avgCurvature * 0.5) {
                  segmentStart = segmentEnd;
                  continue;
                }
                
                // Darker shade of grey for tire marks (use texture-specific values)
                const shade = Math.floor(tex.tireMarkShadeMin + seededRandom(segmentStart * 11 + tireIdx) * tex.tireMarkShadeRange);
                ctx.strokeStyle = `rgba(${shade}, ${shade}, ${shade}, ${intensity})`;
                ctx.lineWidth = tireWidth + seededRandom(segmentStart) * 2;
                
                ctx.beginPath();
                for (let i = segmentStart; i < segmentEnd && i < n; i++) {
                  const p = centerline[i];
                  const prevIdx = (i - 1 + n) % n;
                  const nextIdx = (i + 1) % n;
                  const prev = centerline[prevIdx];
                  const next = centerline[nextIdx];
                  
                  // Calculate normal direction
                  const dx = next.x - prev.x;
                  const dy = next.y - prev.y;
                  const len = Math.hypot(dx, dy) || 1;
                  const nx = -dy / len;
                  const ny = dx / len;
                  
                  // Add slight waviness to tire marks
                  const waveOffset = Math.sin(i * 0.3 + tireIdx * 2) * 3;
                  const finalOffset = offset + waveOffset;
                  
                  const tx = p.x + nx * finalOffset;
                  const ty = p.y + ny * finalOffset;
                  
                  if (i === segmentStart) ctx.moveTo(tx, ty);
                  else ctx.lineTo(tx, ty);
                }
                ctx.stroke();
                
                segmentStart = segmentEnd;
              }
            }
          }

          // Draw subtle asphalt texture noise
          function drawAsphaltNoise(ctx, centerline, roadWidth, textureConfig) {
            if (!centerline || centerline.length < 2) return;
            
            const tex = textureConfig || TRACK_TEXTURES.default;
            const n = centerline.length;
            const step = 3; // Sample every few points
            
            // Draw random speckles across the track surface
            for (let i = 0; i < n; i += step) {
              const p = centerline[i];
              const prevIdx = (i - 1 + n) % n;
              const nextIdx = (i + 1) % n;
              const prev = centerline[prevIdx];
              const next = centerline[nextIdx];
              
              // Calculate normal direction
              const dx = next.x - prev.x;
              const dy = next.y - prev.y;
              const len = Math.hypot(dx, dy) || 1;
              const nx = -dy / len;
              const ny = dx / len;
              
              // Add multiple small speckles at each sample point (use texture-specific values)
              const numSpeckles = Math.floor(tex.noiseSpecklesMin + seededRandom(i * 7) * tex.noiseSpecklesRange);
              for (let j = 0; j < numSpeckles; j++) {
                const offsetDist = (seededRandom(i * 13 + j * 17) - 0.5) * roadWidth * 0.85;
                const alongDist = (seededRandom(i * 19 + j * 23) - 0.5) * 15;
                
                const tangentX = dx / len;
                const tangentY = dy / len;
                
                const sx = p.x + nx * offsetDist + tangentX * alongDist;
                const sy = p.y + ny * offsetDist + tangentY * alongDist;
                
                const shade = Math.floor(tex.noiseShadeMin + seededRandom(i * 29 + j * 31) * tex.noiseShadeRange);
                const alpha = tex.noiseAlphaBase + seededRandom(i * 37 + j * 41) * tex.noiseAlphaRange;
                const size = tex.noiseSizeBase + seededRandom(i * 43 + j * 47) * tex.noiseSizeRange;
                
                ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            
            // Vintage texture: add cracks
            if (tex.hasCracks) {
              drawVintageCracks(ctx, centerline, roadWidth, tex.crackDensity || 0.15);
            }
            
            // Vintage texture: add oil stains
            if (tex.hasOilStains) {
              drawOilStains(ctx, centerline, roadWidth, tex.oilStainDensity || 0.08);
            }
            
            // Night texture: add reflective markers
            if (tex.hasReflectiveMarkers) {
              drawReflectiveMarkers(ctx, centerline, roadWidth, tex.markerColor || '#00e5ff');
            }
          }

          // Draw weathered cracks for vintage texture
          function drawVintageCracks(ctx, centerline, roadWidth, density) {
            if (!centerline || centerline.length < 2) return;
            
            const n = centerline.length;
            const step = Math.max(1, Math.floor(30 / density));
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            for (let i = 0; i < n; i += step) {
              if (seededRandom(i * 97) > density * 2) continue;
              
              const p = centerline[i];
              const prevIdx = (i - 1 + n) % n;
              const nextIdx = (i + 1) % n;
              const prev = centerline[prevIdx];
              const next = centerline[nextIdx];
              
              const dx = next.x - prev.x;
              const dy = next.y - prev.y;
              const len = Math.hypot(dx, dy) || 1;
              const nx = -dy / len;
              const ny = dx / len;
              
              // Random offset across road width
              const offsetDist = (seededRandom(i * 53) - 0.5) * roadWidth * 0.7;
              const startX = p.x + nx * offsetDist;
              const startY = p.y + ny * offsetDist;
              
              // Crack length and direction
              const crackLen = 8 + seededRandom(i * 61) * 25;
              const crackAngle = seededRandom(i * 67) * Math.PI * 2;
              const endX = startX + Math.cos(crackAngle) * crackLen;
              const endY = startY + Math.sin(crackAngle) * crackLen;
              
              ctx.strokeStyle = `rgba(25, 25, 25, ${0.15 + seededRandom(i * 71) * 0.2})`;
              ctx.lineWidth = 0.5 + seededRandom(i * 73) * 1.5;
              
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              // Add some jaggedness
              const midX = (startX + endX) / 2 + (seededRandom(i * 79) - 0.5) * 6;
              const midY = (startY + endY) / 2 + (seededRandom(i * 83) - 0.5) * 6;
              ctx.quadraticCurveTo(midX, midY, endX, endY);
              ctx.stroke();
            }
          }

          // Draw oil stains for vintage texture
          function drawOilStains(ctx, centerline, roadWidth, density) {
            if (!centerline || centerline.length < 2) return;
            
            const n = centerline.length;
            const step = Math.max(1, Math.floor(50 / density));
            
            for (let i = 0; i < n; i += step) {
              if (seededRandom(i * 103) > density * 3) continue;
              
              const p = centerline[i];
              const prevIdx = (i - 1 + n) % n;
              const nextIdx = (i + 1) % n;
              const prev = centerline[prevIdx];
              const next = centerline[nextIdx];
              
              const dx = next.x - prev.x;
              const dy = next.y - prev.y;
              const len = Math.hypot(dx, dy) || 1;
              const nx = -dy / len;
              const ny = dx / len;
              
              // Random offset across road width
              const offsetDist = (seededRandom(i * 107) - 0.5) * roadWidth * 0.6;
              const stainX = p.x + nx * offsetDist;
              const stainY = p.y + ny * offsetDist;
              
              const stainSize = 4 + seededRandom(i * 109) * 12;
              
              // Dark, slightly iridescent oil stain
              const gradient = ctx.createRadialGradient(stainX, stainY, 0, stainX, stainY, stainSize);
              gradient.addColorStop(0, `rgba(15, 18, 20, ${0.25 + seededRandom(i * 113) * 0.15})`);
              gradient.addColorStop(0.5, `rgba(25, 30, 35, ${0.15 + seededRandom(i * 117) * 0.1})`);
              gradient.addColorStop(1, 'rgba(30, 35, 40, 0)');
              
              ctx.fillStyle = gradient;
              ctx.beginPath();
              // Irregular shape
              ctx.ellipse(stainX, stainY, stainSize, stainSize * (0.6 + seededRandom(i * 121) * 0.4), seededRandom(i * 127) * Math.PI, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Draw reflective markers for night texture
          function drawReflectiveMarkers(ctx, centerline, roadWidth, markerColor) {
            if (!centerline || centerline.length < 2) return;
            
            // Helper function to convert hex color to rgba
            function hexToRgba(hex, alpha) {
              const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              if (result) {
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
              }
              // Fallback for rgb/rgba format
              if (hex.startsWith('rgb')) {
                return hex.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
              }
              return hex;
            }
            
            const n = centerline.length;
            const markerSpacing = 25; // pixels between markers
            
            for (let i = 0; i < n; i += markerSpacing) {
              const p = centerline[i];
              const prevIdx = (i - 1 + n) % n;
              const nextIdx = (i + 1) % n;
              const prev = centerline[prevIdx];
              const next = centerline[nextIdx];
              
              const dx = next.x - prev.x;
              const dy = next.y - prev.y;
              const len = Math.hypot(dx, dy) || 1;
              const nx = -dy / len;
              const ny = dx / len;
              
              // Draw markers on both edges of the road
              const edgeOffset = roadWidth * 0.45;
              
              // Left edge marker
              const lx = p.x + nx * edgeOffset;
              const ly = p.y + ny * edgeOffset;
              
              // Right edge marker
              const rx = p.x - nx * edgeOffset;
              const ry = p.y - ny * edgeOffset;
              
              // Glowing marker effect
              const glowSize = 3;
              const gradient1 = ctx.createRadialGradient(lx, ly, 0, lx, ly, glowSize * 2);
              gradient1.addColorStop(0, markerColor);
              gradient1.addColorStop(0.5, hexToRgba(markerColor, 0.5));
              gradient1.addColorStop(1, 'rgba(0, 0, 0, 0)');
              
              ctx.fillStyle = gradient1;
              ctx.beginPath();
              ctx.arc(lx, ly, glowSize * 2, 0, Math.PI * 2);
              ctx.fill();
              
              const gradient2 = ctx.createRadialGradient(rx, ry, 0, rx, ry, glowSize * 2);
              gradient2.addColorStop(0, markerColor);
              gradient2.addColorStop(0.5, hexToRgba(markerColor, 0.5));
              gradient2.addColorStop(1, 'rgba(0, 0, 0, 0)');
              
              ctx.fillStyle = gradient2;
              ctx.beginPath();
              ctx.arc(rx, ry, glowSize * 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          function buildTrackSurfaceCanvas() {
            const LIMIT = 4096;
            const TARGET_PPM = 4;
            const pad = Math.max(ROAD_WIDTH * 0.75, 80);
            const baseBounds = trackBounds ? {
              minX: trackBounds.minX,
              minY: trackBounds.minY,
              maxX: trackBounds.maxX,
              maxY: trackBounds.maxY,
            } : { minX: 0, minY: 0, maxX: W, maxY: H };
            const bounds = {
              minX: Math.max(0, baseBounds.minX - pad),
              minY: Math.max(0, baseBounds.minY - pad),
              maxX: Math.min(W, baseBounds.maxX + pad),
              maxY: Math.min(H, baseBounds.maxY + pad),
            };
            const spanW = Math.max(1, bounds.maxX - bounds.minX);
            const spanH = Math.max(1, bounds.maxY - bounds.minY);
            let ppm = TARGET_PPM;
            let texW = Math.ceil(spanW * ppm);
            let texH = Math.ceil(spanH * ppm);
            const over = Math.max(texW / LIMIT, texH / LIMIT, 1);
            if (over > 1) {
              ppm = Math.max(1.5, ppm / over);
              texW = Math.max(1, Math.ceil(spanW * ppm));
              texH = Math.max(1, Math.ceil(spanH * ppm));
            }

            const canvas = document.createElement('canvas');
            canvas.width = texW;
            canvas.height = texH;
            const sctx = canvas.getContext('2d');
            if (!sctx) {
              trackSurfaceRef.current = { canvas: null, mapping: null };
              return;
            }
            sctx.imageSmoothingEnabled = false;
            sctx.setTransform(1, 0, 0, 1, 0, 0);
            sctx.clearRect(0, 0, texW, texH);
            sctx.save();
            sctx.setTransform(ppm, 0, 0, ppm, -bounds.minX * ppm, -bounds.minY * ppm);
            if (activeTrack && typeof activeTrack.drawScenery === 'function') {
              try {
                activeTrack.drawScenery(sctx, { W, H, ROAD_WIDTH, centerline, labels });
              } catch (err) {
                console.warn('Track scenery render failed', err);
              }
            }
            if (centerline && centerline.length > 1) {
              // Get texture configuration from track data
              const textureId = (activeTrack && activeTrack.textureId) || 'default';
              const tex = getTextureConfig(textureId);
              
              let path = null;
              if (typeof Path2D === 'function') {
                path = new Path2D();
                for (let i = 0; i < centerline.length; i++) {
                  const p = centerline[i];
                  if (i === 0) path.moveTo(p.x, p.y);
                  else path.lineTo(p.x, p.y);
                }
              }
              sctx.lineJoin = 'round';
              sctx.lineCap = 'round';
              
              // Night texture: draw glow effect underneath
              if (tex.hasGlowEffect && tex.glowColor) {
                sctx.strokeStyle = tex.glowColor;
                sctx.lineWidth = ROAD_WIDTH * 1.3;
                if (path) sctx.stroke(path);
                else {
                  sctx.beginPath();
                  for (let i = 0; i < centerline.length; i++) {
                    const p = centerline[i];
                    if (i === 0) sctx.moveTo(p.x, p.y);
                    else sctx.lineTo(p.x, p.y);
                  }
                  sctx.stroke();
                }
              }
              
              // Base asphalt color (use texture-specific color)
              sctx.strokeStyle = tex.baseColor;
              sctx.lineWidth = ROAD_WIDTH;
              if (path) sctx.stroke(path);
              else {
                sctx.beginPath();
                for (let i = 0; i < centerline.length; i++) {
                  const p = centerline[i];
                  if (i === 0) sctx.moveTo(p.x, p.y);
                  else sctx.lineTo(p.x, p.y);
                }
                sctx.stroke();
              }
              
              // Calculate curvature for tire mark intensity
              const rawCurvatures = calculateTrackCurvature(centerline);
              const curvatures = smoothCurvatures(rawCurvatures, 12);
              
              // Add asphalt texture noise (with texture config)
              drawAsphaltNoise(sctx, centerline, ROAD_WIDTH, tex);
              
              // Draw tire marks with curvature-based intensity (with texture config)
              drawTireMarks(sctx, centerline, curvatures, ROAD_WIDTH, tex);
              
              // Center line marking (use texture-specific color and width)
              sctx.strokeStyle = tex.centerLineColor;
              sctx.lineWidth = tex.centerLineWidth || 2;
              if (path) sctx.stroke(path);
              else {
                sctx.beginPath();
                for (let i = 0; i < centerline.length; i++) {
                  const p = centerline[i];
                  if (i === 0) sctx.moveTo(p.x, p.y);
                  else sctx.lineTo(p.x, p.y);
                }
                sctx.stroke();
              }
            }
            sctx.restore();

            trackSurfaceRef.current = {
              canvas,
              mapping: {
                worldMinX: bounds.minX,
                worldMinY: bounds.minY,
                worldWidth: spanW,
                worldHeight: spanH,
                worldToTex: ppm,
                texToWorld: 1 / ppm,
              },
            };
          }

          function onRoad(x, y) {
            const ix = (Math.floor(y) * W + Math.floor(x)) * 4;
            return trackData && trackData[ix] > 200;
          }

          function ccw(A, B, C) { return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x); }
          function segIntersect(A, B, C, D) { return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D); }
          function loopIndex(i, len) { return ((i % len) + len) % len; }
          function normalizeAngle(a) { while (a > Math.PI) a -= Math.PI * 2; while (a < -Math.PI) a += Math.PI * 2; return a; }

          function carCorners(car) {
            const { x, y, angle, length, width } = car;
            const hl = length / 2, hw = width / 2;
            const pts = [ { x: hl, y: -hw }, { x: hl, y: hw }, { x: -hl, y: hw }, { x: -hl, y: -hw } ];
            const s = Math.sin(angle), c = Math.cos(angle);
            return pts.map((p) => ({ x: x + p.x * c - p.y * s, y: y + p.x * s + p.y * c }));
          }

          function buildPlanckSegments(points, halfWidth) {
            if (!Array.isArray(points) || points.length < 2 || !Number.isFinite(halfWidth)) return [];
            const n = points.length;
            const left = new Array(n);
            const right = new Array(n);
            for (let i = 0; i < n; i++) {
              const prev = points[(i - 1 + n) % n];
              const curr = points[i];
              const next = points[(i + 1) % n];
              let tx = next.x - prev.x;
              let ty = next.y - prev.y;
              const len = Math.hypot(tx, ty) || 1;
              const nx = -ty / len;
              const ny = tx / len;
              left[i] = { x: curr.x + nx * halfWidth, y: curr.y + ny * halfWidth };
              right[i] = { x: curr.x - nx * halfWidth, y: curr.y - ny * halfWidth };
            }
            const segs = [];
            for (let i = 0; i < n; i++) {
              const a = left[i];
              const b = left[(i + 1) % n];
              segs.push({ x1: a.x, y1: a.y, x2: b.x, y2: b.y });
            }
            for (let i = 0; i < n; i++) {
              const a = right[i];
              const b = right[(i + 1) % n];
              segs.push({ x1: a.x, y1: a.y, x2: b.x, y2: b.y });
            }
            return segs;
          }

          function makeStartGrid({ startLine: srcLine, slots, roadWidth, referenceAngle }) {
            if (!srcLine || !srcLine.a || !srcLine.b || !Array.isArray(slots) || !slots.length) return null;
            const ax = Number(srcLine.a.x);
            const ay = Number(srcLine.a.y);
            const bx = Number(srcLine.b.x);
            const by = Number(srcLine.b.y);
            if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return null;
            const vx = bx - ax;
            const vy = by - ay;
            const lineLen = Math.hypot(vx, vy);
            if (!lineLen || lineLen < 1) return null;
            const origin = { x: (ax + bx) * 0.5, y: (ay + by) * 0.5 };
            const across = { x: vx / lineLen, y: vy / lineLen };
            let forward = { x: -across.y, y: across.x };
            if (typeof referenceAngle === "number" && Number.isFinite(referenceAngle)) {
              const ref = { x: Math.cos(referenceAngle), y: Math.sin(referenceAngle) };
              const dot = ref.x * forward.x + ref.y * forward.y;
              if (dot < 0) {
                forward = { x: -forward.x, y: -forward.y };
              }
            }
            let minForward = Infinity;
            let maxForward = -Infinity;
            let widest = lineLen * 0.5;
            const baseWidth = Number.isFinite(roadWidth) && roadWidth > 0 ? roadWidth : lineLen;
            const lineThickness = clamp(baseWidth * 0.035, 2, 6);
            const gridSlots = [];
            for (const slot of slots) {
              if (!slot) continue;
              const cx = Number(slot.x);
              const cy = Number(slot.y);
              if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;
              const dx = cx - origin.x;
              const dy = cy - origin.y;
              const forwardPos = dx * forward.x + dy * forward.y;
              const lateralPos = dx * across.x + dy * across.y;
              const slotLength = Math.max(24, Number(slot.length) || baseWidth * 0.65);
              const slotWidth = Math.max(12, Number(slot.width) || baseWidth * 0.22);
              const gridSlot = { forward: forwardPos, lateral: lateralPos, length: slotLength, width: slotWidth };
              gridSlots.push(gridSlot);
              const back = gridSlot.forward - gridSlot.length * 0.5;
              const front = gridSlot.forward + gridSlot.length * 0.5;
              minForward = Math.min(minForward, back);
              maxForward = Math.max(maxForward, front);
              widest = Math.max(widest, gridSlot.width * 0.5);
            }
            if (!gridSlots.length || !Number.isFinite(minForward) || !Number.isFinite(maxForward)) return null;
            const frontPad = baseWidth * 0.5;
            const backPad = baseWidth * 0.25;
            const area = {
              start: Math.min(minForward - backPad, -baseWidth),
              end: Math.max(maxForward + frontPad, baseWidth * 0.75),
              halfWidth: Math.max(widest + 6, lineLen * 0.5 + 4)
            };
            return {
              origin,
              forwardAngle: Math.atan2(forward.y, forward.x),
              acrossWidth: lineLen,
              slots: gridSlots,
              area,
              lineThickness,
              checkSize: clamp(lineLen / 14, 4, 16)
            };
          }

          function buildGridSlots({ startLine: srcLine, roadWidth, totalCars, forwardAngle }) {
            if (!srcLine || !srcLine.a || !srcLine.b || totalCars <= 0) return null;
            const ax = Number(srcLine.a.x);
            const ay = Number(srcLine.a.y);
            const bx = Number(srcLine.b.x);
            const by = Number(srcLine.b.y);
            if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return null;
            const vx = bx - ax;
            const vy = by - ay;
            const lineLen = Math.hypot(vx, vy);
            if (!lineLen) return null;
            const across = { x: vx / lineLen, y: vy / lineLen };
            let forward = { x: -across.y, y: across.x };
            if (typeof forwardAngle === "number" && Number.isFinite(forwardAngle)) {
              const ref = { x: Math.cos(forwardAngle), y: Math.sin(forwardAngle) };
              if (ref.x * forward.x + ref.y * forward.y < 0) {
                forward = { x: -forward.x, y: -forward.y };
              }
            }
            const origin = { x: (ax + bx) * 0.5, y: (ay + by) * 0.5 };
            const baseWidth = Number.isFinite(roadWidth) && roadWidth > 0 ? roadWidth : lineLen;
            const slotWidth = clamp(baseWidth * 0.22, 14, Math.min(baseWidth * 0.5, 48));
            const slotLength = clamp(baseWidth * 0.65, 28, 90);
            const rowGap = Math.max(slotLength * 0.9, 26);
            const startGap = Math.max(slotLength * 0.35, 8);
            const laneSpacing = totalCars === 1 ? 0 : Math.max(slotWidth + 8, Math.min(baseWidth * 0.45, slotWidth * 1.8));
            const columns = totalCars === 1 ? 1 : 2;
            const lateralOffsets = columns === 1 ? [0] : [-laneSpacing * 0.5, laneSpacing * 0.5];
            const slots = [];
            for (let i = 0; i < totalCars; i++) {
              const row = Math.floor(i / columns);
              const column = columns === 1 ? 0 : (i % columns);
              const forwardOffset = -(row * rowGap + slotLength * 0.6 + startGap);
              const lateralOffset = lateralOffsets[column] || 0;
              const cx = origin.x + forwardOffset * forward.x + lateralOffset * across.x;
              const cy = origin.y + forwardOffset * forward.y + lateralOffset * across.y;
              slots.push({ x: cx, y: cy, angle: Math.atan2(forward.y, forward.x), width: slotWidth, length: slotLength });
            }
            return slots;
          }

          function planckCars(){
            const list = [];
            if (player) list.push(player);
            if (Array.isArray(aiCars)) list.push(...aiCars);
            return list;
          }

          function syncPlanckWorld(){
            if (!window.RacerPhysics) { planckNeedsSync = true; return; }
            try {
              const ppm = (player && player.physics && player.physics.params && player.physics.params.pixelsPerMeter) || planckPPM || 30;
              planckPPM = ppm;
              const restitution = (player && player.physics && player.physics.params && player.physics.params.restitution) || 0;
              window.RacerPhysics.configureTrackCollision(planckSegments, { ppm, restitution });
              const cars = planckCars();
              if (cars.length) {
                window.RacerPhysics.rebuildPlanckWorld({ cars });
              }
              planckNeedsSync = false;
            } catch (err) {
              console.warn('[Planck] rebuild failed', err);
              planckNeedsSync = true;
            }
          }


          // Get the tangent heading of the centerline nearest to (x,y)
          function headingAtNearest(x, y) {
            if (!centerline || centerline.length < 2) return 0;
            let bestI = 0, bestD2 = Infinity;
            for (let i = 0; i < centerline.length - 1; i++) {
              const a = centerline[i], b = centerline[i + 1];
              // distance from point to segment (approx)
              const abx = b.x - a.x, aby = b.y - a.y;
              const apx = x - a.x, apy = y - a.y;
              const ab2 = abx*abx + aby*aby || 1;
              let t = (apx*abx + apy*aby) / ab2; t = Math.max(0, Math.min(1, t));
              const qx = a.x + abx*t, qy = a.y + aby*t;
              const dx = x - qx, dy = y - qy;
              const d2 = dx*dx + dy*dy;
              if (d2 < bestD2) { bestD2 = d2; bestI = i; }
            }
            const a = centerline[bestI], b = centerline[bestI + 1];
            return Math.atan2(b.y - a.y, b.x - a.x);
          }

          // ===== Track switcher =====
          function loadTrack(name) {
            cancelCountdown();
            setRunning(false);
            GEO_SCALE = clampScale(GEO_SCALE);
            WIDTH_SCALE = clampScale(WIDTH_SCALE);
            let T = Tracks[name];
            if (!T){
              if (name && /^custom:/i.test(name)) {
                setStatus("Loading custom track\u2026");
                ensureCustomTrack(name).then(() => {
                  setStatus("");
                  loadTrack(name);
                }).catch((err) => {
                  console.error("Custom track load failed", err);
                  setStatus("Custom track unavailable");
                });
              } else {
                console.error('Track not found:', name);
                setStatus('Track data missing');
              }
              return;
            }
            const displayName = T.name || name;
            const isCustomTrack = !!(T.isCustom || (T.origin && T.origin === "sketcher") || /^custom:/i.test(name));
            const baseWorldWidth = (T.world && T.world.width) || BASE_WORLD_W;
            const baseWorldHeight = (T.world && T.world.height) || BASE_WORLD_H;
            
            // For custom tracks, geometry is already scaled during bake - don't apply GEO_SCALE again
            // For built-in tracks, apply GEO_SCALE to both world size and geometry
            const effectiveGeoScale = isCustomTrack ? 1 : GEO_SCALE;
            
            applyWorldSize(baseWorldWidth * effectiveGeoScale, baseWorldHeight * effectiveGeoScale);
            activeTrack = { ...T, name: displayName, key: name, world: { width: W, height: H }, baseWorld: { width: baseWorldWidth, height: baseWorldHeight }, isCustom: isCustomTrack, roadWidth: (T.roadWidth || 80) * WIDTH_SCALE };
            activeTrackRef.current = activeTrack;
            startGrid = null;
            decorLayerRef.current = { decorCanvas: null, shadowCanvas: null, metadata: null };
            decorSignatureRef.current = null;

            const baseCx = baseWorldWidth / 2;
            const baseCy = baseWorldHeight / 2;
            const scaledPoints = T.points.map((p) => scalePoint(p, baseCx, baseCy, effectiveGeoScale));
            const bb = bbox(scaledPoints);
            const dx = ((W - bb.w) / 2) - bb.minX;
            const dy = ((H - bb.h) / 2) - bb.minY;
            const transformPoint = (p) => {
              const src = p || { x: baseCx, y: baseCy };
              const scaled = scalePoint(src, baseCx, baseCy, effectiveGeoScale);
              return { x: scaled.x + dx, y: scaled.y + dy };
            };
            const transformPose = (pose, fallbackAngle) => {
              const src = pose || { x: baseCx, y: baseCy, angle: fallbackAngle ?? 0 };
              const pt = transformPoint(src);
              const angle = typeof src.angle === "number" ? src.angle : (fallbackAngle ?? 0);
              return { x: pt.x, y: pt.y, angle };
            };

            const sourcePoints = Array.isArray(T.points) && T.points.length ? T.points : centerline;
            const interpStep = Math.max(4, Math.round(6 * (isCustomTrack ? 1 : GEO_SCALE))); // keep physics segment count stable as tracks scale up
            centerline = interpolate(sourcePoints.map(transformPoint), interpStep);
            const startSrc = (T.startLine && T.startLine.a && T.startLine.b) ? T.startLine : { a: sourcePoints[0], b: sourcePoints[1] || sourcePoints[0] };
            startLine = { a: transformPoint(startSrc.a), b: transformPoint(startSrc.b) };
            ROAD_WIDTH = (T.roadWidth || 80) * WIDTH_SCALE;
            if (typeof T.ppm === "number" && Number.isFinite(T.ppm) && T.ppm > 0) {
              planckPPM = T.ppm;
            }
            planckSegments = buildPlanckSegments(centerline, ROAD_WIDTH * 0.5);
            labels = (T.labels || []).map(([text, x, y]) => {
              const pt = transformPoint({ x, y });
              return [text, pt.x, pt.y];
            });
            const rawPlayer = T.spawn && T.spawn.player ? T.spawn.player : startSrc.a;
            const rawAi = T.spawn && T.spawn.ai ? T.spawn.ai : rawPlayer;
            const playerSpawn = transformPose(rawPlayer, 0);
            const aiSpawn = transformPose(rawAi, playerSpawn.angle);

            drawTrackMask();
            buildTrackSurfaceCanvas();
            const zones = Array.isArray(T.speedZones) && T.speedZones.length ? T.speedZones : [[0, Math.max(1, Math.floor(centerline.length / 24)), 220]];
            waypoints = buildWaypoints(centerline, zones);
            const storedLine = Array.isArray(T.racingLine) ? T.racingLine : null;
            if (storedLine && storedLine.length) {
              baseRacingLine = storedLine.map((node) => ({ ...node }));
              racingLine = baseRacingLine.map((node) => ({ ...node }));
            } else if (window.RacerAI && typeof window.RacerAI.buildRacingLine === "function") {
              racingLine = window.RacerAI.buildRacingLine(centerline, ROAD_WIDTH, { straightSpeed: 440 }) || [];
              baseRacingLine = racingLine.map((node) => ({ ...node }));
            } else {
              racingLine = [];
              baseRacingLine = [];
            }
            if (activeTrack) {
              activeTrack.racingLine = racingLine;
            }
            applyAiLineOverrides();
            trackBounds = bbox(centerline);
            checkpoints = [];
            const K = 12;
            for (let i=0;i<K;i++){
              const idx = Math.floor(i * Math.max(1, centerline.length-2) / K);
              const a = centerline[idx];
              const b = centerline[(idx+1) % centerline.length];
              const ang = Math.atan2(b.y-a.y, b.x-a.x);
              const nx = -Math.sin(ang), ny = Math.cos(ang);
              const half = ROAD_WIDTH*0.5;
              checkpoints.push({ a:{x:a.x+nx*half, y:a.y+ny*half}, b:{x:a.x-nx*half, y:a.y-ny*half} });
            }

            decorSourceRef.current = {
              width: W,
              height: H,
              baseWorldWidth,
              baseWorldHeight,
              worldScale: effectiveGeoScale,
              roadWidth: ROAD_WIDTH,
              centerline: centerline.map((p) => ({ x: p.x, y: p.y })),
              maskCanvas: trackMap,
              trackKey: name,
              track: activeTrack,
              isCustom: isCustomTrack,
              bounds: trackBounds ? { minX: trackBounds.minX, minY: trackBounds.minY, maxX: trackBounds.maxX, maxY: trackBounds.maxY } : null,
            };
            scheduleDecorGeneration(false);

            const fallbackPose = { x: W / 2, y: H / 2, angle: 0 };
            const pSpawn = playerSpawn || fallbackPose;
            Object.assign(player, { ...player, ...pSpawn, speed: 0, lap: 0, bestLap: null, lapStart: performance.now(), lastCross: 0, vx: 0, vy: 0, targetIndex: 0 });
            player.angle = headingAtNearest(player.x, player.y);

            const totalGridSlots = 1 + DEFAULT_AI_CAR_COUNT;
            const gridSlots = (activeTrack && activeTrack.isCustom)
              ? buildGridSlots({ startLine, roadWidth: ROAD_WIDTH, totalCars: totalGridSlots, forwardAngle: player.angle })
              : null;
            if (gridSlots && gridSlots.length) {
              const playerSlot = gridSlots[0];
              if (playerSlot) {
                player.x = playerSlot.x;
                player.y = playerSlot.y;
                player.angle = playerSlot.angle;
              }
            }

            const base = aiSpawn || pSpawn;
            const baseAngle = typeof rawAi.angle === "number" ? rawAi.angle : base.angle;
            if (gridSlots && gridSlots.length > 1) {
              const aiSlotDefs = gridSlots.slice(1, 1 + DEFAULT_AI_CAR_COUNT);
              aiCars = buildAICarsFromSlots(aiSlotDefs);
            } else {
              aiCars = buildLegacyAICars(DEFAULT_AI_CAR_COUNT, base, baseAngle);
            }
            rebuildAIControllers();
            syncAIGearboxes();
            if (activeTrack && activeTrack.isCustom && gridSlots && gridSlots.length) {
              startGrid = makeStartGrid({ startLine, slots: gridSlots, roadWidth: ROAD_WIDTH, referenceAngle: player.angle });
            } else {
              startGrid = null;
            }
            syncPlanckWorld();

            const prettyName = activeTrack && activeTrack.name ? activeTrack.name : name;
            setStatus("");
            if (isCustomTrack) {
              setHudTip(`${prettyName} loaded (custom)`);
            } else {
              setHudTip(`${prettyName} loaded (geo x${GEO_SCALE.toFixed(2)}, width x${WIDTH_SCALE.toFixed(2)})`);
            }

            try {
              const cam = camRef.current; 
              if (cam) { 
                cam.x = player.x;
                cam.y = player.y;
                cam.targetX = player.x;
                cam.targetY = player.y;
                const zoom = computeCameraZoom(Math.abs(player.speed || 0));
                cam.scale = cam.targetScale = zoom.targetZoom;
              }
            } catch(_){}

            startRaceCountdown();
          }

          // Build n AI cars in a staggered grid behind base position, aligned to angle
          function buildLegacyAICars(n, base, angleRad) {
            const arr = [];
            const v = { x: Math.cos(angleRad), y: Math.sin(angleRad) };
            const vp = { x: -v.y, y: v.x }; // left perp
            const gap = 38;       // gap along forward axis
            const lateral = 18;   // side column spacing
            const colors = ["#1e88e5","#43a047","#f4511e","#8e24aa","#00897b","#3949ab","#fdd835","#f97316","#00acc1","#c0ca33"];
            const kinds = Object.keys(CarProfiles);
            for (let i = 0; i < n; i++) {
              const row = Math.floor(i/2) + 1;
              const side = (i%2===0 ? -1 : 1);
              const x = base.x - v.x * gap * row + vp.x * lateral * side;
              const y = base.y - v.y * gap * row + vp.y * lateral * side;
              const kind = kinds[i % kinds.length];
              const car = makeCar({ x, y, angle: angleRad, color: colors[i % colors.length], kind, steeringMode: "manual" });
              car.targetIndex = 0;
              car.speedBias = (-20 + (i%5)*10);
              arr.push(car);
            }
            return arr;
          }

          function buildAICarsFromSlots(slots) {
            const arr = [];
            if (!Array.isArray(slots) || !slots.length) return arr;
            const colors = ["#1e88e5","#43a047","#f4511e","#8e24aa","#00897b","#3949ab","#fdd835","#f97316","#00acc1","#c0ca33"];
            const kinds = Object.keys(CarProfiles);
            slots.forEach((slot, idx) => {
              if (!slot) return;
              const kind = kinds[idx % kinds.length];
              const car = makeCar({ x: slot.x, y: slot.y, angle: slot.angle || 0, color: colors[idx % colors.length], kind, steeringMode: "manual" });
              car.targetIndex = 0;
              car.speedBias = (-20 + (idx % 5) * 10);
              arr.push(car);
            });
            return arr;
          }

          // ===== Rendering =====

          function getColliderHull(car) {
            if (!car) return { width: 0, length: 0 };
            const hull = car.physics && car.physics.colliderHull;
            const width = Number.isFinite(hull?.width)
              ? hull.width
              : (car.colliderWidth ?? car.width ?? 18);
            const length = Number.isFinite(hull?.length)
              ? hull.length
              : (car.colliderLength ?? car.length ?? 36);
            return { width, length };
          }

// ===== Car rendering (detailed) =====
// ===== Car rendering (per-vehicle models) =====
// ===== Car rendering (distinct per-vehicle models) =====
function drawCarDetailed(ctx, car){
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle + Math.PI/2); // align nose with +X physics

  const L = car.length, W = car.width;
  const steerAngle = (car.steerVis || 0) * 0.45;
  const clipperReady = car.kind === 'GT' && canRenderClipperSprite();

  // Helpers
  function roundRectLocal(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }
  function poly(points){ ctx.beginPath(); ctx.moveTo(points[0][0], points[0][1]); for(let i=1;i<points.length;i++) ctx.lineTo(points[i][0], points[i][1]); ctx.closePath(); }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); }
  function gradBody(col){
    const g = ctx.createLinearGradient(0, -L/2, 0, L/2);
    g.addColorStop(0, '#eef1f5');
    g.addColorStop(0.45, col || (car.color || '#c23'));
    g.addColorStop(1, '#1a1f26');
    return g;
  }
  function wheel(x,y,a,ww,ll){
    ctx.save(); ctx.translate(x,y); ctx.rotate(a);
    ctx.fillStyle = '#131820'; roundRectLocal(-ww/2,-ll/2,ww,ll,2); ctx.fill();
    ctx.globalAlpha = .2; ctx.fillStyle = '#2a323d'; roundRectLocal(-ww/2+1.2,-ll/2+1.0,ww-2.4,ll-2.0,2); ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Shadow (skip for sprite-based trucks that include baked shading)
  if (!(car.kind === 'Truck' || clipperReady)) {
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.ellipse(0, 3, W*0.8, L*0.65, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Common lights (head/tail intensity from speed)
  function drawLights(){
    const accelGlow = Math.min(0.55, 0.18 + Math.max(0, car.speed)*0.0008);
    const brakeGlow = Math.min(0.85, 0.28 + Math.max(0, -car.speed)*0.0012);
    // Headlights (front)
    ctx.save(); ctx.globalAlpha = accelGlow; ctx.fillStyle = '#ffe69b';
    roundRectLocal(-W*0.36, -L*0.50, W*0.26, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.10, -L*0.50, W*0.26, L*0.04, 2); ctx.fill();
    ctx.restore();
    // Taillights (rear)
    ctx.save(); ctx.globalAlpha = brakeGlow; ctx.fillStyle = '#ff3b3b';
    roundRectLocal(-W*0.34,  L*0.46, W*0.24, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.10,  L*0.46, W*0.24, L*0.04, 2); ctx.fill();
    ctx.restore();
  }

  function drawColliderOverlay(){
    if (!colliderOverlayEnabled) return;
    const hull = getColliderHull(car);
    const cW = hull.width;
    const cL = hull.length;
    if (!cW || !cL) return;
    const clampSize = (value, min, max) => Math.max(min, Math.min(max, value));
    const w = clampSize(cW, 4, 200);
    const l = clampSize(cL, 8, 260);
    ctx.save();
    ctx.strokeStyle = 'rgba(64,196,255,0.95)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    roundRectLocal(-w/2, -l/2, w, l, 6);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(64,196,255,0.14)';
    roundRectLocal(-w/2, -l/2, w, l, 6);
    ctx.fill();
    ctx.restore();
  }

  // === Distinct models ===
  function drawGT(){
    if (drawClipperSprite()) return;
    // Wide, low silhouette with big rear wing and twin stripes
    ctx.fillStyle = gradBody(car.color || '#f59e0b'); // warm GT tone by default
    roundRectLocal(-W/2, -L/2, W, L, Math.min(W,L)*0.22); ctx.fill();
    // canopy
    ctx.fillStyle = 'rgba(15,20,28,0.92)';
    roundRectLocal(-W*0.36, -L*0.18, W*0.72, L*0.34, 6); ctx.fill();
    // rear wing pylons + plane
    ctx.fillStyle = 'rgba(220,225,232,0.95)';
    roundRectLocal(-W*0.08, L*0.34, W*0.16, L*0.12, 2); ctx.fill();
    roundRectLocal(-W*0.50, L*0.40, W, L*0.06, 3); ctx.fill();
    // twin stripes
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRectLocal(-W*0.13, -L*0.48, W*0.06, L*0.96, 2); ctx.fill();
    roundRectLocal( W*0.07, -L*0.48, W*0.06, L*0.96, 2); ctx.fill();
    // side intakes (triangles)
    ctx.fillStyle = 'rgba(20,24,30,0.70)';
    poly([[-W*0.52, -L*0.08],[-W*0.32,0],[ -W*0.52, L*0.06 ]]); ctx.fill();
    poly([[ W*0.52, -L*0.08],[ W*0.32,0],[  W*0.52, L*0.06 ]]); ctx.fill();

    // wheels (tucked, performance)
    const axY=L*0.30, t=W*0.38, ww=Math.max(3,W*0.24), ll=Math.max(6,L*0.22);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    drawLights();
  }

  function drawRally(){
    // Short hatch with flares, roof scoop, light pod, spare
    ctx.fillStyle = gradBody(car.color || '#2563eb'); // rally blue default
    roundRectLocal(-W/2, -L/2, W, L*0.95, Math.min(W,L)*0.20); ctx.fill();
    // wheel arch flares (outside body)
    ctx.fillStyle = 'rgba(22,28,35,0.95)';
    roundRectLocal(-W*0.60, -L*0.34, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal( W*0.44, -L*0.34, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal(-W*0.60,  L*0.16, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal( W*0.44,  L*0.16, W*0.16, L*0.18, 4); ctx.fill();
    // roof scoop
    ctx.fillStyle = 'rgba(235,238,242,0.85)';
    roundRectLocal(-W*0.18, -L*0.10, W*0.36, L*0.08, 3); ctx.fill();
    // light pod (4 circles)
    ctx.fillStyle = '#eaeef4';
    const ly=-L*0.35, lr=W*0.055;
    circle(-W*0.16, ly, lr); ctx.fill();
    circle(-W*0.05, ly, lr); ctx.fill();
    circle( W*0.06, ly, lr); ctx.fill();
    circle( W*0.17, ly, lr); ctx.fill();
    // spare wheel on roof
    ctx.fillStyle='rgba(40,45,54,0.9)'; circle(0, -L*0.02, W*0.12); ctx.fill();
    ctx.fillStyle='rgba(220,224,230,0.45)'; circle(0, -L*0.02, W*0.07); ctx.fill();
    // rally number circle on door (player only to reduce clutter)
    if (typeof player!=='undefined' && car===player){
      ctx.fillStyle='rgba(255,255,255,0.95)'; circle(-W*0.30, 0, W*0.16); ctx.fill();
      ctx.fillStyle='#111'; ctx.font = `${Math.max(10, W*0.22)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('01', -W*0.30, 0);
    }
    // wheels (chunky)
    const axY=L*0.30, t=W*0.42, ww=Math.max(5,W*0.30), ll=Math.max(8,L*0.24);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    drawLights();
  }

  function drawF1(){
    // Very narrow monocoque, open wheels far outside body, large wings
    const bodyW = Math.max(6, W*0.36);
    // center body
    ctx.fillStyle = gradBody(car.color || '#ef4444'); // F1 red default
    roundRectLocal(-bodyW/2, -L*0.45, bodyW, L*0.90, Math.min(bodyW,L)*0.22); ctx.fill();
    // cockpit/halo
    ctx.fillStyle = 'rgba(22,26,32,0.95)';
    roundRectLocal(-bodyW*0.40, -L*0.10, bodyW*0.80, L*0.16, 3); ctx.fill();
    // sidepods hint (low)
    ctx.fillStyle = 'rgba(200,200,210,0.55)';
    roundRectLocal(-W*0.60, -L*0.08, W*1.20, L*0.14, 6); ctx.fill();
    // front & rear wings extremely wide
    ctx.fillStyle = 'rgba(235,238,242,0.95)';
    roundRectLocal(-W*0.95, -L*0.48, W*1.90, L*0.06, 3); ctx.fill(); // front wing
    roundRectLocal(-W*0.75,  L*0.42,  W*1.50, L*0.06, 3); ctx.fill(); // rear wing
    // nose tip
    ctx.fillStyle = 'rgba(240,240,242,0.95)'; roundRectLocal(-bodyW*0.25, -L*0.50, bodyW*0.50, L*0.06, 3); ctx.fill();

    // Open wheels: far outboard, thin lengthwise
    const axY=L*0.30, t=W*0.85, ww=Math.max(6,W*0.34), ll=Math.max(6,L*0.18);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    // No body over the wheels -> silhouette reads F1 at a glance
  }

  function canRenderClipperSprite(){
    const img = clipperSprite;
    return !!(img && img.complete && img.naturalWidth && img.naturalHeight);
  }

  function drawClipperSprite(){
    const img = clipperSprite;
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;
    const drawLength = L;
    const aspect = img.naturalWidth / img.naturalHeight;
    const drawWidth = drawLength * aspect;
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, -drawWidth/2, -drawLength/2, drawWidth, drawLength);
    ctx.restore();
    return true;
  }

  function drawTruck(){
    if (drawTruckSprite()) return;
    drawTruckFallback();
  }

  function drawTruckSprite(){
    const img = truckSprite;
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;
    const meta = truckSpriteMeta;
    const aspect = meta.sw / meta.sh;
    const drawLength = L;
    const drawWidth = drawLength * aspect;
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, meta.sx, meta.sy, meta.sw, meta.sh, -drawWidth/2, -drawLength/2, drawWidth, drawLength);
    ctx.restore();
    return true;
  }

  function drawTruckFallback(){
    // Boxy cab-over with long chassis, twin rear axles, exhaust stacks, square lights
    // Chassis
    ctx.fillStyle = gradBody(car.color || '#f97316'); // bright truck orange
    roundRectLocal(-W/2, -L*0.10, W, L*0.60, 6); ctx.fill();
    // Cab
    ctx.fillStyle = 'rgba(58,62,70,0.95)';
    roundRectLocal(-W*0.50, -L*0.48, W, L*0.34, 6); ctx.fill();
    // Grill bars
    ctx.globalAlpha = 0.28; ctx.fillStyle = '#e6e9ed';
    roundRectLocal(-W*0.42, -L*0.38, W*0.84, L*0.03, 2); ctx.fill();
    roundRectLocal(-W*0.42, -L*0.32, W*0.84, L*0.03, 2); ctx.fill();
    roundRectLocal(-W*0.42, -L*0.26, W*0.84, L*0.03, 2); ctx.fill();
    ctx.globalAlpha = 1;
    // Mirrors
    ctx.fillStyle = 'rgba(230,232,236,0.95)';
    roundRectLocal(-W*0.62, -L*0.35, W*0.10, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.52, -L*0.35, W*0.10, L*0.04, 2); ctx.fill();
    // Exhaust stacks (behind cab)
    ctx.fillStyle = 'rgba(210,214,220,0.9)';
    roundRectLocal(-W*0.44, -L*0.14, W*0.06, L*0.18, 2); ctx.fill();
    roundRectLocal( W*0.38, -L*0.14, W*0.06, L*0.18, 2); ctx.fill();
    // Square headlights
    ctx.fillStyle = '#ffe69b';
    roundRectLocal(-W*0.38, -L*0.50, W*0.14, L*0.06, 2); ctx.fill();
    roundRectLocal( W*0.24, -L*0.50, W*0.14, L*0.06, 2); ctx.fill();
    // Rear aero flap
    ctx.fillStyle = 'rgba(220,225,232,0.95)';
    roundRectLocal(-W*0.50, L*0.44, W, L*0.05, 3); ctx.fill();

    // Wheels: twin rear axles with dual wheels + single front axle
    const axF=-L*0.28, axR1=L*0.06, axR2=L*0.22, t=W*0.48;
    const wwF=Math.max(6,W*0.30), llF=Math.max(9,L*0.24);
    const wwR=Math.max(6,W*0.34), llR=Math.max(10,L*0.26);
    // Front
    wheel(-t, axF, steerAngle, wwF, llF); wheel(t, axF, steerAngle, wwF, llF);
    // Rear axle 1 (dual each side)
    wheel(-t-3, axR1, 0, wwR, llR); wheel(-t+3, axR1, 0, wwR, llR);
    wheel( t-3, axR1, 0, wwR, llR); wheel( t+3, axR1, 0, wwR, llR);
    // Rear axle 2
    wheel(-t-3, axR2, 0, wwR, llR); wheel(-t+3, axR2, 0, wwR, llR);
    wheel( t-3, axR2, 0, wwR, llR); wheel( t+3, axR2, 0, wwR, llR);
  }

  switch (car.kind){
    case 'F1':    drawF1();    break;
    case 'Truck': drawTruck(); break;
    case 'Rally': drawRally(); break;
    default:      drawGT();    break;
  }

  drawColliderOverlay();

  ctx.restore();
}


function roundRect(ctx, x, y, w, h, r){ r = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); }
          function drawStartGridArea(ctx) {
            if (!startGrid || !startGrid.slots || !startGrid.slots.length) return;
            const { origin, forwardAngle, slots, checkSize, acrossWidth } = startGrid;
            const slotLineThickness = (typeof startGrid.lineThickness === "number" && startGrid.lineThickness > 0)
              ? startGrid.lineThickness
              : 4;
            const trackWidth = (activeTrack && activeTrack.roadWidth) ? activeTrack.roadWidth : acrossWidth;
            const halfWidth = Math.max(12, trackWidth * 0.5);
            const finishDepth = Math.max(4, slotLineThickness * 1.8);
            const checkerSize = Math.max(4, checkSize || 10);

            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.rotate(forwardAngle);

            // Main race line (checkered pattern spanning track width)
            const cells = Math.max(2, Math.ceil((halfWidth * 2) / checkerSize));
            const startY = -halfWidth;
            for (let i = 0; i < cells; i++) {
              const cellY = startY + i * checkerSize;
              const remaining = (halfWidth * 2) - (i * checkerSize);
              const height = Math.min(checkerSize, Math.max(0, remaining));
              if (height <= 0) break;
              ctx.fillStyle = (i % 2 === 0) ? "rgba(245,245,245,0.98)" : "rgba(20,20,20,0.95)";
              ctx.fillRect(-finishDepth * 0.5, cellY, finishDepth, height);
            }

            // Parking slot lines (single lead line per stall)
            ctx.save();
            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = slotLineThickness;
            ctx.lineCap = "butt";
            ctx.beginPath();
            for (const slot of slots) {
              if (!slot) continue;
              const slotHalf = (slot.width || 24) * 0.5;
              const slotLen = (slot.length || 36) * 0.5;
              const front = slot.forward + slotLen;
              ctx.moveTo(front, slot.lateral - slotHalf);
              ctx.lineTo(front, slot.lateral + slotHalf);
            }
            ctx.stroke();
            ctx.restore();
            ctx.restore();
          }
          function drawBackground() {
            // Clear screen-space
            ctx.setTransform(1,0,0,1,0,0);
            const canvasEl = canvasRef.current;
            const cw = canvasEl && canvasEl.width ? canvasEl.width : W;
            const ch = canvasEl && canvasEl.height ? canvasEl.height : H;
            ctx.fillStyle = "#184f1a";
            ctx.fillRect(0, 0, cw, ch);

            // Ensure player has valid position and track data is loaded
            if (!player || typeof player.x !== 'number' || typeof player.y !== 'number' || !trackData) {
              return;
            }

            const cam = camRef.current || {};
            const zoom = typeof cam.scale === "number" && cam.scale > 0 ? cam.scale : 1;
            const camX = Number.isFinite(cam.x) ? cam.x : player.x;
            const camY = Number.isFinite(cam.y) ? cam.y : player.y;
            const regionW = cw / zoom;
            const regionH = ch / zoom;
            const regionX = camX - regionW * 0.5;
            const regionY = camY - regionH * 0.5;

            ctx.save();
            ctx.translate(cw / 2, ch / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-camX, -camY);

            ctx.fillStyle = "#123b1a";
            ctx.fillRect(regionX, regionY, regionW, regionH);

            const trackSurfaceEntry = trackSurfaceRef.current;
            if (trackSurfaceEntry && trackSurfaceEntry.canvas) {
              drawLayerImage(ctx, trackSurfaceEntry.canvas, trackSurfaceEntry.mapping, regionX, regionY, regionW, regionH);
            }

            const decorLayer = decorLayerRef.current;
            const decorMapping = decorLayer && decorLayer.metadata ? decorLayer.metadata.mapping : null;
            if (decorLayer && decorLayer.decorCanvas) {
              drawLayerImage(ctx, decorLayer.decorCanvas, decorMapping, regionX, regionY, regionW, regionH);
            }

            // Start line / grid (ensure visible over decor)
            if (startGrid && activeTrack && activeTrack.isCustom) {
              drawStartGridArea(ctx);
            } else if (startLine && startLine.a && startLine.b) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(startLine.a.x, startLine.a.y);
              ctx.lineTo(startLine.b.x, startLine.b.y);
              ctx.stroke();
            }

            // Checkpoint visuals (subtle)
            ctx.strokeStyle = "rgba(255,255,255,0.15)"; ctx.lineWidth = 2;
            for (const cp of checkpoints){ ctx.beginPath(); ctx.moveTo(cp.a.x, cp.a.y); ctx.lineTo(cp.b.x, cp.b.y); ctx.stroke(); }

            if (decorLayer && decorLayer.shadowCanvas) {
              ctx.save();
              ctx.globalCompositeOperation = "multiply";
              const meta = decorLayer.metadata;
              const shadowAlpha = meta && meta.params && typeof meta.params.shadowStrength === "number"
                ? meta.params.shadowStrength
                : shadowStrengthParam;
              ctx.globalAlpha = shadowAlpha;
              drawLayerImage(ctx, decorLayer.shadowCanvas, decorMapping, regionX, regionY, regionW, regionH);
              ctx.restore();
            }

            // Render racing lines based on visualization mode
            if (showAiLineRef.current) {
              const visMode = lineVisModeRef.current || 'anchor';
              const baseWidth = Math.max(2, ROAD_WIDTH * 0.12);
              
              if (visMode === 'anchor' || visMode === 'both') {
                if (anchorRacingLine && anchorRacingLine.length > 1) {
                  // Highlight violations in red
                  const hasViolations = anchorValidation && (anchorValidation.boundaryViolationsCount > 0);
                  strokeAiRacingLine(ctx, anchorRacingLine, {
                    width: baseWidth,
                    color: hasViolations ? "rgba(239, 68, 68, 0.85)" : "rgba(96, 165, 250, 0.85)",
                    dash: [28, 18],
                    alpha: 0.8
                  });
                } else if (racingLine && racingLine.length > 1 && visMode === 'anchor') {
                  strokeAiRacingLine(ctx, racingLine, {
                    width: baseWidth,
                    dash: [28, 18],
                    alpha: 0.8
                  });
                }
              }
              
              if (visMode === 'mcp' || visMode === 'both') {
                if (mcpRacingLine && mcpRacingLine.length > 1) {
                  const hasViolations = mcpValidation && (mcpValidation.boundaryViolationsCount > 0);
                  strokeAiRacingLine(ctx, mcpRacingLine, {
                    width: baseWidth,
                    color: hasViolations ? "rgba(239, 68, 68, 0.85)" : "rgba(132, 204, 22, 0.85)",
                    dash: visMode === 'both' ? [18, 12] : [28, 18],
                    alpha: 0.8
                  });
                } else if (racingLine && racingLine.length > 1 && visMode === 'mcp') {
                  strokeAiRacingLine(ctx, racingLine, {
                    width: baseWidth,
                    dash: [28, 18],
                    alpha: 0.8
                  });
                }
              }
            }

            // Skids and labels
            drawSkids(ctx);
            ctx.fillStyle = "#e0f2f1"; ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
            for (const [text, x, y] of labels) ctx.fillText(text, x, y);

            // Cars
            const allCars = [player, ...aiCars];
            for (const car of allCars) drawCarDetailed(ctx, car);
            if (window.RacerPhysics) { for (const car of allCars) window.RacerPhysics.drawDebug(ctx, car); }
            ctx.restore();
          }

          function drawCar(car) {
            const corners = carCorners(car);
            const ctx = canvasRef.current.getContext("2d");
            // shadow
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            ctx.beginPath(); corners.forEach((p, i) => (i ? ctx.lineTo(p.x + 2, p.y + 2) : ctx.moveTo(p.x + 2, p.y + 2)));
            ctx.closePath(); ctx.fill();

            // body
            ctx.fillStyle = car.color;
            ctx.beginPath(); corners.forEach((p, i) => (i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)));
            ctx.closePath(); ctx.fill();

            // windshield indicator
            const nose = { x: car.x + Math.cos(car.angle) * (car.length / 2 - 2), y: car.y + Math.sin(car.angle) * (car.length / 2 - 2) };
            ctx.strokeStyle = "#fafafa"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(car.x, car.y); ctx.lineTo(nose.x, nose.y); ctx.stroke();
            ctx.restore();
          }

          function drawHUD() {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext("2d");
            const viewW = canvas.width || W;
            const viewH = canvas.height || H;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const statusText = statusRef.current;
            if (statusText) {
              ctx.font = "bold 36px ui-sans-serif, system-ui"; ctx.fillStyle = "rgba(0,0,0,0.7)";
              ctx.fillRect(viewW / 2 - 260, viewH / 2 - 40, 520, 60); ctx.fillStyle = "#fff";
              ctx.fillText(statusText, viewW / 2 - ctx.measureText(statusText).width / 2, viewH / 2);
            }

            const overlay = countdownOverlayRef.current;
            if (overlay) {
              const now = performance.now();
              const elapsed = overlay.startedAt ? (now - overlay.startedAt) : 0;
              const duration = overlay.duration || 1;
              const progress = Math.min(1, Math.max(0, elapsed / duration));
              const centerX = viewW / 2;
              const centerY = viewH * 0.35;
              const pulse = overlay.final ? 1.05 + progress * 0.15 : 1 + Math.sin(progress * Math.PI) * 0.12;
              const radius = overlay.final ? 150 : 130;
              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.scale(pulse, pulse);
              ctx.globalAlpha = overlay.final ? 0.98 : 0.9 - progress * 0.35;
              ctx.fillStyle = overlay.color;
              ctx.shadowColor = "rgba(0,0,0,0.55)";
              ctx.shadowBlur = 32;
              const fontSize = overlay.final ? 120 : 140;
              ctx.font = `800 ${fontSize}px ui-sans-serif, system-ui, -apple-system`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(overlay.label, 0, 0);
              ctx.shadowBlur = 0;
              ctx.globalAlpha = overlay.final ? 0.9 : 0.7;
              ctx.lineWidth = overlay.final ? 14 : 10;
              ctx.strokeStyle = overlay.final ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.55)";
              ctx.beginPath();
              ctx.arc(0, 0, radius, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
              ctx.stroke();
              ctx.restore();
            }

            if (player) {
              ctx.save();
              const totalLaps = LAPS_TO_FINISH;
              const completed = Math.max(0, player.lap | 0);
              const currentLap = Math.min(completed + 1, totalLaps);
              const finished = completed >= totalLaps;
              const lapText = finished ? `Finished ${totalLaps} laps` : `Lap ${currentLap} / ${totalLaps}`;
              ctx.font = "600 24px system-ui";
              ctx.textBaseline = "middle";
              const padX = 18;
              const textWidth = ctx.measureText(lapText).width;
              const boxWidth = textWidth + padX * 2;
              const boxHeight = 48;
              const boxX = 22;
              const boxY = 20;
              ctx.fillStyle = "rgba(10,16,24,0.78)";
              ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
              ctx.fillStyle = "#f8fafc";
              ctx.fillText(lapText, boxX + padX, boxY + boxHeight / 2);
              ctx.restore();
            }
            // Minimap (top-right)
            if (centerline && centerline.length){
              const mw = 180, mh = 120, pad=10; const x=viewW-mw-pad, y=pad;
              ctx.fillStyle = "rgba(10,16,24,0.75)"; ctx.strokeStyle = "#223453"; ctx.lineWidth=1.5;
              ctx.fillRect(x,y,mw,mh); ctx.strokeRect(x,y,mw,mh);
              const bb = trackBounds || {minX:0,minY:0,w:W,h:H};
              const s = Math.min((mw-12)/bb.w, (mh-12)/bb.h);
              const ox = x + 6 - (bb.minX)*s; const oy = y + 6 - (bb.minY)*s;
              ctx.save(); ctx.beginPath(); ctx.rect(x+2,y+2,mw-4,mh-4); ctx.clip();
              ctx.lineWidth = Math.max(1, ROAD_WIDTH*0.12*s);
              ctx.strokeStyle = "#9aa5b1"; ctx.beginPath(); for (let i=0;i<centerline.length;i++){ const p=centerline[i]; const px=p.x*s+ox, py=p.y*s+oy; if(i===0)ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke();
              if (showAiLineRef.current) {
                const visMode = lineVisModeRef.current || 'anchor';
                
                if (visMode === 'anchor' || visMode === 'both') {
                  const line = anchorRacingLine && anchorRacingLine.length > 1 ? anchorRacingLine : racingLine;
                  if (line && line.length > 1) {
                    ctx.strokeStyle = "rgba(96,165,250,0.9)";
                    ctx.lineWidth = Math.max(1, ROAD_WIDTH*0.08*s);
                    ctx.setLineDash([8, 6]);
                    ctx.beginPath();
                    for (let i=0;i<line.length;i++){
                      const node = line[i];
                      const lx = node.x*s+ox;
                      const ly = node.y*s+oy;
                      if(i===0)ctx.moveTo(lx,ly); else ctx.lineTo(lx,ly);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);
                  }
                }
                
                if (visMode === 'mcp' || visMode === 'both') {
                  if (mcpRacingLine && mcpRacingLine.length > 1) {
                    ctx.strokeStyle = "rgba(132, 204, 22, 0.9)";
                    ctx.lineWidth = Math.max(1, ROAD_WIDTH*0.08*s);
                    ctx.setLineDash(visMode === 'both' ? [6, 4] : [8, 6]);
                    ctx.beginPath();
                    for (let i=0;i<mcpRacingLine.length;i++){
                      const node = mcpRacingLine[i];
                      const lx = node.x*s+ox;
                      const ly = node.y*s+oy;
                      if(i===0)ctx.moveTo(lx,ly); else ctx.lineTo(lx,ly);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);
                  }
                }
              }
              // cars
              function dot(col, px,py){ ctx.fillStyle=col; ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.fill(); }
              const ppx = player.x*s+ox, ppy = player.y*s+oy; dot('#e53935', ppx, ppy);
              for (const a of aiCars){ dot('#7dd3fc', a.x*s+ox, a.y*s+oy); }
              ctx.restore();
              // Label
              ctx.fillStyle = "#cbd5e1"; ctx.font = "11px system-ui"; ctx.fillText(activeTrack && activeTrack.name ? activeTrack.name : trackName, x+8, y+14);
            }
            if (player && player.gearbox) {
              const gearLabel = player.gearbox.gear;
              const hudText = `${gearLabel}  ${(player.gearbox.rpm|0)} rpm`;
              const scale = 3;
              const fontSize = 14 * scale;
              const padX = 8 * scale;
              const boxHeight = 28 * scale;
              ctx.font = `${fontSize}px system-ui`;
              const textWidth = ctx.measureText(hudText).width;
              const boxWidth = textWidth + padX * 2;
              const hudX = 16;
              const hudY = viewH - (16 + boxHeight);
              ctx.fillStyle = "rgba(10,16,24,0.7)";
              ctx.fillRect(hudX, hudY, boxWidth, boxHeight);
              ctx.fillStyle = "#f8fafc";
              const baselineOffset = boxHeight - (9 * scale);
              ctx.fillText(hudText, hudX + padX, hudY + baselineOffset);
            }
            ctx.restore();
          }

          // ===== Simulation =====
          let last = performance.now();

          function updateCar(car, dt, control) {
            const steerInput = (control && typeof control.steer === "number")
              ? clamp(control.steer, -1, 1)
              : ((control && control.right ? 1 : 0) - (control && control.left ? 1 : 0));
            const throttleInput = (control && typeof control.throttle === "number")
              ? clamp(control.throttle, 0, 1)
              : (control && control.throttle ? 1 : 0);
            const brakeInput = (control && typeof control.brake === "number")
              ? clamp(control.brake, 0, 1)
              : (control && control.brake ? 1 : 0);
            // Determine surface (sample corners + center)
            const corners = carCorners(car);
            const samples = [corners[0], corners[1], corners[2], corners[3], { x: car.x, y: car.y }];
            let roadCount = 0; for (const s of samples) if (onRoad(s.x, s.y)) roadCount++;
            const onroad = roadCount >= 3;

            // Lap count requires previous position
            const prevX = car.x, prevY = car.y;

            const res = (window.RacerPhysics||{}).updateCar ? window.RacerPhysics.updateCar(
              car,
              { throttle: throttleInput, brake: brakeInput, steer: steerInput },
              { onRoad: onroad },
              dt
            ) : null;

            // Skid marks based on slip
            const skidAmount = res && typeof res.skid === 'number' && res.skidEligible ? res.skid : 0;
            if (skidAmount > 0.28){
              const wp = window.RacerPhysics ? window.RacerPhysics.wheelPositions(car) : null;
              if (wp){
                if (car.skidLPrev && car.skidRPrev){
                  addSkid(car.skidLPrev.x, car.skidLPrev.y, wp.left.x, wp.left.y);
                  addSkid(car.skidRPrev.x, car.skidRPrev.y, wp.right.x, wp.right.y);
                }
                car.skidLPrev = wp.left; car.skidRPrev = wp.right;
              }
            } else { car.skidLPrev = null; car.skidRPrev = null; }

            // Lap counting against start line
            const now = performance.now();
            const hasStartLine = startLine && startLine.a && startLine.b;
            if (hasStartLine && (now - car.lastCross > 800)) {
              if (segIntersect({x: prevX, y: prevY}, { x: car.x, y: car.y }, startLine.a, startLine.b)) {
                car.lap += 1; car.lastCross = now;
                const lapTime = (now - car.lapStart) / 1000;
                car.bestLap = car.bestLap ? Math.min(car.bestLap, lapTime) : lapTime; car.lapStart = now;
              }
            }
          }
          loadTrackRef.current = loadTrack;

          function updateAI(dt) {
            const controllersReady = racingLine.length && window.RacerAI;
            const throttleScale = mapMaxThrottleToSpeedScale(getCurrentMaxThrottle());
            for (const car of aiCars) {
              const controller = controllersReady ? car.aiController : null;
              let control;
              let fallbackDelta = null;
              if (controller) {
                control = controller.update(car, dt);
              } else {
                const target = waypoints[car.targetIndex];
                if (!target) continue;
                const dx = target.x - car.x;
                const dy = target.y - car.y;
                const targetAngle = Math.atan2(dy, dx);
                const steer = clamp(normalizeAngle(targetAngle - car.angle), -1, 1);
                const currentSpeed = Math.hypot((car.physics && car.physics.vx) || car.vx || 0, (car.physics && car.physics.vy) || car.vy || 0);
                const desiredSpeedBase = target.speed || 0;
                const desiredSpeed = Math.min(
                  MAX_AI_TARGET_SPEED,
                  (desiredSpeedBase * throttleScale) + (car.speedBias || 0)
                );
                control = {
                  throttle: currentSpeed < desiredSpeed ? 1 : 0,
                  brake: currentSpeed > desiredSpeed + 25 ? 1 : 0,
                  steer
                };
                fallbackDelta = { dx, dy };
              }
              // Apply collision avoidance - AI cars should avoid crashing into each other
              control = applyAiCollisionAvoidance(car, control, dt, aiCars, player);
              control = applyAiRecoveryControl(car, control, dt, racingLine, performance.now() / 1000);
              updateCar(car, dt, control);
              if (!controller && fallbackDelta) {
                const dist = Math.hypot(fallbackDelta.dx, fallbackDelta.dy);
                if (dist < 40) {
                  car.targetIndex = loopIndex(car.targetIndex + 1, waypoints.length);
                }
              }
            }
          }

          function updatePlayer(dt) {
            // Blend keyboard with motion steering
            const control = { throttle: keys.w, brake: keys.s, left: keys.a, right: keys.d };
            const pads = navigator.getGamepads ? navigator.getGamepads() : null;
            const pad = pads ? pads[0] : null;
            if (pad && pad.buttons) {
              const lb = !!(pad.buttons[4] && pad.buttons[4].pressed);
              const rb = !!(pad.buttons[5] && pad.buttons[5].pressed);
              if (lb && !gamepadShiftPrev.down && player && player.gearbox) player.gearbox.shiftDown();
              if (rb && !gamepadShiftPrev.up && player && player.gearbox) player.gearbox.shiftUp();
              gamepadShiftPrev.down = lb;
              gamepadShiftPrev.up = rb;
            } else {
              gamepadShiftPrev.down = gamepadShiftPrev.up = false;
            }
            updateCar(player, dt, control);
          }

          // ===== Collisions (pairwise among all cars) =====
          function handleCollisions() {
            const all = [player, ...aiCars];
            for (let i = 0; i < all.length; i++) {
              for (let j = i+1; j < all.length; j++) {
                const a = all[i], b = all[j];
                const hullA = getColliderHull(a);
                const hullB = getColliderHull(b);
                const ra = Math.hypot((hullA.length || 36)/2, (hullA.width || 18)/2);
                const rb = Math.hypot((hullB.length || 36)/2, (hullB.width || 18)/2);
                const dx = b.x - a.x, dy = b.y - a.y;
                const dist = Math.hypot(dx, dy) || 1e-6;
                const minDist = ra + rb;
                if (dist < minDist) {
                  const nx = dx / dist, ny = dy / dist;
                  const overlap = (minDist - dist);
                  // Position correction split by mass
                  const ma = (a.physics && a.physics.params && a.physics.params.mass) || 1.0;
                  const mb = (b.physics && b.physics.params && b.physics.params.mass) || 1.0;
                  const invSum = 1 / (ma + mb);
                  a.x -= nx * overlap * (mb * invSum);
                  a.y -= ny * overlap * (mb * invSum);
                  b.x += nx * overlap * (ma * invSum);
                  b.y += ny * overlap * (ma * invSum);

                  // Velocities in world frame
                  const vax = (a.physics ? a.physics.vx : (Math.cos(a.angle)*a.speed + a.vx));
                  const vay = (a.physics ? a.physics.vy : (Math.sin(a.angle)*a.speed + a.vy));
                  const vbx = (b.physics ? b.physics.vx : (Math.cos(b.angle)*b.speed + b.vx));
                  const vby = (b.physics ? b.physics.vy : (Math.sin(b.angle)*b.speed + b.vy));
                  const rvx = vbx - vax, rvy = vby - vay;
                  const relNorm = rvx * nx + rvy * ny;
                  if (relNorm < 0) {
                    const e = 0.45; // restitution
                    const j = -(1 + e) * relNorm / (1/ma + 1/mb);
                    const jx = j * nx, jy = j * ny;
                    // Apply impulses
                    if (a.physics){ a.physics.vx -= jx / ma; a.physics.vy -= jy / ma; a.vx = a.physics.vx; a.vy = a.physics.vy; }
                    else { a.vx -= jx / ma; a.vy -= jy / ma; }
                    if (b.physics){ b.physics.vx += jx / mb; b.physics.vy += jy / mb; b.vx = b.physics.vx; b.vy = b.physics.vy; }
                    else { b.vx += jx / mb; b.vy += jy / mb; }
                    const impact = Math.min(1, Math.abs(j) * 0.003);
                    if (a===player || b===player) { player.sfxImpact = Math.max(player.sfxImpact||0, impact); }
                  }
                }
              }
            }
          }

          // ===== Input =====
          function key(e, down) {
            if (down) primeAudio();
            const k = e.key.toLowerCase();
            if (down && !e.repeat) {
              if (k === 'q' && player && player.gearbox) { player.gearbox.shiftDown(); e.preventDefault(); }
              if (k === 'e' && player && player.gearbox) { player.gearbox.shiftUp(); e.preventDefault(); }
              if (k === 'm') {
                if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                  toggleSFX();
                } else if (player && player.gearbox) {
                  player.gearbox.setManual(player.gearbox.c.auto);
                }
                e.preventDefault();
              }
            }
            if (k === "w") keys.w = down;
            if (k === "s") keys.s = down;
            if (k === "a") keys.a = down;
            if (k === "d") keys.d = down;
            if (down && (k === "r" || k === "enter")) loadTrack(trackName); // restart current track
            if (down && k === " ") {
              if (countdownActiveRef.current) return;
              setRunning((r) => !r);
            }
            if (down && k === "t") {
              const next = trackName === "Silverstone" ? "Le Mans" : "Silverstone";
              setTrackName(next); setTimeout(() => loadTrack(next), 0);
            }
            // Unlock/resume audio on any key press
            if (down) { try { const a = ensureAudio(); if (a && a.ctx.state==='suspended') a.ctx.resume(); } catch(_){ } }
            if (down && k === 'v') toggleSFX();
            if (down && k === "1") { setTrackName("Silverstone"); setTimeout(() => loadTrack("Silverstone"), 0); }
            if (down && k === "2") { setTrackName("Le Mans"); setTimeout(() => loadTrack("Le Mans"), 0); }
            if (down && (k === "+" || k === "=")) {
              GEO_SCALE = clampScale(GEO_SCALE + SCALE_STEP);
              writeScale('geoScale', GEO_SCALE);
              setGeoScaleInput(GEO_SCALE);
              loadTrack(trackName);
            }
            if (down && (k === "-" || k === "_")) {
              GEO_SCALE = clampScale(GEO_SCALE - SCALE_STEP);
              writeScale('geoScale', GEO_SCALE);
              setGeoScaleInput(GEO_SCALE);
              loadTrack(trackName);
            }
            // Gyro toggle and calibration
            // (Gyro removed)
          }
          const kd = (e) => key(e, true), ku = (e) => key(e, false);
          window.addEventListener("keydown", kd);
          window.addEventListener("keyup", ku);

          // Touch HUD bindings
          function bindTouchButton(el, onDown, onUp){ if(!el) return; const d=(e)=>{ e.preventDefault(); primeAudio(); onDown(); try{ const a=ensureAudio(); if(a&&a.ctx.state==='suspended') a.ctx.resume(); }catch{} }; const u=(e)=>{ e.preventDefault(); onUp(); }; el.addEventListener('touchstart', d, {passive:false}); el.addEventListener('touchend', u, {passive:false}); el.addEventListener('touchcancel', u, {passive:false}); el.addEventListener('mousedown', d); el.addEventListener('mouseup', u); el.addEventListener('mouseleave', u); }
          const hud = document.querySelector('.hud');
          if (hud){
            bindTouchButton(hud.querySelector('.btn.left'),  ()=>keys.a=true, ()=>keys.a=false);
            bindTouchButton(hud.querySelector('.btn.right'), ()=>keys.d=true, ()=>keys.d=false);
            bindTouchButton(hud.querySelector('.btn.thr'),   ()=>keys.w=true, ()=>keys.w=false);
            bindTouchButton(hud.querySelector('.btn.brk'),   ()=>keys.s=true, ()=>keys.s=false);
            // Gyro button removed
          }

          // Motion steering after first user gesture
          // Gyro handlers removed
          // Optional: keep the screen awake during play (Android Chrome)
          let wakeLock = null;
          async function enableWakeLock(){
            try { if ('wakeLock' in navigator) { wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>{}); } } catch(_){}
          }
          window.addEventListener('pointerdown', ()=>{ primeAudio(); try{ const a=ensureAudio(); if(a&&a.ctx.state==='suspended') a.ctx.resume(); }catch{} enableWakeLock(); }, { once:true });
          document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible' && wakeLock && wakeLock.released){ enableWakeLock(); } });
          // Pause when tab/app is hidden
          document.addEventListener('visibilitychange', ()=>{ if (document.hidden) setRunning(false); });

          function frame(t) {
            const dt = Math.min(0.05, (t - last) / 1000); last = t;
            const physicsAPI = window.RacerPhysics;
            const carsForPlanck = planckCars();
            const isRunning = runningRef.current;
            if (planckNeedsSync && physicsAPI && typeof physicsAPI.configureTrackCollision === 'function') {
              syncPlanckWorld();
            }
            if (physicsAPI && typeof physicsAPI.planckBeginStep === 'function') {
              try { physicsAPI.planckBeginStep(isRunning ? dt : 0, carsForPlanck); } catch(err){ console.warn('[Planck] begin step failed', err); }
            }
            if (isRunning) {
              updatePlayer(dt); updateAI(dt);
            }
            if (physicsAPI && typeof physicsAPI.planckStep === 'function') {
              try { physicsAPI.planckStep(); } catch(err){ console.warn('[Planck] step failed', err); }
            }
            tryInitSpeedometer();
            // --- Speedometer update ---
            if (speedoCtrl) {
              const ppm = (window.PlanckWorld && window.PlanckWorld.PPM_DEFAULT) || 30;
              // speed (px/s -> m/s -> mph)
              const mph = ((player?.speed || 0) / ppm) * 2.23694;
              // gearbox
              const gb = player?.gearbox;
              const gear = gb?.gear || 1;
              const rpm  = gb?.rpm  || 0;
              const rpmSmooth = gb?.state?.smoothedRpm ?? rpm;
              const red  = (gb?.state && gb.state.redlineRpm) || (gb?.c && gb.c.redlineRPM) || 7600;
              const idle = (gb?.state && gb.state.idleRpm)    || (gb?.c && gb.c.idleRPM)    || 1100;
              speedoCtrl.update({ gear, rpm: rpmSmooth, smoothedRpm: rpmSmooth, redline: red, idle, mph });
            }
            if (isRunning) {
              const planckActive = physicsAPI && typeof physicsAPI.usesPlanckWorld === 'function' && physicsAPI.usesPlanckWorld();
              if (!planckActive) {
                handleCollisions();
              }
              if (!statusRef.current && (player.lap >= LAPS_TO_FINISH)) {
                const finishMsg = `${LAPS_TO_FINISH} laps done! Press R to restart`;
                statusRef.current = finishMsg;
                setStatus(finishMsg);
                runningRef.current = false;
                setRunning(false);
              }
            }
            const cam = camRef.current;
            if (cam && player && typeof player.x === 'number' && typeof player.y === 'number') {
              cam.targetX = player.x;
              cam.targetY = player.y;
            }
            const spd = Math.abs(player.speed || 0);
            if (cam) {
              const { minZoom, maxZoom, targetZoom } = computeCameraZoom(spd);
              cam.targetScale = Math.max(minZoom, Math.min(maxZoom, targetZoom));
              const zoomEase = clampZoomResponse(zoomResponseRate);
              cam.scale += (cam.targetScale - cam.scale) * Math.min(1, dt * zoomEase);
              if (typeof cam.targetX === "number" && typeof cam.targetY === "number") {
                cam.x = cam.targetX;
                cam.y = cam.targetY;
              }
            }

            updateSFX(player, dt); updateSkids(dt);
            drawBackground();
            drawHUD();
            requestAnimationFrame(frame);
          }
          // initial track first, then start animation to ensure camera is centered
          loadTrack(trackName);
          camInitRef.current = true; // ensure camera is initialized
          requestAnimationFrame(frame);
          try {
            if (window.RacerPhysics) {
              const getCars = () => ({ player, ai: aiCars });
              window.RacerPhysics.injectDevTools(getCars);
              if (typeof window.RacerPhysics.injectVehicleTweaker === 'function') {
                const bridge = {
                  listKinds: () => Object.keys(CarProfiles),
                  getArtDimensions: (kind) => {
                    const prof = CarProfiles[kind];
                    return prof ? { width: prof.width, length: prof.length } : null;
                  },
                  setArtDimensions: (kind, dims) => {
                    if (!kind || !CarProfiles[kind] || !dims) return;
                    const width = clamp(+dims.width || CarProfiles[kind].width, 10, 80);
                    const length = clamp(+dims.length || CarProfiles[kind].length, 30, 140);
                    CarProfiles[kind].width = width;
                    CarProfiles[kind].length = length;
                    const applyDims = (car) => {
                      if (!car || car.kind !== kind) return;
                      car.width = width;
                      car.length = length;
                      if (car.physics && car.physics.params) {
                        const mass = car.physics.params.mass || 1;
                        car.physics.Izz = mass * (length * length + width * width) / 12;
                      }
                    };
                    applyDims(player);
                    if (Array.isArray(aiCars)) aiCars.forEach(applyDims);
                  },
                  getColliderDimensions: (kind) => {
                    const prof = CarProfiles[kind];
                    if (!prof) return null;
                    return {
                      width: prof.colliderWidth ?? prof.width,
                      length: prof.colliderLength ?? prof.length
                    };
                  },
                  setColliderDimensions: (kind, dims) => {
                    if (!kind || !CarProfiles[kind] || !dims) return;
                    const profile = CarProfiles[kind];
                    const width = Math.max(10, Math.min(80, Number(dims.width) || profile.colliderWidth || profile.width));
                    const length = Math.max(30, Math.min(140, Number(dims.length) || profile.colliderLength || profile.length));
                    profile.colliderWidth = width;
                    profile.colliderLength = length;
                    const applyCollider = (car) => {
                      if (!car || car.kind !== kind) return;
                      car.colliderWidth = width;
                      car.colliderLength = length;
                      if (car.physics && car.physics.params) {
                        const mass = car.physics.params.mass || 1;
                        car.physics.Izz = mass * (length * length + width * width) / 12;
                      }
                    };
                    applyCollider(player);
                    if (Array.isArray(aiCars)) aiCars.forEach(applyCollider);
                    if (window.RacerPhysics && typeof window.RacerPhysics.forcePlanckRefresh === 'function') {
                      window.RacerPhysics.forcePlanckRefresh(kind);
                    }
                  },
                  getColliderVisibility: () => colliderOverlayEnabled,
                  setColliderVisibility: (enabled) => {
                    setColliderOverlayEnabled(!!enabled);
                  }
                };
                window.RacerPhysics.injectVehicleTweaker(bridge, getCars);
              }
            }
          } catch (_){ }

          return () => {
            window.removeEventListener("keydown", kd);
            window.removeEventListener("keyup", ku);
            if (speedoCtrl && typeof speedoCtrl.destroy === 'function') speedoCtrl.destroy();
            loadTrackRef.current = () => {};
          };
        }, [trackName]);

        // Helper to toggle panel from dev menu
        const toggleDevPanel = (panelId) => {
          if (activeDevPanel === panelId) {
            setActiveDevPanel(null);
          } else {
            setActiveDevPanel(panelId);
          }
          setDevMenuOpen(false);
        };

        return (
          <div className="wrap">
            {hudTip ? <div className="hud-tip">{hudTip}</div> : null}
            {/* Dev Menu Dropdown */}
            <div className="dev-menu-container">
              <button
                type="button"
                className={`dev-menu-toggle ${devMenuOpen ? 'open' : ''}`}
                onClick={() => setDevMenuOpen(open => !open)}
              >
                Dev
              </button>
              <div className={`dev-menu-dropdown ${devMenuOpen ? 'open' : ''}`}>
                <button
                  type="button"
                  className={`dev-menu-item ${activeDevPanel === 'scales' ? 'active' : ''}`}
                  onClick={() => toggleDevPanel('scales')}
                >
                  Scales
                </button>
                <button
                  type="button"
                  className={`dev-menu-item ${activeDevPanel === 'ai' ? 'active' : ''}`}
                  onClick={() => toggleDevPanel('ai')}
                >
                  AI Controls
                </button>
                <button
                  type="button"
                  className="dev-menu-item"
                  onClick={() => {
                    // Toggle Dev tools panel (injected by physics.js)
                    const devtools = document.getElementById('rv-devtools');
                    if (devtools) {
                      const panel = devtools.querySelector('.rv-panel');
                      if (panel) panel.classList.toggle('open');
                    }
                    setDevMenuOpen(false);
                  }}
                >
                  Dev Tools
                </button>
                <button
                  type="button"
                  className="dev-menu-item"
                  onClick={() => {
                    // Toggle GBX panel
                    const gbxPanel = document.getElementById('gbxPanel');
                    if (gbxPanel) {
                      gbxPanel.style.display = gbxPanel.style.display === 'block' ? 'none' : 'block';
                    }
                    setDevMenuOpen(false);
                  }}
                >
                  GBX
                </button>
                <button
                  type="button"
                  className="dev-menu-item"
                  onClick={() => {
                    // Toggle Vehicle Tweaker panel
                    const tweaker = document.getElementById('rv-vehicle-tweaker');
                    if (tweaker) {
                      const panel = tweaker.querySelector('.rv-panel');
                      if (panel) panel.classList.toggle('open');
                    }
                    setDevMenuOpen(false);
                  }}
                >
                  Vehicle Tweaker
                </button>
              </div>
            </div>
            {/* Hidden legacy buttons for compatibility - hidden via CSS class .dev-toggle */}
            <button
              type="button"
              className="dev-toggle"
              onClick={() => setDevPanelOpen(open => !open)}
              aria-pressed={devPanelOpen}
            >
              {devPanelOpen ? "Hide scales" : "Scales"}
            </button>
            <button
              type="button"
              className="dev-toggle ai-toggle"
              onClick={() => setAiPanelOpen(open => !open)}
              aria-pressed={aiPanelOpen}
            >
              {aiPanelOpen ? "Hide AI Controls" : "AI Controls"}
            </button>
            <div className={`dev-panel ${activeDevPanel === 'scales' ? "open" : ""}`}>
              <h3>Track scale</h3>
              <label>
                <span>Geo scale</span>
                <div className="field">
                  <input
                    type="range"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={geoScaleInput}
                    onChange={(e) => applyGeoScaleChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={geoScaleInput.toFixed(2)}
                    onChange={(e) => applyGeoScaleChange(e.target.value)}
                  />
                </div>
              </label>
              <label>
                <span>Width scale</span>
                <div className="field">
                  <input
                    type="range"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={widthScaleInput}
                    onChange={(e) => applyWidthScaleChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={widthScaleInput.toFixed(2)}
                    onChange={(e) => applyWidthScaleChange(e.target.value)}
                  />
                </div>
              </label>
              <label>
                <span>Camera distance</span>
                <div className="field">
                  <input
                    type="range"
                    min={CAMERA_MIN}
                    max={CAMERA_MAX}
                    step={CAMERA_STEP}
                    value={cameraDistance}
                    onChange={(e) => applyCameraDistanceChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={CAMERA_MIN}
                    max={CAMERA_MAX}
                    step={CAMERA_STEP}
                    value={cameraDistance.toFixed(2)}
                    onChange={(e) => applyCameraDistanceChange(e.target.value)}
                  />
                </div>
              </label>
              <h4>Camera zoom</h4>
              <label title="Maximum extra zoom-out applied at top speed (percentage of base zoom span).">
                <span>Zoom-out amount (%)</span>
                <div className="field">
                  <input
                    type="range"
                    min={ZOOM_DELTA_MIN}
                    max={ZOOM_DELTA_MAX}
                    step={ZOOM_DELTA_STEP}
                    value={zoomMaxDelta}
                    onChange={(e) => handleZoomMaxDeltaChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={ZOOM_DELTA_MIN}
                    max={ZOOM_DELTA_MAX}
                    step={ZOOM_DELTA_STEP}
                    value={zoomMaxDelta.toFixed(0)}
                    onChange={(e) => handleZoomMaxDeltaChange(e.target.value)}
                  />
                </div>
              </label>
              <label title="Vehicle speed (mph) where zoom-out begins to activate.">
                <span>Zoom start speed (mph)</span>
                <div className="field">
                  <input
                    type="range"
                    min={ZOOM_SPEED_MIN}
                    max={ZOOM_SPEED_MAX}
                    step={ZOOM_SPEED_STEP}
                    value={zoomStartSpeed}
                    onChange={(e) => handleZoomStartSpeedChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={ZOOM_SPEED_MIN}
                    max={ZOOM_SPEED_MAX}
                    step={ZOOM_SPEED_STEP}
                    value={zoomStartSpeed.toFixed(0)}
                    onChange={(e) => handleZoomStartSpeedChange(e.target.value)}
                  />
                </div>
              </label>
              <label title="Vehicle speed (mph) where the camera reaches the maximum zoom-out amount.">
                <span>Full zoom speed (mph)</span>
                <div className="field">
                  <input
                    type="range"
                    min={ZOOM_SPEED_MIN}
                    max={ZOOM_SPEED_MAX}
                    step={ZOOM_SPEED_STEP}
                    value={zoomFullSpeed}
                    onChange={(e) => handleZoomFullSpeedChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={ZOOM_SPEED_MIN}
                    max={ZOOM_SPEED_MAX}
                    step={ZOOM_SPEED_STEP}
                    value={zoomFullSpeed.toFixed(0)}
                    onChange={(e) => handleZoomFullSpeedChange(e.target.value)}
                  />
                </div>
              </label>
              <label title="Controls how quickly the camera interpolates to the new zoom level. Higher values feel snappier; lower values ease slowly.">
                <span>Zoom response</span>
                <div className="field">
                  <input
                    type="range"
                    min={ZOOM_RESPONSE_MIN}
                    max={ZOOM_RESPONSE_MAX}
                    step={ZOOM_RESPONSE_STEP}
                    value={zoomResponseRate}
                    onChange={(e) => handleZoomResponseChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={ZOOM_RESPONSE_MIN}
                    max={ZOOM_RESPONSE_MAX}
                    step={ZOOM_RESPONSE_STEP}
                    value={zoomResponseRate.toFixed(2)}
                    onChange={(e) => handleZoomResponseChange(e.target.value)}
                  />
                </div>
              </label>
              <h3>Decor</h3>
              <label>
                <span>Tree density</span>
                <div className="field">
                  <input
                    type="range"
                    min={0}
                    max={1.2}
                    step={0.05}
                    value={treeDensity}
                    onChange={(e) => setTreeDensity(parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0}
                    max={1.2}
                    step={0.05}
                    value={treeDensity.toFixed(2)}
                    onChange={(e) => setTreeDensity(parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label>
                <span>Building density</span>
                <div className="field">
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.05}
                    value={buildingDensity}
                    onChange={(e) => setBuildingDensity(parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0}
                    max={1}
                    step={0.05}
                    value={buildingDensity.toFixed(2)}
                    onChange={(e) => setBuildingDensity(parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label>
                <span>Kerb width scale</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.4}
                    max={2}
                    step={0.05}
                    value={kerbWidthScaleParam}
                    onChange={(e) => setKerbWidthScaleParam(parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.4}
                    max={2}
                    step={0.05}
                    value={kerbWidthScaleParam.toFixed(2)}
                    onChange={(e) => setKerbWidthScaleParam(parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label>
                <span>Shadow strength</span>
                <div className="field">
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.05}
                    value={shadowStrengthParam}
                    onChange={(e) => setShadowStrengthParam(parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0}
                    max={1}
                    step={0.05}
                    value={shadowStrengthParam.toFixed(2)}
                    onChange={(e) => setShadowStrengthParam(parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <button
                type="button"
                style={{ marginTop: "6px", padding: "6px 10px", borderRadius: "6px", border: "1px solid rgba(148,163,184,0.35)", background: "rgba(37,99,235,0.25)", color: "#e2e8f0", cursor: "pointer" }}
                onClick={() => setDecorSeedOffset((v) => v + 1)}
              >
                Regenerate decor
              </button>
            </div>
            <div className={`dev-panel ai-panel ${activeDevPanel === 'ai' ? "open" : ""}`}>
              <h3>AI Controls</h3>
              <label title={getAiControlDescription("difficulty")}>
                <span>Difficulty</span>
                <select value={aiControls.difficulty} onChange={(e) => handleSetAIDifficulty(e.target.value, true)}>
                  {AVAILABLE_AI_DIFFICULTIES.map((key) => (
                    <option key={key} value={key}>{key.charAt(0).toUpperCase() + key.slice(1)}</option>
                  ))}
                </select>
              </label>
              <label title="Show or hide the path AI cars are targeting.">
                <span>Show racing line</span>
                <div className="field" style={{ justifyContent: "flex-end" }}>
                  <input
                    type="checkbox"
                    checked={showAiLine}
                    onChange={(e) => setShowAiLine(e.target.checked)}
                  />
                </div>
              </label>
              <label title="Select which racing line algorithm to use for AI.">
                <span>Racing line algorithm</span>
                <select value={racingLineMode} onChange={(e) => {
                  setRacingLineMode(e.target.value);
                  // Regenerate racing line and rebuild controllers
                  setTimeout(() => {
                    applyAiLineOverridesRef.current({ forceCustom: true });
                  }, 0);
                }}>
                  <option value="anchor">Anchor (Default)</option>
                  <option value="mcp">MCP (Minimum Curvature)</option>
                </select>
              </label>
              <label title="Choose which racing line to visualize.">
                <span>Visualize line</span>
                <select value={lineVisMode} onChange={(e) => setLineVisMode(e.target.value)}>
                  <option value="anchor">Anchor Only</option>
                  <option value="mcp">MCP Only</option>
                  <option value="both">Both (A/B Compare)</option>
                </select>
              </label>
              <label title="Display validation metrics for racing lines.">
                <span>Show validation metrics</span>
                <div className="field" style={{ justifyContent: "flex-end" }}>
                  <input
                    type="checkbox"
                    checked={showValidationMetrics}
                    onChange={(e) => setShowValidationMetrics(e.target.checked)}
                  />
                </div>
              </label>
              <label title="When enabled, AI cars use the same gearbox settings as the player for each vehicle type.">
                <span>Clone player gearbox</span>
                <div className="field" style={{ justifyContent: "flex-end" }}>
                  <input
                    type="checkbox"
                    checked={clonePlayerGearbox}
                    onChange={(e) => {
                      setClonePlayerGearbox(e.target.checked);
                      // Immediately sync gearboxes when checkbox is toggled on
                      if (e.target.checked) {
                        setTimeout(() => runSyncAIGearboxes(), 0);
                      }
                    }}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("apexAggression")}>
                <span>Apex aggression</span>
                <div className="field">
                  <input
                    type="range"
                    min={0}
                    max={1}
                    step={0.02}
                    value={aiControls.apexAggression}
                    onChange={(e) => handleAiControlChange("apexAggression", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0}
                    max={1}
                    step={0.02}
                    value={aiControls.apexAggression.toFixed(2)}
                    onChange={(e) => handleAiControlChange("apexAggression", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("maxOffset")}>
                <span>Max offset</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.2}
                    max={0.65}
                    step={0.01}
                    value={aiControls.maxOffset}
                    onChange={(e) => handleAiControlChange("maxOffset", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.2}
                    max={0.65}
                    step={0.01}
                    value={aiControls.maxOffset.toFixed(2)}
                    onChange={(e) => handleAiControlChange("maxOffset", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("lookaheadBase")}>
                <span>Lookahead base</span>
                <div className="field">
                  <input
                    type="range"
                    min={20}
                    max={80}
                    step={1}
                    value={aiControls.lookaheadBase}
                    onChange={(e) => handleAiControlChange("lookaheadBase", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={20}
                    max={80}
                    step={1}
                    value={Math.round(aiControls.lookaheadBase)}
                    onChange={(e) => handleAiControlChange("lookaheadBase", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("lookaheadSpeed")}>
                <span>Lookahead / speed</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.08}
                    max={0.25}
                    step={0.01}
                    value={aiControls.lookaheadSpeed}
                    onChange={(e) => handleAiControlChange("lookaheadSpeed", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.08}
                    max={0.25}
                    step={0.01}
                    value={aiControls.lookaheadSpeed.toFixed(2)}
                    onChange={(e) => handleAiControlChange("lookaheadSpeed", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("steerP")}>
                <span>Steer gain (P)</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.8}
                    max={3.2}
                    step={0.05}
                    value={aiControls.steerP}
                    onChange={(e) => handleAiControlChange("steerP", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.8}
                    max={3.2}
                    step={0.05}
                    value={aiControls.steerP.toFixed(2)}
                    onChange={(e) => handleAiControlChange("steerP", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("maxThrottle")}>
                <span>Max throttle</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.6}
                    max={1.2}
                    step={0.01}
                    value={aiControls.maxThrottle}
                    onChange={(e) => handleAiControlChange("maxThrottle", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.6}
                    max={1.2}
                    step={0.01}
                    value={aiControls.maxThrottle.toFixed(2)}
                    onChange={(e) => handleAiControlChange("maxThrottle", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("brakeAggro")}>
                <span>Brake aggression</span>
                <div className="field">
                  <input
                    type="range"
                    min={0.4}
                    max={1.6}
                    step={0.02}
                    value={aiControls.brakeAggro}
                    onChange={(e) => handleAiControlChange("brakeAggro", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0.4}
                    max={1.6}
                    step={0.02}
                    value={aiControls.brakeAggro.toFixed(2)}
                    onChange={(e) => handleAiControlChange("brakeAggro", parseFloat(e.target.value))}
                  />
                </div>
              </label>
              <label title={getAiControlDescription("cornerMargin")}>
                <span>Corner margin</span>
                <div className="field">
                  <input
                    type="range"
                    min={0}
                    max={60}
                    step={1}
                    value={aiControls.cornerMargin}
                    onChange={(e) => handleAiControlChange("cornerMargin", parseFloat(e.target.value))}
                  />
                  <input
                    type="number"
                    min={0}
                    max={60}
                    step={1}
                    value={Math.round(aiControls.cornerMargin)}
                    onChange={(e) => handleAiControlChange("cornerMargin", parseFloat(e.target.value))}
                  />
                </div>
              </label>
            </div>
            <canvas ref={canvasRef} width="1000" height="700"></canvas>
            {showValidationMetrics && (anchorValidation || mcpValidation) && (
              <div style={{
                position: 'absolute',
                top: '80px',
                right: '12px',
                background: 'rgba(3, 5, 12, 0.92)',
                color: '#e6edf6',
                padding: '12px 16px',
                borderRadius: '8px',
                fontSize: '11px',
                lineHeight: '1.6',
                border: '1px solid rgba(59, 130, 246, 0.4)',
                backdropFilter: 'blur(6px)',
                maxWidth: '300px',
                zIndex: 30
              }}>
                <div style={{ fontWeight: 'bold', marginBottom: '8px', fontSize: '12px', color: '#60a5fa' }}>
                  Racing Line Validation
                </div>
                {anchorValidation && lineVisMode !== 'mcp' && (
                  <div style={{ marginBottom: lineVisMode === 'both' ? '12px' : '0' }}>
                    <div style={{ color: '#84cc16', fontWeight: '600', marginBottom: '4px' }}>Anchor Line:</div>
                    <div>Length: {anchorValidation.length.toFixed(0)}px</div>
                    <div style={{ color: anchorValidation.boundaryViolationsCount > 0 ? '#ef4444' : '#6ee7b7' }}>
                      Violations: {anchorValidation.boundaryViolationsCount}
                    </div>
                    {anchorValidation.boundaryViolationsCount > 0 && (
                      <div style={{ color: '#fca5a5', fontSize: '10px' }}>
                        Max penetration: {anchorValidation.maxBoundaryPenetration.toFixed(1)}px
                      </div>
                    )}
                    <div style={{ color: anchorValidation.selfIntersectionsCount > 0 ? '#ef4444' : '#6ee7b7' }}>
                      Self-intersections: {anchorValidation.selfIntersectionsCount}
                    </div>
                    <div>Min edge dist: {anchorValidation.minDistanceToEdge.toFixed(1)}px</div>
                    <div style={{ fontSize: '10px', marginTop: '4px', color: '#94a3b8' }}>
                      Curvature: avg {anchorValidation.curvatureStats.avg.toFixed(5)}
                    </div>
                  </div>
                )}
                {mcpValidation && lineVisMode !== 'anchor' && (
                  <div>
                    <div style={{ color: '#84cc16', fontWeight: '600', marginBottom: '4px' }}>MCP Line:</div>
                    <div>Length: {mcpValidation.length.toFixed(0)}px</div>
                    <div style={{ color: mcpValidation.boundaryViolationsCount > 0 ? '#ef4444' : '#6ee7b7' }}>
                      Violations: {mcpValidation.boundaryViolationsCount}
                    </div>
                    {mcpValidation.boundaryViolationsCount > 0 && (
                      <div style={{ color: '#fca5a5', fontSize: '10px' }}>
                        Max penetration: {mcpValidation.maxBoundaryPenetration.toFixed(1)}px
                      </div>
                    )}
                    <div style={{ color: mcpValidation.selfIntersectionsCount > 0 ? '#ef4444' : '#6ee7b7' }}>
                      Self-intersections: {mcpValidation.selfIntersectionsCount}
                    </div>
                    <div>Min edge dist: {mcpValidation.minDistanceToEdge.toFixed(1)}px</div>
                    <div style={{ fontSize: '10px', marginTop: '4px', color: '#94a3b8' }}>
                      Curvature: avg {mcpValidation.curvatureStats.avg.toFixed(5)}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<TopDownRacer />);
    </script>
    <style>
  /* GBX Panel - positioned at left under Dev menu */
  #gbxPanel { position:fixed; left:12px; top:var(--dev-panel-top, 56px); width:min(280px, calc(100vw - 24px)); max-height:calc(100vh - 80px); overflow:auto; background:rgba(3,5,12,0.92); color:#e6edf6; font:11px/1.5 system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding:10px 14px 10px 10px; border:1px solid rgba(59,130,246,0.4); border-radius:10px; display:none; z-index:35; backdrop-filter:blur(6px); box-sizing:border-box; }
    #gbxPanel .gbx-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    #gbxPanel .gbx-header button { appearance:none; border:0; background:rgba(148,163,184,0.2); color:#e2e8f0; padding:2px 8px; border-radius:6px; cursor:pointer; }
    #gbxPanel .gbx-header button:hover { background:rgba(148,163,184,0.35); }
  #gbxPanel .gbx-row { display:flex; align-items:center; gap:6px; margin-bottom:6px; padding-right:4px; }
    #gbxPanel .gbx-row label { flex:0 0 100px; font-weight:600; font-size:11px; }
    #gbxPanel .gbx-row input[type="range"] { flex:1; accent-color:#2563eb; }
    #gbxPanel .gbx-row input[type="checkbox"] { width:16px; height:16px; }
  #gbxPanel .gbx-value { width:44px; text-align:right; font-feature-settings:"tnum"; opacity:0.85; font-size:10px; }
  #gbxPanel .gbx-btns { display:flex; flex-direction:column; gap:3px; }
  #gbxPanel .gbx-mini { appearance:none; border:1px solid rgba(148,163,184,0.35); background:rgba(23,37,84,0.68); color:#dde8ff; font-size:10px; padding:2px 5px; border-radius:4px; cursor:pointer; }
  #gbxPanel .gbx-mini:hover { background:rgba(59,130,246,0.45); }
    #gbxPanel .gbx-actions { display:flex; gap:6px; margin-top:10px; flex-wrap:wrap; }
    #gbxPanel .gbx-actions button { flex:1 1 auto; min-width:60px; appearance:none; border:1px solid rgba(59,130,246,0.5); background:#1d335f; color:#e2e8f0; padding:5px 4px; border-radius:6px; cursor:pointer; font-weight:600; font-size:10px; }
    #gbxPanel .gbx-actions button:hover { filter:brightness(1.1); }
    /* Hide the old GBX toggle button - now accessed through Dev menu */
    #gbxToggle { display:none !important; }
    @media (max-width: 600px) {
      #gbxPanel { font-size:10px; padding:8px 10px; width:min(240px, calc(100vw - 24px)); }
      #gbxPanel .gbx-row label { flex:0 0 80px; font-size:10px; }
      #gbxPanel .gbx-value { width:36px; font-size:9px; }
    }
    </style>
    <div id="gbxPanel">
      <div class="gbx-header">
        <strong>Gearbox Tuner</strong>
        <button id="gbxClose" type="button" title="Close tuner">✕</button>
      </div>
      <div class="gbx-row" title="Enable automatic shifting handled by the gearbox.">
        <label for="gbxAuto">Auto shift</label>
        <input id="gbxAuto" type="checkbox">
      </div>
      <div class="gbx-row" title="Primary gear ratio for first gear. Higher values shorten the gear but increase torque.">
        <label for="gbxR0">1st gear</label>
        <input id="gbxR0" type="range" min="0.50" max="7.00" step="0.01" data-default="7.00">
        <span class="gbx-value" id="gbxR0Val">7.00</span>
      </div>
      <div class="gbx-row" title="Gear ratio for second gear.">
        <label for="gbxR1">2nd gear</label>
  <input id="gbxR1" type="range" min="0.40" max="5.00" step="0.01" data-default="4.50">
  <span class="gbx-value" id="gbxR1Val">4.50</span>
      </div>
      <div class="gbx-row" title="Gear ratio for third gear.">
        <label for="gbxR2">3rd gear</label>
  <input id="gbxR2" type="range" min="0.30" max="4.00" step="0.01" data-default="3.60">
  <span class="gbx-value" id="gbxR2Val">3.60</span>
      </div>
      <div class="gbx-row" title="Gear ratio for fourth gear.">
        <label for="gbxR3">4th gear</label>
        <input id="gbxR3" type="range" min="0.20" max="3.00" step="0.01" data-default="3.00">
        <span class="gbx-value" id="gbxR3Val">3.00</span>
      </div>
      <div class="gbx-row" title="Gear ratio for fifth gear.">
        <label for="gbxR4">5th gear</label>
        <input id="gbxR4" type="range" min="0.15" max="2.50" step="0.01" data-default="2.50">
        <span class="gbx-value" id="gbxR4Val">2.50</span>
      </div>
      <div class="gbx-row" title="Gear ratio for sixth gear (top gear).">
        <label for="gbxR5">6th gear</label>
        <input id="gbxR5" type="range" min="0.10" max="2.00" step="0.01" data-default="2.00">
        <span class="gbx-value" id="gbxR5Val">2.00</span>
      </div>
      <div class="gbx-row" title="Final drive multiplies each gear ratio. Higher values shorten all gears.">
        <label for="gbxFD">Final drive</label>
  <input id="gbxFD" type="range" min="2.00" max="6.00" step="0.01" data-default="5.00">
  <span class="gbx-value" id="gbxFDVal">5.00</span>
      </div>
      <div class="gbx-row" title="Effective wheel radius in metres. Smaller wheels multiply wheel torque.">
        <label for="gbxWR">Wheel radius</label>
        <input id="gbxWR" type="range" min="0.20" max="0.50" step="0.005" data-default="0.50">
        <span class="gbx-value" id="gbxWRVal">0.500</span>
      </div>
      <div class="gbx-row" title="Engine idle speed. Determines minimum RPM when throttle is released.">
        <label for="gbxIdle">Idle RPM</label>
        <input id="gbxIdle" type="range" min="600" max="3000" step="50" data-default="1100">
        <span class="gbx-value" id="gbxIdleVal">1100</span>
      </div>
      <div class="gbx-row" title="Maximum allowed engine speed. The limiter fades drive torque as you approach this value.">
        <label for="gbxRed">Redline RPM</label>
        <input id="gbxRed" type="range" min="5000" max="9500" step="50" data-default="9500">
        <span class="gbx-value" id="gbxRedVal">9500</span>
      </div>
      <div class="gbx-row" title="RPM target for automatic upshifts.">
        <label for="gbxUp">Upshift RPM</label>
        <input id="gbxUp" type="range" min="2500" max="9000" step="1" data-default="6696">
        <span class="gbx-value" id="gbxUpVal">6696</span>
      </div>
      <div class="gbx-row" title="RPM threshold to downshift when in automatic mode.">
        <label for="gbxDown">Downshift RPM</label>
        <input id="gbxDown" type="range" min="1500" max="5000" step="1" data-default="5040">
        <span class="gbx-value" id="gbxDownVal">5040</span>
      </div>
      <div class="gbx-row" title="Overall driveline efficiency from engine to wheels.">
  <label for="gbxEff">Driveline eff.</label>
  <input id="gbxEff" type="range" min="0.70" max="1.00" step="0.01" data-default="1.00">
  <span class="gbx-value" id="gbxEffVal">1.00</span>
      </div>
      <div class="gbx-row" title="Peak engine torque available at full throttle (before gearing).">
        <label for="gbxTq">Torque peak</label>
        <input id="gbxTq" type="range" min="5" max="400" step="0.5" data-default="260">
        <span class="gbx-value" id="gbxTqVal">260.0</span>
      </div>
      <div class="gbx-row" title="Maximum engine braking torque applied when off throttle.">
        <label for="gbxBrakePeak">Engine brake</label>
        <input id="gbxBrakePeak" type="range" min="0" max="20" step="0.2" data-default="0.0">
        <span class="gbx-value" id="gbxBrakePeakVal">0.0</span>
      </div>
      <div class="gbx-row" title="Dead zone before throttle engages (helps avoid accidental inputs).">
        <label for="gbxThrottle">Throttle deadzone</label>
        <input id="gbxThrottle" type="range" min="0" max="0.20" step="0.005" data-default="0.05">
        <span class="gbx-value" id="gbxThrottleVal">0.050</span>
      </div>
      <div class="gbx-row" title="Time in milliseconds where drive torque is cut during upshifts.">
        <label for="gbxCut">Shift cut (ms)</label>
        <input id="gbxCut" type="range" min="0" max="200" step="5" data-default="110">
        <span class="gbx-value" id="gbxCutVal">110</span>
      </div>
      <div class="gbx-row" title="Engine flywheel inertia. Higher values slow RPM changes.">
        <label for="gbxIn">Engine inertia</label>
        <input id="gbxIn" type="range" min="0.05" max="0.60" step="0.01" data-default="0.60">
        <span class="gbx-value" id="gbxInVal">0.60</span>
      </div>
      <div class="gbx-row" title="Rate at which the clutch locks after a shift.">
        <label for="gbxCE">Clutch engage</label>
        <input id="gbxCE" type="range" min="1" max="12" step="0.1" data-default="12.0">
        <span class="gbx-value" id="gbxCEVal">12.0</span>
      </div>
      <div class="gbx-row" title="Extra RPM boost allowed while slipping the clutch under throttle.">
        <label for="gbxSB">Clutch slip boost</label>
        <input id="gbxSB" type="range" min="0" max="1" step="0.01" data-default="0.00">
        <span class="gbx-value" id="gbxSBVal">0.00</span>
      </div>
      <div class="gbx-actions">
        <button id="gbxSave" type="button">Save</button>
        <button id="gbxPresetChoose" type="button">Choose Preset</button>
        <button id="gbxPresetSave" type="button">Save Preset</button>
        <button id="gbxReset" type="button">Reset</button>
      </div>
    </div>
    <button id="gbxToggle">GBX</button>
    <script>
    (function(){
      const QS = (id) => document.getElementById(id);
      const panel = QS('gbxPanel');
      const toggle = QS('gbxToggle');
      const closeBtn = QS('gbxClose');
  const presetBtn = QS('gbxPresetSave');
  const presetChooseBtn = QS('gbxPresetChoose');

      if (!panel || !toggle || !closeBtn) {
        window.GEARBOX_DEFAULTS = window.GEARBOX_DEFAULTS || {};
        return;
      }

      const CONTROL_DEFS = [
        { id: 'gbxAuto', prop: 'auto', type: 'checkbox' },
        { id: 'gbxR0', prop: 'ratios', index: 0, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxR1', prop: 'ratios', index: 1, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxR2', prop: 'ratios', index: 2, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxR3', prop: 'ratios', index: 3, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxR4', prop: 'ratios', index: 4, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxR5', prop: 'ratios', index: 5, type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxFD', prop: 'finalDrive', type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxWR', prop: 'wheelRadius', type: 'range', format: (v) => v.toFixed(3) },
        { id: 'gbxIdle', prop: 'idleRPM', type: 'range', format: (v) => Math.round(v) },
        { id: 'gbxRed', prop: 'redlineRPM', type: 'range', format: (v) => Math.round(v) },
        { id: 'gbxUp', prop: 'upshiftRPM', type: 'range', format: (v) => Math.round(v) },
        { id: 'gbxDown', prop: 'downshiftRPM', type: 'range', format: (v) => Math.round(v) },
        { id: 'gbxEff', prop: 'drivelineEff', type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxTq', prop: 'torquePeak', type: 'range', format: (v) => v.toFixed(1) },
        { id: 'gbxBrakePeak', prop: 'engineBrakePeak', type: 'range', format: (v) => v.toFixed(1) },
        { id: 'gbxThrottle', prop: 'throttleDead', type: 'range', format: (v) => v.toFixed(3) },
        { id: 'gbxCut', prop: 'shiftCutMs', type: 'range', format: (v) => Math.round(v) },
        { id: 'gbxIn', prop: 'engineInertia', type: 'range', format: (v) => v.toFixed(2) },
        { id: 'gbxCE', prop: 'clutchEngageRate', type: 'range', format: (v) => v.toFixed(1) },
        { id: 'gbxSB', prop: 'clutchSlipBoost', type: 'range', format: (v) => v.toFixed(2) }
      ];
      const CONTROL_LOOKUP = {};
      CONTROL_DEFS.forEach((def) => { CONTROL_LOOKUP[def.id] = def; });
      const RANGE_CONTROLS = CONTROL_DEFS.filter((def) => def.type === 'range');

      const PRESET_STORAGE_KEY = 'gearboxCfg_presets';

      function getDefaultConfig() {
        const defaults = window.GEARBOX_DEFAULTS;
        if (defaults && Object.keys(defaults).length) return defaults;
        const moduleDefaults = window.GearboxModule?.gearboxDefaults;
        return moduleDefaults || null;
      }

      function cloneConfig(source){
        if (!source) return null;
        const cfg = { ...source };
        if (Array.isArray(source.ratios)) cfg.ratios = [...source.ratios];
        return cfg;
      }

      function getPlayerCar(){
        return window.game?.playerCar || window.playerCar || window.car || null;
      }

      function readCfgFromCar(){
        const car = getPlayerCar();
        if (!car?.gearbox) return null;
        return cloneConfig(car.gearbox.c);
      }

      function applyCfgToCar(cfg){
        const car = getPlayerCar();
        if (!car?.gearbox || !cfg) return;
        if (Array.isArray(cfg.ratios)) {
          car.gearbox.c.ratios = [...cfg.ratios];
        }
        const assignable = { ...cfg };
        delete assignable.ratios;
        Object.assign(car.gearbox.c, assignable);
      }

      function loadStore(){
        try {
          const raw = localStorage.getItem('gearboxCfg_activeProfile');
          return raw ? cloneConfig(JSON.parse(raw)) : null;
        } catch (e) {
          return null;
        }
      }

      function saveStore(cfg){
        if (!cfg) return;
        try {
          localStorage.setItem('gearboxCfg_activeProfile', JSON.stringify(cfg));
        } catch (e) {}
      }

      function clampToInputRange(input, value){
        if (value == null) return null;
        let num = Number(value);
        if (!Number.isFinite(num)) return null;
        if (input) {
          const minAttr = input.min;
          const maxAttr = input.max;
          const min = minAttr !== undefined && minAttr !== '' ? parseFloat(minAttr) : NaN;
          const max = maxAttr !== undefined && maxAttr !== '' ? parseFloat(maxAttr) : NaN;
          if (!Number.isNaN(min)) num = Math.max(num, min);
          if (!Number.isNaN(max)) num = Math.min(num, max);
        }
        return num;
      }

      function resolveDefault(def, inputEl){
        const defaults = getDefaultConfig() || {};
        const input = inputEl || QS(def.id);
        if (def.type === 'checkbox') {
          if (def.prop && defaults[def.prop] != null) return !!defaults[def.prop];
          if (input) return !!input.defaultChecked;
          return true;
        }
        if (def.prop === 'ratios') {
          const arr = defaults.ratios;
          if (Array.isArray(arr) && arr[def.index] != null) {
            const clamped = clampToInputRange(input, arr[def.index]);
            if (clamped != null) return clamped;
          }
        } else if (def.prop && defaults[def.prop] != null) {
          const clampedProp = clampToInputRange(input, defaults[def.prop]);
          if (clampedProp != null) return clampedProp;
        }
        if (input) {
          const dataDefault = input.dataset.default;
          if (dataDefault != null) {
            const clampedData = clampToInputRange(input, dataDefault);
            if (clampedData != null) return clampedData;
          }
          const base = clampToInputRange(input, input.defaultValue);
          if (base != null) return base;
          const min = clampToInputRange(input, input.min);
          if (min != null) return min;
        }
        const fallback = clampToInputRange(input, 0);
        return fallback != null ? fallback : 0;
      }

      function normalizeGearboxConfig(cfg){
        if (!cfg) return cfg;
        const ensureNumber = (value) => {
          const num = Number(value);
          return Number.isFinite(num) ? num : undefined;
        };
        const redline = ensureNumber(cfg.redlineRPM ?? cfg.redlineRpm);
        if (redline && redline > 0) {
          const upRpm = ensureNumber(cfg.upshiftRPM);
          if (upRpm !== undefined) cfg.upshiftFrac = Math.max(0, Math.min(1, upRpm / redline));
          const downRpm = ensureNumber(cfg.downshiftRPM);
          if (downRpm !== undefined) cfg.downshiftFrac = Math.max(0, Math.min(1, downRpm / redline));
        }
        const wheel = ensureNumber(cfg.wheelRadius);
        const tire = ensureNumber(cfg.tireRadiusM);
        if (wheel !== undefined) cfg.tireRadiusM = wheel;
        else if (tire !== undefined) cfg.wheelRadius = tire;
        return cfg;
      }

      function updateSliderLabel(def, value){
        const display = QS(def.id + 'Val');
        if (!display) return;
        const formatter = def.format || ((v) => v);
        const numeric = Number(value);
        display.textContent = formatter(Number.isNaN(numeric) ? 0 : numeric);
      }

      function setSlider(def, value){
        const input = QS(def.id);
        if (!input) return null;
        let assigned = clampToInputRange(input, value);
        if (assigned == null) assigned = clampToInputRange(input, resolveDefault(def, input));
        if (assigned == null) assigned = clampToInputRange(input, 0) ?? 0;
        input.value = String(assigned);
        updateSliderLabel(def, assigned);
        return assigned;
      }

      function setControl(def, value){
        const input = QS(def.id);
        if (!input) return null;
        if (def.type === 'checkbox') {
          const assigned = value != null ? !!value : !!resolveDefault(def);
          input.checked = assigned;
          return assigned;
        }
        return setSlider(def, value);
      }

      function fillForm(cfg){
        const defaults = getDefaultConfig() || {};
        CONTROL_DEFS.forEach((def) => {
          let value;
          if (def.prop === 'ratios') {
            value = cfg?.ratios?.[def.index];
            if (value == null) value = defaults.ratios?.[def.index];
          } else {
            value = cfg?.[def.prop];
            if (value == null) value = defaults[def.prop];
          }
          setControl(def, value);
        });
      }

      function readForm(){
        const defaults = getDefaultConfig();
        const base = readCfgFromCar() || loadStore() || cloneConfig(defaults) || { auto: true, ratios: [] };
        const cfg = cloneConfig(base) || { auto: true, ratios: [] };
        if (!Array.isArray(cfg.ratios)) cfg.ratios = [];
        CONTROL_DEFS.forEach((def) => {
          const input = QS(def.id);
          if (!input) return;
          if (def.type === 'checkbox') {
            cfg[def.prop] = input.checked;
            return;
          }
          const val = parseFloat(input.value);
          if (Number.isNaN(val)) return;
          if (def.prop === 'ratios') {
            cfg.ratios[def.index] = val;
          } else {
            cfg[def.prop] = val;
          }
        });
        const defaultRatios = Array.isArray(defaults?.ratios) ? defaults.ratios : [];
        const maxLen = Math.max(cfg.ratios.length, defaultRatios.length, 6);
        for (let i = 0; i < maxLen; i += 1) {
          if (cfg.ratios[i] == null && defaultRatios[i] != null) {
            cfg.ratios[i] = defaultRatios[i];
          }
        }
        cfg.ratios = cfg.ratios.slice(0, maxLen);
        return cfg;
      }

      function persistConfig(cfg){
        const payload = cloneConfig(cfg);
        normalizeGearboxConfig(payload);
        applyCfgToCar(payload);
        const stored = readCfgFromCar();
        if (stored) {
          normalizeGearboxConfig(stored);
          saveStore(stored);
          return stored;
        }
        if (payload) saveStore(payload);
        return stored || payload;
      }

      function getWorkingConfig(){
        const fromForm = readForm();
        if (fromForm) return cloneConfig(fromForm);
        const fallback = readCfgFromCar() || loadStore() || cloneConfig(getDefaultConfig());
        return cloneConfig(fallback) || { auto: true, ratios: [] };
      }

      function handleControlAction(def, action){
        if (!def) return;
        const cfg = getWorkingConfig();
        if (!Array.isArray(cfg.ratios)) cfg.ratios = [];
        if (action === 'default') {
          const defaultValue = resolveDefault(def);
          const assigned = setControl(def, defaultValue);
          if (def.type === 'checkbox') {
            if (def.prop) cfg[def.prop] = !!assigned;
          } else if (def.prop === 'ratios') {
            const numeric = Number(assigned);
            cfg.ratios[def.index] = Number.isFinite(numeric) ? numeric : Number(resolveDefault(def));
          } else if (def.prop) {
            const numeric = Number(assigned);
            cfg[def.prop] = Number.isFinite(numeric) ? numeric : Number(resolveDefault(def));
          }
          normalizeGearboxConfig(cfg);
          const storedDefault = persistConfig(cfg);
          fillForm(storedDefault || cfg);
          return;
        }
        if (action === 'save') {
          normalizeGearboxConfig(cfg);
          const storedSave = persistConfig(cfg);
          fillForm(storedSave || cfg);
          return;
        }
      }

      function ensureControlButtons(def){
        const input = QS(def.id);
        if (!input) return;
        const row = input.closest('.gbx-row');
        if (!row || row.querySelector(`.gbx-btns[data-for="${def.id}"]`)) return;
        const btns = document.createElement('div');
        btns.className = 'gbx-btns';
        btns.dataset.for = def.id;
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'gbx-mini';
        saveBtn.dataset.control = def.id;
        saveBtn.dataset.action = 'save';
        saveBtn.textContent = 'Save';
        const defaultBtn = document.createElement('button');
        defaultBtn.type = 'button';
        defaultBtn.className = 'gbx-mini';
        defaultBtn.dataset.control = def.id;
        defaultBtn.dataset.action = 'default';
        defaultBtn.textContent = 'Default';
        btns.append(saveBtn, defaultBtn);
        row.appendChild(btns);
      }

      function loadPresetMap(){
        try {
          const raw = localStorage.getItem(PRESET_STORAGE_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch (e) {
          return {};
        }
      }

      function savePresetMap(map){
        try {
          localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(map));
        } catch (e) {}
      }

      function openPanel(){
        const cfg = readCfgFromCar() || loadStore() || cloneConfig(getDefaultConfig());
        fillForm(cfg || {});
        panel.style.display = 'block';
      }

      function closePanel(){
        panel.style.display = 'none';
      }

      CONTROL_DEFS.forEach(ensureControlButtons);

      RANGE_CONTROLS.forEach((def) => {
        const input = QS(def.id);
        if (!input) return;
        input.addEventListener('input', () => {
          updateSliderLabel(def, parseFloat(input.value));
        });
      });

      panel.addEventListener('click', (event) => {
        const target = event.target.closest('button[data-control]');
        if (!target || !panel.contains(target)) return;
        const def = CONTROL_LOOKUP[target.dataset.control];
        if (!def) return;
        handleControlAction(def, target.dataset.action);
        event.preventDefault();
        event.stopPropagation();
      });

      toggle.addEventListener('click', openPanel);
      closeBtn.addEventListener('click', closePanel);

      window.addEventListener('keydown', (e) => {
        if (e.code === 'F9') {
          if (panel.style.display === 'none' || !panel.style.display) openPanel();
          else closePanel();
        }
        if (panel.style.display !== 'block') return;
        const car = getPlayerCar();
        if (!car?.gearbox) return;
        if (e.defaultPrevented || e.repeat) return;
        const stop = () => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation?.();
        };
        if (e.code === 'KeyQ') {
          car.gearbox.shiftDown();
          stop();
        } else if (e.code === 'KeyE') {
          car.gearbox.shiftUp();
          stop();
        } else if (e.code === 'KeyM') {
          car.gearbox.setManual(!(car.gearbox.c.auto));
          stop();
        }
      });

      const saveBtn = QS('gbxSave');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          const stored = persistConfig(readForm());
          fillForm(stored || {});
        });
      }

      const resetBtn = QS('gbxReset');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          const defaults = cloneConfig(getDefaultConfig());
          if (!defaults) return;
          const stored = persistConfig(defaults);
          fillForm(stored || defaults);
        });
      }

      if (presetBtn) {
        presetBtn.addEventListener('click', () => {
          const name = (window.prompt('Enter a name for this gearbox preset:') || '').trim();
          if (!name) return;
          const presets = loadPresetMap();
          if (presets[name] && !window.confirm(`Preset "${name}" exists. Overwrite?`)) return;
          const stored = persistConfig(readForm());
          if (!stored) return;
          presets[name] = cloneConfig(stored);
          savePresetMap(presets);
          console.info(`[Gearbox] Saved preset "${name}"`, stored);
        });
      }

      if (presetChooseBtn) {
        presetChooseBtn.addEventListener('click', () => {
          const presets = loadPresetMap();
          const names = Object.keys(presets);
          if (!names.length) {
            window.alert('No presets saved yet. Save one first.');
            return;
          }
          const list = names.map((name, index) => `${index + 1}. ${name}`).join('\n');
          const response = (window.prompt(`Select a preset by number or name:\n${list}`) || '').trim();
          if (!response) return;
          let chosen = null;
          if (presets[response]) {
            chosen = response;
          } else {
            const asNumber = parseInt(response, 10);
            if (!Number.isNaN(asNumber) && asNumber >= 1 && asNumber <= names.length) {
              chosen = names[asNumber - 1];
            } else {
              const match = names.find((name) => name.toLowerCase() === response.toLowerCase());
              if (match) chosen = match;
            }
          }
          if (!chosen) {
            window.alert('Preset not found.');
            return;
          }
          const selected = cloneConfig(presets[chosen]);
          if (!selected) {
            window.alert('Preset data is unavailable.');
            return;
          }
          const applied = persistConfig(selected);
          fillForm(applied || selected);
          console.info(`[Gearbox] Loaded preset "${chosen}"`, applied || selected);
        });
      }

      window.GEARBOX_DEFAULTS = window.GEARBOX_DEFAULTS || {};
    })();
    </script>
    <script>
      // Register service worker only on http(s)
      if ('serviceWorker' in navigator && /^https?:$/i.test(location.protocol)) {
        window.addEventListener('load', function(){
          navigator.serviceWorker.register('service-worker.js').catch(function(e){ console.warn('SW reg failed', e); });
        });
      }
    </script>
  </body>
</html>
