<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optimal Racing Line Visualization</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    h1 {
      text-align: center;
      color: #60a5fa;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .controls {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      color: #94a3b8;
    }
    select, input[type="range"], input[type="number"], button {
      width: 100%;
      padding: 8px;
      background: #1a1a1a;
      border: 1px solid #404040;
      color: #fff;
      border-radius: 4px;
    }
    button {
      background: #3b82f6;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover {
      background: #2563eb;
    }
    canvas {
      border: 2px solid #404040;
      border-radius: 8px;
      background: #0a0a0a;
      display: block;
      margin: 0 auto;
    }
    .metrics {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      margin-top: 20px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    .metric-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .metric-value {
      color: #60a5fa;
      font-weight: bold;
    }
    .legend {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin: 20px 0;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-line {
      width: 40px;
      height: 3px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèéÔ∏è Optimal Racing Line Visualization</h1>
    
    <div class="controls">
      <div class="control-group">
        <label>Track Type:</label>
        <select id="trackType">
          <option value="circle">Circle (Constant Curvature)</option>
          <option value="corner">90-Degree Corner</option>
          <option value="wavy">Wavy Track (Straightening Test)</option>
          <option value="chicane">Chicane (S-Curve)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Iterations: <span id="iterLabel">200</span></label>
        <input type="range" id="iterations" min="50" max="500" value="200" step="10">
      </div>
      
      <div class="control-group">
        <label>Lambda (Smoothing): <span id="lambdaLabel">0.10</span></label>
        <input type="range" id="lambda" min="0.01" max="0.3" value="0.1" step="0.01">
      </div>
      
      <div class="control-group">
        <label>Safety Margin: <span id="marginLabel">15</span>px</label>
        <input type="range" id="margin" min="5" max="30" value="15" step="1">
      </div>
      
      <button onclick="generateLine()">Generate Racing Line</button>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-line" style="background: #9aa5b1;"></div>
        <span>Centerline</span>
      </div>
      <div class="legend-item">
        <div class="legend-line" style="background: #fbbf24; border: 1px dashed #fff;"></div>
        <span>Corridor Bounds</span>
      </div>
      <div class="legend-item">
        <div class="legend-line" style="background: #ef4444;"></div>
        <span>Optimal Line</span>
      </div>
    </div>
    
    <canvas id="canvas" width="1200" height="800"></canvas>
    
    <div class="metrics" id="metrics">
      <div class="metric-row">
        <span>Status:</span>
        <span class="metric-value" id="status">Click "Generate Racing Line" to start</span>
      </div>
    </div>
  </div>

  <script src="../utils/utils.js"></script>
  <script src="../ai/optimal_line.js"></script>
  <script>
    // Validate dependencies are loaded
    if (typeof window.RacerUtils === 'undefined') {
      console.error('RacerUtils not loaded. Make sure utils/utils.js is available.');
      document.getElementById('status').textContent = 'Error: utils.js failed to load';
    }
    if (typeof window.RacerOptimalLine === 'undefined') {
      console.error('RacerOptimalLine not loaded. Make sure ai/optimal_line.js is available.');
      document.getElementById('status').textContent = 'Error: optimal_line.js failed to load';
    }
  </script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Update labels
    document.getElementById('iterations').addEventListener('input', (e) => {
      document.getElementById('iterLabel').textContent = e.target.value;
    });
    document.getElementById('lambda').addEventListener('input', (e) => {
      document.getElementById('lambdaLabel').textContent = parseFloat(e.target.value).toFixed(2);
    });
    document.getElementById('margin').addEventListener('input', (e) => {
      document.getElementById('marginLabel').textContent = e.target.value;
    });

    function generateTrack(type) {
      const tracks = {
        circle: () => {
          const points = [];
          const radius = 300;
          const numPoints = 50;
          for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * Math.PI * 2;
            points.push({
              x: 600 + radius * Math.cos(angle),
              y: 400 + radius * Math.sin(angle)
            });
          }
          return points;
        },
        
        corner: () => {
          const points = [];
          const straight1 = 300;
          const cornerRadius = 150;
          const cornerPoints = 25;

          // Entry straight
          for (let i = 0; i < 30; i++) {
            points.push({ x: 300, y: 700 - (i / 30) * straight1 });
          }

          // 90-degree turn
          const turnCenterX = 300 + cornerRadius;
          const turnCenterY = 700 - straight1;
          for (let i = 0; i <= cornerPoints; i++) {
            const angle = Math.PI + (i / cornerPoints) * (Math.PI / 2);
            points.push({
              x: turnCenterX + cornerRadius * Math.cos(angle),
              y: turnCenterY + cornerRadius * Math.sin(angle)
            });
          }

          // Exit straight
          for (let i = 1; i <= 30; i++) {
            points.push({
              x: turnCenterX + cornerRadius + (i / 30) * straight1,
              y: turnCenterY
            });
          }

          // Close loop
          const endX = turnCenterX + cornerRadius + straight1;
          for (let i = 1; i < 30; i++) {
            const t = i / 30;
            points.push({ x: endX, y: turnCenterY + (700 - turnCenterY) * t });
          }
          for (let i = 1; i < 30; i++) {
            const t = i / 30;
            points.push({ x: endX - (endX - 300) * t, y: 700 });
          }

          return points;
        },
        
        wavy: () => {
          const points = [];
          const length = 800;
          const amplitude = 40;
          const frequency = 4;
          
          for (let i = 0; i < 100; i++) {
            const t = i / 100;
            points.push({
              x: 200 + length * t,
              y: 300 + amplitude * Math.sin(t * Math.PI * 2 * frequency)
            });
          }
          
          for (let i = 99; i > 0; i--) {
            const t = i / 100;
            points.push({
              x: 200 + length * t,
              y: 500 - amplitude * Math.sin(t * Math.PI * 2 * frequency)
            });
          }
          
          return points;
        },
        
        chicane: () => {
          const points = [];
          const straight = 200;
          const offset = 100;
          
          // Entry
          for (let i = 0; i < 30; i++) {
            points.push({ x: 200 + (i / 30) * straight, y: 400 });
          }
          
          // Left kink
          for (let i = 0; i <= 20; i++) {
            const t = i / 20;
            points.push({
              x: 200 + straight + t * straight,
              y: 400 - offset * Math.sin(t * Math.PI)
            });
          }
          
          // Right kink
          for (let i = 0; i <= 20; i++) {
            const t = i / 20;
            points.push({
              x: 200 + straight * 2 + t * straight,
              y: 400 + offset * Math.sin(t * Math.PI)
            });
          }
          
          // Exit
          for (let i = 1; i <= 30; i++) {
            points.push({ x: 200 + straight * 3 + (i / 30) * straight, y: 400 });
          }
          
          // Close loop
          const endX = 200 + straight * 4;
          for (let i = 1; i < 40; i++) {
            const t = i / 40;
            points.push({ x: endX - (endX - 200) * t, y: 600 });
          }
          for (let i = 1; i < 20; i++) {
            const t = i / 20;
            points.push({ x: 200, y: 600 - 200 * t });
          }
          
          return points;
        }
      };
      
      return tracks[type]();
    }

    function drawTrack(centerline, bounds, racingLine) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw corridor bounds
      if (bounds && bounds.leftBound && bounds.rightBound) {
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        ctx.beginPath();
        bounds.leftBound.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.stroke();
        
        ctx.beginPath();
        bounds.rightBound.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.stroke();
        
        ctx.setLineDash([]);
      }
      
      // Draw centerline
      ctx.strokeStyle = '#9aa5b1';
      ctx.lineWidth = 2;
      ctx.beginPath();
      centerline.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.closePath();
      ctx.stroke();
      
      // Draw racing line
      if (racingLine && racingLine.length > 0) {
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        racingLine.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.stroke();
        
        // Draw direction indicators
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        for (let i = 0; i < racingLine.length; i += 12) {
          const p = racingLine[i];
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function displayMetrics(metrics, time) {
      const metricsEl = document.getElementById('metrics');
      metricsEl.innerHTML = `
        <div class="metric-row">
          <span>Status:</span>
          <span class="metric-value">‚úì Generated successfully in ${time}ms</span>
        </div>
        <div class="metric-row">
          <span>Points:</span>
          <span class="metric-value">${metrics.points}</span>
        </div>
        <div class="metric-row">
          <span>Max Lateral Step:</span>
          <span class="metric-value">${metrics.maxLateralStep.toFixed(2)} px</span>
        </div>
        <div class="metric-row">
          <span>Min Margin to Bounds:</span>
          <span class="metric-value">${metrics.minMargin.toFixed(2)} px</span>
        </div>
        <div class="metric-row">
          <span>Path Length:</span>
          <span class="metric-value">${metrics.pathLength.toFixed(1)} px</span>
        </div>
        <div class="metric-row">
          <span>Max Curvature:</span>
          <span class="metric-value">${metrics.maxCurvature.toFixed(6)}</span>
        </div>
        <div class="metric-row">
          <span>Smoothness:</span>
          <span class="metric-value">${metrics.maxLateralStep < 10 ? '‚úì Smooth' : '‚ö† Rough'}</span>
        </div>
        <div class="metric-row">
          <span>Boundary Compliance:</span>
          <span class="metric-value">${metrics.minMargin >= 0 ? '‚úì Valid' : '‚úó Violations'}</span>
        </div>
      `;
    }

    function generateLine() {
      const trackType = document.getElementById('trackType').value;
      const iterations = parseInt(document.getElementById('iterations').value);
      const lambda = parseFloat(document.getElementById('lambda').value);
      const margin = parseInt(document.getElementById('margin').value);
      
      const centerline = generateTrack(trackType);
      const roadWidth = 80;
      
      const startTime = performance.now();
      const result = window.RacerOptimalLine.generate(centerline, roadWidth, {
        debugMode: false,
        iterations: iterations,
        lambda: lambda,
        safetyMargin: margin
      });
      const endTime = performance.now();
      
      // Build bounds for visualization
      const leftBound = [];
      const rightBound = [];
      if (result && result.length > 0) {
        for (let i = 0; i < result.length; i++) {
          const node = result[i];
          if (node.centerX !== undefined) {
            leftBound.push({
              x: node.centerX + node.normalX * node.aMax,
              y: node.centerY + node.normalY * node.aMax
            });
            rightBound.push({
              x: node.centerX + node.normalX * node.aMin,
              y: node.centerY + node.normalY * node.aMin
            });
          }
        }
      }
      
      drawTrack(centerline, { leftBound, rightBound }, result);
      
      // Calculate metrics
      let maxLateralStep = 0;
      let minMargin = Infinity;
      let pathLength = 0;
      let maxCurvature = 0;
      
      for (let i = 0; i < result.length; i++) {
        const prev = result[(i - 1 + result.length) % result.length];
        maxLateralStep = Math.max(maxLateralStep, Math.abs(result[i].offset - prev.offset));
        minMargin = Math.min(minMargin, result[i].offset - result[i].aMin, result[i].aMax - result[i].offset);
        
        const next = result[(i + 1) % result.length];
        const dx = next.x - result[i].x;
        const dy = next.y - result[i].y;
        pathLength += Math.hypot(dx, dy);
        
        // Curvature calculation
        const v1x = result[i].x - prev.x;
        const v1y = result[i].y - prev.y;
        const v2x = next.x - result[i].x;
        const v2y = next.y - result[i].y;
        const len1 = Math.hypot(v1x, v1y) || 1;
        const len2 = Math.hypot(v2x, v2y) || 1;
        const cross = Math.abs((v1x / len1) * (v2y / len2) - (v1y / len1) * (v2x / len2));
        const curvature = cross / ((len1 + len2) / 2);
        maxCurvature = Math.max(maxCurvature, curvature);
      }
      
      displayMetrics({
        points: result.length,
        maxLateralStep,
        minMargin,
        pathLength,
        maxCurvature
      }, (endTime - startTime).toFixed(1));
    }
    
    // Generate initial line
    generateLine();
  </script>
</body>
</html>
