<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <title>Top‑Down Racer — Bigger Track + 9 AI + Collisions</title>
    <meta name="theme-color" content="#0a0a0a" />
    <link rel="manifest" href="manifest.webmanifest" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="physics.js"></script>
    <script src="track_storage.js"></script>
    <style>
      html, body, #root { height: 100%; margin: 0; }
      body { background: #0a0a0a; color: #eee; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow:hidden; overscroll-behavior:none; }
      .wrap { display:flex; flex-direction:column; align-items:center; gap:12px; padding:16px; }
      canvas { border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,.6); background: #000; touch-action: none; }
      .subtitle { opacity:.9; font-size: 12px; }
      .note { opacity:.7; font-size: 11px; }
      .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#1f2937; font-size:12px; margin-left:8px; }
      /* Mobile HUD buttons */
      .hud { position:fixed; inset:0; pointer-events:none; }
      .btn { position:absolute; width:72px; height:72px; border-radius:50%; background:#1f2937a6; color:#fff; display:grid; place-items:center; pointer-events:auto; user-select:none; touch-action:none; -webkit-tap-highlight-color: transparent; }
      .btn:active { background:#374151cc; }
      .btn.left  { left:16px; bottom:104px; }
      .btn.right { left:104px; bottom:104px; }
      .btn.thr   { right:16px; bottom:168px; }
      .btn.brk   { right:16px; bottom:80px; }
  .btn.gyro  { right:16px; top:16px; width:56px; height:40px; border-radius:8px; font-size:12px; }
      @media (min-width: 900px) { .hud { display:none; } }
      /* Portrait orientation warning */
      .portrait-warning { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(10,10,10,0.94); color:#fff; z-index:10; text-align:center; padding:24px; }
      .portrait-warning .box { max-width:520px; border:1px solid #2a2a2a; border-radius:12px; padding:18px; background:#111; }
      @media (orientation: portrait) { .portrait-warning { display:flex; } }
      .dev-toggle { position:fixed; top:16px; right:16px; padding:6px 12px; border-radius:999px; border:1px solid #1f2937; background:rgba(15,23,42,0.88); color:#e2e8f0; font-size:12px; cursor:pointer; z-index:30; }
      .dev-toggle:hover { background:rgba(30,41,59,0.94); }
      .dev-panel { position:fixed; top:56px; right:16px; width:220px; padding:12px; border-radius:12px; border:1px solid rgba(71,85,105,0.6); background:rgba(15,23,42,0.94); color:#e2e8f0; font-size:12px; display:none; gap:10px; box-shadow:0 12px 32px rgba(15,23,42,0.45); z-index:30; }
      .dev-panel.open { display:flex; flex-direction:column; }
      .dev-panel h3 { margin:0 0 4px; font-size:13px; font-weight:600; }
      .dev-panel .field { display:grid; grid-template-columns:1fr 64px; align-items:center; gap:8px; }
      .dev-panel label { display:flex; flex-direction:column; gap:6px; font-size:12px; color:#94a3b8; }
      .dev-panel input[type="range"] { width:100%; accent-color:#38bdf8; }
      .dev-panel input[type="number"] { width:100%; padding:4px 6px; border-radius:6px; border:1px solid rgba(148,163,184,0.5); background:#0f172a; color:#e2e8f0; font-size:12px; }
      .hud-tip { position:fixed; top:16px; left:50%; transform:translateX(-50%); padding:6px 14px; border-radius:999px; background:rgba(15,23,42,0.92); color:#e2e8f0; font-size:12px; z-index:28; box-shadow:0 8px 20px rgba(15,23,42,0.45); pointer-events:none; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <!-- Mobile HUD overlay for touch controls -->
    <!-- Portrait orientation guidance -->
    <div class="portrait-warning" aria-live="polite">
      <div class="box">
        <h2 style="margin:0 0 8px; font:700 20px system-ui">Rotate device</h2>
        <p style="margin:0; opacity:.9">This game is best played in landscape. Please rotate your device.</p>
      </div>
    </div>
    <div class="hud" aria-hidden="true">
      <div class="btn left"  title="Left">◄</div>
      <div class="btn right" title="Right">►</div>
      <div class="btn thr"   title="Throttle">▲</div>
      <div class="btn brk"   title="Brake/Reverse">▼</div>
      <div class="btn gyro"   title="Toggle Gyro">GY</div>
    </div>

    <script type="text/babel" data-presets="env,react">
function requestFullscreen(el){
  if (!el) return; try { if (el.requestFullscreen) el.requestFullscreen(); else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); else if (el.msRequestFullscreen) el.msRequestFullscreen(); } catch(_){}
}
function getViewportSize(){ const vv = window.visualViewport; if (vv) return { w: vv.width, h: vv.height }; return { w: window.innerWidth, h: window.innerHeight }; }
let skids = []; // {x1,y1,x2,y2, life}
const SKID_LIFE = 2.2;
const SKID_MAX = 2400;
function addSkid(x1,y1,x2,y2){
  skids.push({x1,y1,x2,y2, life: SKID_LIFE});
  if (skids.length > SKID_MAX) skids.splice(0, skids.length - SKID_MAX);
}
function updateSkids(dt){
  for (let i=skids.length-1;i>=0;i--){
    skids[i].life -= dt;
    if (skids[i].life <= 0) skids.splice(i,1);
  }
}
function drawSkids(ctx){
  if (!skids.length) return;
  ctx.save();
  ctx.lineCap = 'round';
  for (const s of skids){
    const a = Math.max(0, Math.min(1, s.life / SKID_LIFE));
    ctx.globalAlpha = a * 0.55;
    ctx.lineWidth = 2.0;
    ctx.strokeStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.moveTo(s.x1, s.y1);
    ctx.lineTo(s.x2, s.y2);
    ctx.stroke();
  }
  ctx.restore();
}

      
// ===== WebAudio SFX =====
let SFX = null;
function ensureAudio() {
  if (SFX && SFX.ctx && SFX.ctx.state !== 'suspended') return SFX;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioCtx();
    const master = ctx.createGain(); master.gain.value = 0.9; master.connect(ctx.destination);

    // Engine: two oscillators + mild drive + lowpass "intake" filter
    const engGain = ctx.createGain(); engGain.gain.value = 0.0; engGain.connect(master);
    const engLP = ctx.createBiquadFilter(); engLP.type='lowpass'; engLP.frequency.value=500; engLP.Q.value = 0.7; engLP.connect(engGain);
    const oscA = ctx.createOscillator(); oscA.type='sawtooth'; oscA.frequency.value = 100; oscA.connect(engLP); oscA.start();
    const oscB = ctx.createOscillator(); oscB.type='square';   oscB.frequency.value = 50;  oscB.detune.value = 6; oscB.connect(engLP); oscB.start();

    // Exhaust/wind/skid noise buffers
    function makeNoise(){
      const len = ctx.sampleRate * 2;
      const buf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<len;i++) data[i] = Math.random()*2-1;
      const src = ctx.createBufferSource();
      src.buffer = buf; src.loop = true; return src;
    }

    // Wind (speed hiss)
    const windSrc = makeNoise(); 
    const windHP = ctx.createBiquadFilter(); windHP.type='highpass'; windHP.frequency.value=400;
    const windGain = ctx.createGain(); windGain.gain.value = 0.0;
    windSrc.connect(windHP); windHP.connect(windGain); windGain.connect(master); windSrc.start();

    // Skid (tire squeal)
    const skidSrc = makeNoise();
    const skidBP = ctx.createBiquadFilter(); skidBP.type='bandpass'; skidBP.frequency.value=3800; skidBP.Q.value=3.0;
    const skidGain = ctx.createGain(); skidGain.gain.value = 0.0;
    skidSrc.connect(skidBP); skidBP.connect(skidGain); skidGain.connect(master); skidSrc.start();

    // Grass rumble (lower freq noise)
    const grassSrc = makeNoise();
    const grassBP = ctx.createBiquadFilter(); grassBP.type='bandpass'; grassBP.frequency.value=240; grassBP.Q.value=0.6;
    const grassGain = ctx.createGain(); grassGain.gain.value = 0.0;
    grassSrc.connect(grassBP); grassBP.connect(grassGain); grassGain.connect(master); grassSrc.start();

    function crash(impact){
      // Impact: low thump + metallic ping + noise burst
      const g = ctx.createGain(); g.gain.value = 0.0; g.connect(master);
      // thump
      const th = ctx.createOscillator(); th.type = 'sine'; th.frequency.setValueAtTime(90, ctx.currentTime);
      th.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.12);
      th.connect(g);
      // ping
      const pn = ctx.createOscillator(); pn.type = 'sine'; pn.frequency.setValueAtTime(1400, ctx.currentTime);
      pn.frequency.exponentialRampToValueAtTime(500, ctx.currentTime + 0.25);
      pn.connect(g);
      // burst noise
      const nb = makeNoise(); const nbBP = ctx.createBiquadFilter(); nbBP.type='bandpass'; nbBP.frequency.value=1800; nbBP.Q.value=1.0;
      const nbG = ctx.createGain(); nbG.gain.value = 0.0; nb.connect(nbBP); nbBP.connect(nbG); nbG.connect(master);
      // envelopes
      const a = Math.min(1, 0.15 + impact * 0.8);
      g.gain.linearRampToValueAtTime(a, ctx.currentTime + 0.005);
      g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
      nbG.gain.linearRampToValueAtTime(a*0.6, ctx.currentTime + 0.005);
      nbG.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
      th.start(); pn.start(); nb.start();
      th.stop(ctx.currentTime + 0.35); pn.stop(ctx.currentTime + 0.35); nb.stop(ctx.currentTime + 0.27);
    }

    SFX = { ctx, master, eng:{oscA,oscB,lp:engLP,g:engGain}, wind:{g:windGain}, skid:{g:skidGain}, grass:{g:grassGain}, crash };
    return SFX;
  } catch(e){ console.warn('Audio init failed:', e); return null; }
}

let sfxEnabled = true;
function toggleSFX(){ sfxEnabled = !sfxEnabled; if (SFX) SFX.master.gain.value = sfxEnabled ? 0.9 : 0.0; }
function updateSFX(player, dt){
  if (!sfxEnabled) return;
  const sfx = ensureAudio(); if (!sfx) return;
  const spd = Math.max(0, player.speed||0);
  const throttle = player.sfxThrottle || 0;
  const slip = Math.max(0, Math.min(1, player.sfxSlip || 0));
  const onGrass = !!player.sfxGrass;

  // Engine pitch from speed + throttle
  const rpm = 80 + spd * 0.9 + throttle * 40; // pseudo-rpm
  const fA = Math.max(40, rpm); const fB = fA/2;
  sfx.eng.oscA.frequency.setTargetAtTime(fA, sfx.ctx.currentTime, 0.02);
  sfx.eng.oscB.frequency.setTargetAtTime(fB, sfx.ctx.currentTime, 0.02);
  const engVol = Math.min(0.85, 0.15 + spd*0.002 + throttle*0.35);
  sfx.eng.g.gain.setTargetAtTime(engVol, sfx.ctx.currentTime, 0.04);
  sfx.eng.lp.frequency.setTargetAtTime(400 + spd*2 + throttle*500, sfx.ctx.currentTime, 0.05);

  // Wind
  const windVol = Math.min(0.5, spd*0.0025);
  sfx.wind.g.gain.setTargetAtTime(windVol, sfx.ctx.currentTime, 0.08);

  // Skid squeal (depends on slip; quieter on grass)
  const skidVol = (onGrass ? 0.25 : 1.0) * Math.max(0, (slip-0.15)) * 0.9;
  sfx.skid.g.gain.setTargetAtTime(skidVol, sfx.ctx.currentTime, 0.03);

  // Grass rumble
  const grassVol = onGrass ? Math.min(0.6, 0.1 + spd*0.002) : 0.0;
  sfx.grass.g.gain.setTargetAtTime(grassVol, sfx.ctx.currentTime, 0.05);

  // Impact one-shots
  if (player.sfxImpact && player.sfxImpact > 0.05){
    sfx.crash(Math.min(1, player.sfxImpact));
    player.sfxImpact = 0;
  }
}
const { useEffect, useRef, useState } = React;
      function getInitialTrack() {
        try {
          const params = new URLSearchParams(window.location.search);
          const raw = (params.get('track') || '').trim();
          if (!raw) return "Le Mans";
          if (/^custom:/i.test(raw)) return raw;
          const q = raw.toLowerCase();
          const map = { "le mans": "Le Mans", "lemans": "Le Mans", "silverstone": "Silverstone", "kart": "Kart Park", "kart park": "Kart Park", "kartpark": "Kart Park", "park": "Kart Park", "windey": "Windey", "windey clone": "Windey Clone", "windeyclone": "Windey Clone", "windey circuit": "Windey Circuit", "windeycircuit": "Windey Circuit", "night loop": "Night Loop", "nightloop": "Night Loop", "night": "Night Loop" };
          if (map[q]) return map[q];
          return q ? (q[0].toUpperCase() + q.slice(1)) : "Le Mans";
        } catch (e) { return "Le Mans"; }
      }
      const CarProfiles = {
        "F1":    { width: 18, length: 44, maxK: 1.18, accelK: 1.10, brakeK: 1.05, turnK: 1.20, color: "#d32f2f" },
        "GT":    { width: 20, length: 38, maxK: 1.00, accelK: 1.00, brakeK: 1.00, turnK: 1.00, color: "#3949ab" },
        "Rally": { width: 18, length: 34, maxK: 0.95, accelK: 1.05, brakeK: 1.05, turnK: 1.15, color: "#2e7d32" },
        "Truck": { width: 24, length: 46, maxK: 0.82, accelK: 0.85, brakeK: 0.90, turnK: 0.70, color: "#6d4c41" }
      };
      function getInitialCar() {
        try {
          const params = new URLSearchParams(window.location.search);
          const q = (params.get('car') || '').trim();
          return CarProfiles[q] ? q : "GT";
        } catch (e) { return "GT"; }
      }

      function getSteeringModeSetting() {
        try {
          const value = localStorage.getItem("steeringMode");
          return value === "touch" ? "touch" : "manual";
        } catch (_) {
          return "manual";
        }
      }

      const SCALE_MIN = 0.5;
      const SCALE_MAX = 3.0;
      const SCALE_STEP = 0.05;
      const SCALE_DEFAULT = 2.5;
      function clampScale(value) {
        return Math.min(SCALE_MAX, Math.max(SCALE_MIN, value));
      }
      function readScale(key, fallback) {
        try {
          const stored = localStorage.getItem(key);
          if (stored === null) return fallback;
          const parsed = parseFloat(stored);
          return Number.isFinite(parsed) ? parsed : fallback;
        } catch(_) {
          return fallback;
        }
      }
      function writeScale(key, value) {
        try { localStorage.setItem(key, String(value)); } catch(_) {}
      }
      let GEO_SCALE = clampScale(readScale('geoScale', SCALE_DEFAULT));
      let WIDTH_SCALE = clampScale(readScale('widthScale', SCALE_DEFAULT));


      function TopDownRacer() {
        const canvasRef = useRef(null);
        const trackMapRef = useRef(null);
        const [running, setRunning] = useState(true);
        const [status, setStatus] = useState("");
        const [trackName, setTrackName] = useState(getInitialTrack()); // default to Le Mans
  const [hudTip, setHudTip] = useState("");
        const [devPanelOpen, setDevPanelOpen] = useState(false);
        const [geoScaleInput, setGeoScaleInput] = useState(() => clampScale(GEO_SCALE));
        const [widthScaleInput, setWidthScaleInput] = useState(() => clampScale(WIDTH_SCALE));
  // motion steering analog value -1..1
  // Gyroscope removed: keyboard / touch only
  // camera state
  const camRef = useRef({ x: 0, y: 0, scale: 1.0, targetScale: 1.0 });
  const camInitRef = useRef(false);
        const loadTrackRef = useRef(() => {});
        useEffect(() => {
          if (!hudTip) return;
          const timer = setTimeout(() => setHudTip(""), 2600);
          return () => clearTimeout(timer);
        }, [hudTip]);
        function reloadTrack() {
          const loader = loadTrackRef.current;
          if (typeof loader === "function") {
            loader(trackName);
          }
        }
        function applyGeoScaleChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampScale(parsed);
          if (Math.abs(clamped - GEO_SCALE) < 1e-4) {
            setGeoScaleInput(clamped);
            return;
          }
          GEO_SCALE = clamped;
          setGeoScaleInput(clamped);
          writeScale("geoScale", clamped);
          reloadTrack();
        }
        function applyWidthScaleChange(nextValue) {
          const parsed = typeof nextValue === "number" ? nextValue : parseFloat(nextValue);
          if (!Number.isFinite(parsed)) return;
          const clamped = clampScale(parsed);
          if (Math.abs(clamped - WIDTH_SCALE) < 1e-4) {
            setWidthScaleInput(clamped);
            return;
          }
          WIDTH_SCALE = clamped;
          setWidthScaleInput(clamped);
          writeScale("widthScale", clamped);
          reloadTrack();
        }

        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");

          const BASE_WORLD_W = 1000, BASE_WORLD_H = 700;
          let W = BASE_WORLD_W, H = BASE_WORLD_H;
          canvas.width = W; canvas.height = H;

          const trackMap = document.createElement("canvas");
          trackMap.width = W; trackMap.height = H;
          trackMapRef.current = trackMap;
          const tctx = trackMap.getContext("2d");

          function adjustCanvasSize(){
            const { w, h } = getViewportSize();
            const baseW = W, baseH = H;
            let targetW = baseW, targetH = baseH;
            const aspect = baseW / baseH;
            const vpAspect = w / Math.max(h, 1);
            if (vpAspect > aspect){
              targetH = Math.min(h, baseH);
              const scale = targetH / baseH;
              targetW = baseW * scale;
            } else {
              targetW = Math.min(w, baseW);
              const scale = targetW / baseW;
              targetH = baseH * scale;
            }
            Object.assign(canvas.style, {
              width: targetW + 'px',
              height: targetH + 'px',
              position: 'fixed',
              left: '50%',
              top: '50%',
              transform: 'translate(-50%, -50%)'
            });
          }

          function applyWorldSize(width, height){
            const minW = 600;
            const minH = 420;
            W = Math.max(minW, Math.round(width || 1000));
            H = Math.max(minH, Math.round(height || 700));
            canvas.width = W;
            canvas.height = H;
            trackMap.width = W;
            trackMap.height = H;
            adjustCanvasSize();
          }

          const fsOnce = () => { requestFullscreen(document.documentElement); adjustCanvasSize(); window.removeEventListener('pointerdown', fsOnce); };
          window.addEventListener('pointerdown', fsOnce, { once:true });
          window.addEventListener('resize', adjustCanvasSize);
          if (window.visualViewport) window.visualViewport.addEventListener('resize', adjustCanvasSize);
          adjustCanvasSize();

          // ===== Track Library (centerline points in pixels) =====
          const Tracks = {
            Silverstone: {
              spawn: { player: { x: 750, y: 145, angle: Math.PI }, ai: { x: 730, y: 145, angle: Math.PI } },
              startLine: { a: { x: 760, y: 95 }, b: { x: 760, y: 165 } },
              points: [
                { x: 780, y: 130 }, { x: 700, y: 120 }, { x: 650, y: 125 }, { x: 610, y: 150 },
                { x: 560, y: 190 }, { x: 540, y: 230 }, { x: 520, y: 280 }, { x: 500, y: 330 },
                { x: 460, y: 360 }, { x: 380, y: 380 }, { x: 310, y: 370 }, { x: 265, y: 340 },
                { x: 250, y: 300 }, { x: 270, y: 260 }, { x: 320, y: 240 }, { x: 380, y: 240 },
                { x: 440, y: 230 }, { x: 500, y: 220 }, { x: 460, y: 180 }, { x: 420, y: 150 },
                { x: 360, y: 140 }, { x: 305, y: 150 }, { x: 260, y: 180 }, { x: 240, y: 220 },
                { x: 250, y: 260 }, { x: 300, y: 300 }, { x: 380, y: 330 }, { x: 480, y: 360 },
                { x: 580, y: 380 }, { x: 680, y: 380 }, { x: 720, y: 360 }, { x: 740, y: 320 },
                { x: 730, y: 280 }, { x: 700, y: 250 }, { x: 660, y: 240 }, { x: 620, y: 230 },
                { x: 600, y: 200 }, { x: 610, y: 160 }, { x: 650, y: 130 }, { x: 700, y: 120 },
                { x: 780, y: 130 }
              ],
              speedZones: [
                [0, 32, 220], [32, 40, 170], [40, 60, 280], [60, 80, 180], [80, 100, 160]
              ],
              labels: [
                ["Hamilton", 730, 85], ["Village", 520, 230], ["Wellington", 340, 400],
                ["Luffield", 280, 250], ["Copse", 390, 135], ["Maggots/Becketts", 255, 170],
                ["Hangar", 610, 400], ["Stowe", 720, 350], ["Club", 640, 220]
              ],
              roadWidth: 80
            },

            // Le Mans — Bugatti layout approximation (based on provided image)
            "Le Mans": {
              spawn: { player: { x: 700, y: 520, angle: Math.PI }, ai: { x: 680, y: 520, angle: Math.PI } },
              // Start/finish line across pit straight
              startLine: { a: { x: 660, y: 490 }, b: { x: 660, y: 550 } },
              points: [
                // Start on pit straight, heading left
                { x: 720, y: 520 }, { x: 680, y: 520 }, { x: 640, y: 520 }, { x: 600, y: 520 },
                { x: 560, y: 520 }, { x: 520, y: 515 }, { x: 470, y: 510 }, { x: 420, y: 500 },
                // T1-2 Raccordement chicane (right-left) near pits (at right end) – already passed; now towards Dunlop
                { x: 380, y: 490 }, { x: 350, y: 480 },
                // Slight climb to Dunlop chicane area
                { x: 320, y: 450 }, { x: 300, y: 420 }, { x: 290, y: 390 },
                // Dunlop chicane left-right crest then into Dunlop curve
                { x: 280, y: 350 }, { x: 300, y: 320 }, { x: 340, y: 300 },
                // Downhill to La Chapelle hairpin
                { x: 360, y: 330 }, { x: 380, y: 370 }, { x: 370, y: 420 }, { x: 350, y: 460 },
                { x: 330, y: 500 },
                // Musée right
                { x: 360, y: 520 }, { x: 400, y: 540 },
                // Garage Vert left-right
                { x: 450, y: 530 }, { x: 480, y: 500 }, { x: 500, y: 470 },
                // Back straight
                { x: 560, y: 450 }, { x: 620, y: 430 }, { x: 680, y: 420 }, { x: 740, y: 420 },
                // Chemin aux Boeufs (left-right-left chicane)
                { x: 720, y: 380 }, { x: 740, y: 340 }, { x: 770, y: 360 }, { x: 790, y: 390 },
                // S Bleus flowing rights along outside
                { x: 830, y: 420 }, { x: 880, y: 450 }, { x: 920, y: 490 },
                // Raccordement chicane to pits
                { x: 900, y: 520 }, { x: 850, y: 520 }, { x: 800, y: 520 }, { x: 760, y: 520 },
                { x: 720, y: 520 }
              ],
              // Target speeds (px/s) per path section; indices are approximate zones
              speedZones: [
                [0, 10, 280],    // pit straight
                [10, 18, 160],   // Dunlop chicane/curve
                [18, 26, 170],   // La Chapelle / Musée / Garage Vert
                [26, 30, 300],   // back straight
                [30, 36, 180],   // Chemin aux Boeufs
                [36, 41, 240],   // S Bleus to raccordement
                [41, 48, 220]    // final chicane to line
              ],
              labels: [
                ["Dunlop", 300, 345], ["La Chapelle", 320, 470], ["Musée", 390, 555],
                ["Garage Vert", 470, 520], ["Chemin aux Boeufs", 730, 350],
                ["S Bleus", 860, 420], ["Raccordement", 880, 510]
              ],
              roadWidth: 78
            },

            "Kart Park": {
              name: "Kart Park",
              ppm: 11,
              spawn: { player: { x: 220, y: 620, angle: 0 }, ai: { x: 200, y: 620, angle: 0 } },
              startLine: { a: { x: 250, y: 590 }, b: { x: 250, y: 650 } },
              points: [
                {x: 150,y: 620}, {x: 240,y: 620}, {x: 360,y: 620}, {x: 500,y: 620}, {x: 640,y: 620}, {x: 780,y: 620},
                {x: 860,y: 610}, {x: 910,y: 590}, {x: 940,y: 555}, {x: 952,y: 510}, {x: 955,y: 470},
                {x: 943,y: 430}, {x: 915,y: 400}, {x: 870,y: 380}, {x: 810,y: 370}, {x: 740,y: 368},
                {x: 675,y: 378}, {x: 620,y: 402}, {x: 585,y: 438}, {x: 570,y: 480}, {x: 575,y: 520},
                {x: 600,y: 555}, {x: 640,y: 580}, {x: 700,y: 592}, {x: 760,y: 588}, {x: 810,y: 570},
                {x: 840,y: 540}, {x: 835,y: 505}, {x: 800,y: 475}, {x: 750,y: 455}, {x: 690,y: 445},
                {x: 620,y: 438}, {x: 560,y: 432}, {x: 500,y: 426}, {x: 440,y: 424}, {x: 380,y: 428},
                {x: 330,y: 442}, {x: 285,y: 470}, {x: 250,y: 505}, {x: 230,y: 545}, {x: 225,y: 585},
                {x: 235,y: 610}, {x: 260,y: 625}, {x: 300,y: 632}, {x: 350,y: 630}, {x: 410,y: 625},
                {x: 470,y: 622}, {x: 520,y: 620}, {x: 640,y: 620}, {x: 780,y: 620}, {x: 860,y: 610},
                {x: 150,y: 620}
              ],
              speedZones: [
                [0, 8, 300], [8, 15, 150], [15, 23, 200], [23, 30, 170], [30, 40, 210], [40, 48, 260], [48, 60, 300]
              ],
              labels: [["Pits", 210, 570], ["Hairpin R", 940, 480], ["S-curve", 720, 380], ["Inner", 560, 510], ["Back straight", 700, 610]],
              roadWidth: 80,
              kerbs: true,
              kerbColors: ["#d94848", "#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle = "#2a2f36"; ctx.strokeStyle = "#3b4552"; ctx.lineWidth = 1.5;
                ctx.fillRect(110, 640, 240, 40); ctx.strokeRect(110, 640, 240, 40);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1; for(let i=0;i<8;i++){ const x=120+i*28; ctx.beginPath(); ctx.moveTo(x,642); ctx.lineTo(x,678); ctx.stroke(); }
                ctx.fillStyle = "#2a2f36"; ctx.fillRect(120, 460, 150, 80); ctx.strokeStyle="#3b4552"; ctx.strokeRect(120,460,150,80);
                ctx.fillStyle = "#1d4222"; for(let i=0;i<20;i++){ const x=40+i*48; ctx.beginPath(); ctx.arc(x, 40, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                ctx.restore();
              }
            },

            "Windey": {
              name: "Windey",
              ppm: 11,
              spawn: { player: { x: 260, y: 620, angle: 0 }, ai: { x: 240, y: 620, angle: 0 } },
              startLine: { a: { x: 250, y: 590 }, b: { x: 250, y: 650 } },
              points: [
                {x:140,y:618}, {x:220,y:620}, {x:300,y:622}, {x:380,y:626}, {x:460,y:628}, {x:540,y:628}, {x:620,y:626}, {x:700,y:624}, {x:780,y:622}, {x:860,y:616},
                {x:900,y:600}, {x:928,y:580}, {x:945,y:555}, {x:954,y:522}, {x:956,y:488}, {x:952,y:452}, {x:940,y:420}, {x:918,y:396}, {x:888,y:382}, {x:850,y:374},
                {x:806,y:372}, {x:760,y:374}, {x:710,y:384}, {x:668,y:404}, {x:634,y:432}, {x:612,y:468}, {x:606,y:506}, {x:614,y:544}, {x:640,y:573}, {x:680,y:592},
                {x:728,y:598}, {x:778,y:592}, {x:820,y:575}, {x:846,y:548}, {x:850,y:516}, {x:834,y:486}, {x:804,y:464}, {x:764,y:452}, {x:720,y:446}, {x:672,y:444},
                {x:626,y:444}, {x:578,y:442}, {x:530,y:438}, {x:482,y:432}, {x:438,y:428}, {x:394,y:430}, {x:352,y:438}, {x:314,y:456}, {x:283,y:482}, {x:260,y:514},
                {x:246,y:552}, {x:244,y:588}, {x:254,y:612}, {x:280,y:628}, {x:318,y:636}, {x:364,y:640}, {x:414,y:638}, {x:468,y:634}, {x:526,y:630}, {x:586,y:626},
                {x:650,y:624}, {x:720,y:624}, {x:800,y:622}, {x:880,y:616}, {x:920,y:602}, {x:140,y:618}
              ],
              speedZones: [
                [0, 10, 280],[10, 20, 140],[20, 30, 190],[30, 42, 170],[42, 52, 210],[52, 66, 260]
              ],
              labels: [["Pits", 210, 570], ["Hairpin", 930, 490], ["S sweep", 700, 420], ["Inner", 540, 520], ["Main straight", 600, 640]],
              roadWidth: 80,
              kerbs: true,
              kerbColors: ["#d94848", "#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle = "#2a2f36"; ctx.strokeStyle = "#3b4552"; ctx.lineWidth = 1.5;
                ctx.fillRect(80, 560, 260, 100); ctx.strokeRect(80, 560, 260, 100);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1; for(let i=0;i<8;i++){ const x=95+i*30; ctx.beginPath(); ctx.moveTo(x,565); ctx.lineTo(x,655); ctx.stroke(); }
                function car(x,y,a){ ctx.save(); ctx.translate(x,y); ctx.rotate(a||0); const w=20, l=44; ctx.fillStyle="#1b1f27"; ctx.fillRect(-w/2,-l/2,w,l); ctx.fillStyle="#eaeef5"; ctx.fillRect(-w*0.35,-l*0.35,w*0.70,l*0.22); ctx.restore(); }
                car(120,585,0); car(150,585,0); car(180,585,0); car(210,585,0);
                ctx.fillStyle="#303744"; ctx.fillRect(90, 500, 180, 50); ctx.strokeStyle="#475166"; ctx.strokeRect(90,500,180,50);
                ctx.fillStyle = "#3a3f47"; ctx.fillRect(180, 602, 420, 22);
                ctx.fillStyle = "#1d4222"; for(let i=0;i<22;i++){ const x=40+i*44; ctx.beginPath(); ctx.arc(x, 40, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                ctx.strokeStyle = "rgba(0,0,0,0.18)"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(760,470); ctx.quadraticCurveTo(700,500,660,560); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(930,520); ctx.quadraticCurveTo(900,470,850,440); ctx.stroke();
                ctx.restore();
              }
            },
            "Windey Clone": {
              name: "Windey Clone",
              ppm: 11,
              spawn: { player: { x: 210, y: 640, angle: 0 }, ai: { x: 190, y: 640, angle: 0 } },
              startLine: { a: { x: 235, y: 612 }, b: { x: 235, y: 668 } },
              points: [
                {x:140,y:646},{x:200,y:646},{x:260,y:646},{x:320,y:646},{x:380,y:646},{x:440,y:646},{x:500,y:646},{x:560,y:646},{x:620,y:646},{x:680,y:646},{x:740,y:644},{x:800,y:642},{x:860,y:636},{x:900,y:624},
                {x:930,y:600},{x:952,y:568},{x:962,y:530},{x:964,y:492},{x:960,y:456},{x:946,y:420},{x:920,y:396},
                {x:884,y:382},{x:842,y:372},{x:796,y:366},{x:748,y:364},{x:702,y:366},{x:656,y:374},{x:616,y:392},{x:584,y:418},{x:562,y:450},
                {x:556,y:486},{x:564,y:520},{x:588,y:550},{x:620,y:570},{x:662,y:582},{x:702,y:584},{x:736,y:578},{x:768,y:564},{x:790,y:544},{x:800,y:520},{x:796,y:494},{x:780,y:470},{x:754,y:454},{x:720,y:446},{x:682,y:444},{x:642,y:448},{x:604,y:458},{x:568,y:472},
                {x:532,y:492},{x:500,y:516},{x:476,y:546},{x:464,y:576},{x:464,y:606},{x:476,y:628},{x:504,y:640},{x:542,y:646},{x:586,y:648},{x:632,y:648},{x:680,y:648},{x:728,y:646},{x:776,y:642},{x:824,y:638},{x:872,y:634},{x:900,y:626},
                {x:820,y:642},{x:760,y:646},{x:700,y:648},{x:640,y:648},{x:580,y:648},{x:520,y:648},{x:460,y:648},{x:400,y:648},{x:340,y:648},{x:280,y:648},{x:220,y:648},{x:160,y:648},{x:140,y:646}
              ],
              speedZones: [ [0,14,300],[14,22,140],[22,31,200],[31,46,180],[46,60,220] ],
              labels: [["Pits", 210, 600],["Hairpin", 950, 490],["S sweep", 700, 370],["Inner", 600, 530],["Main straight", 520, 660]],
              roadWidth: 80,
              kerbs: true,
              kerbColors: ["#d94848","#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle="#b7bcc4"; ctx.fillRect(60, 510, 300, 170); ctx.strokeStyle="#3b4552"; ctx.lineWidth=1.5; ctx.strokeRect(60,510,300,170);
                ctx.fillStyle="#2f3540"; ctx.fillRect(120, 520, 220, 40); ctx.strokeStyle="#475166"; ctx.strokeRect(120,520,220,40);
                ctx.strokeStyle="#9aa5b1"; ctx.lineWidth=1; for(let i=0;i<10;i++){ const gx=190+i*32; ctx.beginPath(); ctx.moveTo(gx,632); ctx.lineTo(gx,664); ctx.stroke(); }
                ctx.fillStyle="#1d4222"; for(let i=0;i<22;i++){ const x=40+i*44; ctx.beginPath(); ctx.arc(x, 36, 10+((i%3)*2), 0, Math.PI*2); ctx.fill(); }
                function car(x,y,a){ ctx.save(); ctx.translate(x,y); ctx.rotate(a||0); const w=20,l=44; ctx.fillStyle="#1b1f27"; ctx.fillRect(-w/2,-l/2,w,l); ctx.fillStyle="#eaeef5"; ctx.fillRect(-w*0.35,-l*0.35,w*0.7,l*0.22); ctx.restore(); }
                car(100,560,0); car(130,560,0); car(160,560,0); car(190,560,0); car(220,560,0);
                ctx.strokeStyle="rgba(255,255,255,0.07)"; ctx.lineWidth=1; for(let i=0;i<6;i++){ ctx.beginPath(); ctx.moveTo(520+i*24, 460); ctx.lineTo(720+i*24, 600); ctx.stroke(); }
                ctx.strokeStyle="rgba(0,0,0,0.18)"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(945,520); ctx.quadraticCurveTo(900,460,850,430); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(760,470); ctx.quadraticCurveTo(700,510,660,560); ctx.stroke();
                ctx.restore();
              }
            },

            "Windey Circuit": {
              name: "Windey Circuit",
              ppm: 11,
              spawn: { player: { x: 250, y: 640, angle: 0 }, ai: { x: 230, y: 640, angle: 0 } },
              startLine: { a: { x: 240, y: 608 }, b: { x: 240, y: 664 } },
              points: [
                {x:210,y:642},{x:260,y:650},{x:320,y:656},{x:380,y:660},{x:440,y:662},{x:500,y:664},{x:560,y:662},{x:620,y:656},{x:680,y:646},{x:740,y:632},{x:800,y:612},{x:860,y:586},{x:902,y:556},{x:932,y:522},{x:950,y:484},{x:954,y:444},{x:942,y:404},{x:916,y:368},{x:878,y:342},{x:832,y:328},{x:780,y:322},{x:724,y:324},{x:670,y:332},{x:620,y:348},{x:578,y:370},{x:542,y:398},{x:514,y:432},{x:498,y:470},{x:494,y:510},{x:504,y:548},{x:528,y:584},{x:564,y:612},{x:608,y:628},{x:656,y:634},{x:704,y:632},{x:750,y:622},{x:792,y:604},{x:820,y:580},{x:832,y:548},{x:826,y:516},{x:806,y:488},{x:774,y:468},{x:732,y:456},{x:688,y:452},{x:642,y:456},{x:598,y:468},{x:560,y:486},{x:528,y:512},{x:502,y:544},{x:488,y:580},{x:486,y:620},{x:498,y:656},{x:522,y:686},{x:556,y:706},{x:600,y:714},{x:648,y:712},{x:694,y:700},{x:736,y:680},{x:772,y:652},{x:796,y:620},{x:804,y:584},{x:796,y:552},{x:772,y:524},{x:736,y:506},{x:692,y:498},{x:646,y:500},{x:602,y:510},{x:562,y:530},{x:528,y:558},{x:502,y:592},{x:486,y:630},{x:474,y:662},{x:452,y:680},{x:416,y:686},{x:372,y:682},{x:324,y:670},{x:276,y:654},{x:232,y:642}
              ],
              speedZones: [ [0,12,300],[12,20,150],[20,30,190],[30,46,200],[46,66,230] ],
              labels: [["Pits", 220, 602],["Hairpin", 948, 500],["North Sweep", 720, 336],["Inner Loop", 600, 540],["Main Straight", 540, 676]],
              roadWidth: 82,
              kerbs: true,
              kerbColors: ["#d94848","#ffffff"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle = "#bfc5cc";
                ctx.fillRect(60, 508, 300, 174);
                ctx.strokeStyle = "#8f96a5"; ctx.lineWidth = 1.4; ctx.strokeRect(60, 508, 300, 174);

                ctx.fillStyle = "#2f3540"; ctx.fillRect(118, 520, 232, 38);
                ctx.strokeStyle = "#475166"; ctx.strokeRect(118, 520, 232, 38);
                ctx.fillStyle = "#dcd6c8"; ctx.fillRect(120, 562, 74, 18);

                ctx.fillStyle = "#3a3f33"; ctx.fillRect(72, 598, 86, 72);
                ctx.fillStyle = "#d2c59a"; ctx.fillRect(86, 606, 58, 34);

                ctx.fillStyle = "#3f434a"; ctx.fillRect(200, 628, 420, 20);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1;
                for (let i = 0; i < 11; i++) {
                  const gx = 210 + i * 36;
                  ctx.beginPath(); ctx.moveTo(gx, 624); ctx.lineTo(gx, 666); ctx.stroke();
                }

                ctx.fillStyle = "#1c3f1f";
                for (let i = 0; i < 24; i++) {
                  const x = 40 + i * 42;
                  ctx.beginPath(); ctx.arc(x, 34 + (i % 2) * 2, 10 + (i % 3), 0, Math.PI * 2); ctx.fill();
                }

                ctx.fillStyle = "rgba(180,190,120,0.4)";
                ctx.beginPath(); ctx.moveTo(520, 428); ctx.lineTo(700, 612); ctx.lineTo(540, 624); ctx.lineTo(500, 500); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                  ctx.beginPath(); ctx.moveTo(540 + i * 26, 420); ctx.lineTo(700 + i * 18, 610); ctx.stroke();
                }

                function car(x, y, angle) {
                  ctx.save();
                  ctx.translate(x, y); ctx.rotate(angle || 0);
                  const w = 20, l = 44;
                  ctx.fillStyle = "#1a1f27"; ctx.fillRect(-w / 2, -l / 2, w, l);
                  ctx.fillStyle = "#e8edf4"; ctx.fillRect(-w * 0.35, -l * 0.35, w * 0.7, l * 0.22);
                  ctx.restore();
                }
                for (let i = 0; i < 7; i++) car(110 + i * 32, 560, 0);
                car(98, 612, -0.05); car(138, 614, 0.02);

                ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(944, 520); ctx.quadraticCurveTo(900, 460, 838, 430); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(780, 480); ctx.quadraticCurveTo(720, 520, 660, 570); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(600, 612); ctx.quadraticCurveTo(560, 592, 520, 552); ctx.stroke();

                ctx.restore();
              }
            },

            "Night Loop": {
              name: "Night Loop",
              ppm: 12.5,
              spawn: { player: { x: 260, y: 640, angle: 0 }, ai: { x: 240, y: 640, angle: 0 } },
              startLine: { a: { x: 250, y: 604 }, b: { x: 250, y: 664 } },
              points: [
                {x:150,y:640},{x:220,y:652},{x:300,y:658},{x:380,y:660},{x:460,y:658},{x:540,y:652},{x:620,y:640},{x:690,y:618},{x:740,y:582},{x:780,y:536},{x:810,y:486},{x:830,y:430},{x:840,y:370},{x:832,y:320},{x:800,y:280},{x:750,y:258},{x:690,y:260},{x:640,y:286},{x:600,y:326},{x:560,y:366},{x:510,y:396},{x:460,y:402},{x:410,y:382},{x:360,y:350},{x:312,y:320},{x:268,y:310},{x:230,y:328},{x:206,y:364},{x:190,y:412},{x:182,y:468},{x:184,y:530},{x:198,y:586},{x:224,y:618},{x:260,y:632},{x:310,y:640}
              ],
              speedZones: [ [0,8,300],[8,16,220],[16,22,180],[22,28,200],[28,35,240] ],
              labels: [["Pit Entry", 240, 608],["North Rim", 805, 300],["Esses", 600, 340],["Carousel", 450, 392],["Night Straight", 500, 648]],
              roadWidth: 116,
              kerbs: true,
              kerbColors: ["#ff6b6b", "#f4f1de"],
              drawScenery: function(ctx){
                ctx.save();
                ctx.fillStyle = "#04070d";
                ctx.fillRect(0,0,1000,700);
                ctx.strokeStyle = "rgba(40,60,120,0.25)";
                ctx.lineWidth = 220;
                ctx.lineJoin = "round";
                ctx.beginPath();
                for (let i=0;i<centerline.length;i++){ const p=centerline[i]; if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = "#2a2e39";
                ctx.fillRect(200, 622, 420, 26);
                ctx.strokeStyle = "#9aa5b1"; ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                  const x = 210 + i * 34;
                  ctx.beginPath(); ctx.moveTo(x, 620); ctx.lineTo(x, 650); ctx.stroke();
                }

                ctx.save();
                ctx.strokeStyle = "rgba(255,255,255,0.18)"; ctx.lineWidth = 8; ctx.setLineDash([16,12]);
                ctx.beginPath();
                for (let i=0;i<centerline.length;i++){ const p=centerline[i]; if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();

                ctx.fillStyle = "rgba(255,214,120,0.35)";
                const lights=[[195,630],[230,645],[320,658],[410,656],[500,650],[585,640],[660,622],[712,590],[752,548],[790,498],[812,440],[820,380],[804,330],[760,300],[706,296],[640,315],[590,356],[540,396],[480,410],[420,390],[360,350],[300,320],[240,330],[206,380],[196,440],[198,512],[212,570],[240,606]];
                for (const [x,y] of lights){ ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill(); }

                ctx.restore();
              }
            }
          };

          // ====== State that depends on the active track ======
          let ROAD_WIDTH = 80 * WIDTH_SCALE;
          let centerline = [];
          let startLine = null;
          let waypoints = [];
          let labels = [];
          const customTrackCache = new Map();
          const customTrackPromises = new Map();
          let trackData = null;
          let activeTrack = null; // keep current track config
          let trackBounds = null; // world-space bbox
          let checkpoints = [];   // [{a:{x,y}, b:{x,y}}]

          // Cars and sim state
          function makeCar({ x, y, angle, color, kind = 'GT', steeringMode }) {
            const prof = CarProfiles[kind] || CarProfiles.GT;
            const width = prof.width, length = prof.length;
            const stats = { maxK: prof.maxK, accelK: prof.accelK, brakeK: prof.brakeK, turnK: prof.turnK };
            if (!color) color = prof.color;
            const mode = steeringMode === "touch" ? "touch" : "manual";
            const car = { x, y, angle, speed: 0, width, length, color, kind, stats,
                          lap: 0, lastCross: 0, bestLap: null, lapStart: performance.now(),
                          vx: 0, vy: 0, targetIndex: 0, speedBias: 0,
                          steerVis: 0, skidLPrev: null, skidRPrev: null, steeringMode: mode };
            try { if (window.RacerPhysics) window.RacerPhysics.initCar(car, kind); } catch(_){}
            return car;
          }
          const steeringModePreference = getSteeringModeSetting();
          const player = makeCar({ x: 0, y: 0, angle: 0, color: "#e53935", kind: getInitialCar(), steeringMode: steeringModePreference });
          let aiCars = []; // array of AI cars

          const keys = { w: false, s: false, a: false, d: false };

          // Normalized handling constants for mobile parity
          const MAX_SPEED_ROAD = 340, MAX_SPEED_GRASS = 135; // reduced from boosted values
          const ACCEL = 480, BRAKE = 400; // softer accel/brake
            const FRICTION_ROAD = 0.985, FRICTION_GRASS = 0.93; // slightly more damping
          const TURN_RATE = 3.4; // reduced steering rate

          function interpolate(points, step = 6) {
            const pts = [];
            for (let i = 0; i < points.length - 1; i++) {
              const a = points[i], b = points[i + 1];
              const dx = b.x - a.x, dy = b.y - a.y;
              const dist = Math.hypot(dx, dy);
              const n = Math.max(1, Math.floor(dist / step));
              for (let j = 0; j < n; j++) {
                const t = j / n;
                pts.push({ x: a.x + dx * t, y: a.y + dy * t });
              }
            }
            return pts;
          }

          function buildWaypoints(centerline, zones) {
            const pts = [];
            for (let i = 0; i < centerline.length; i += 24) {
              const pt = centerline[i];
              // default
              let speed = 240;
              for (const [a,b,s] of zones) {
                if (i/24 >= a && i/24 < b) { speed = s; break; }
              }
              pts.push({ x: pt.x, y: pt.y, speed });
            }
            return pts;
          }

          function scalePoint(p, cx, cy, scale) {
            return { x: cx + (p.x - cx) * scale, y: cy + (p.y - cy) * scale };
          }

          function bbox(pts){
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            for (const p of pts){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
            return {minX, minY, maxX, maxY, w:maxX-minX, h:maxY-minY};
          }

          function clamp(value, min, max){
            return Math.min(max, Math.max(min, value));
          }

          function convertCustomEntry(entry){
            if (!entry || !entry.data) throw new Error("Track bundle missing data");
            const data = entry.data;
            const rawPoints = Array.isArray(data.points) ? data.points : [];
            const points = rawPoints.map((p) => ({ x: Number(p && p.x) || 0, y: Number(p && p.y) || 0 }));
            const worldSrc = data.world || {};
            const world = {
              width: Number(worldSrc.width) || 1000,
              height: Number(worldSrc.height) || 700,
              scale: Number(worldSrc.scale) || undefined
            };
            const name = data.name || entry.name || "Custom Track";
            const speedZones = Array.isArray(data.speedZones) && data.speedZones.length ? data.speedZones : [[0, Math.max(1, Math.floor(points.length / 24) || 1), 220]];
            const labels = Array.isArray(data.labels) && data.labels.length ? data.labels : [[name, world.width * 0.5, world.height * 0.5]];
            const fallbackA = points[0] || { x: world.width * 0.5, y: world.height * 0.5 };
            const fallbackB = points[1] || { x: fallbackA.x + 40, y: fallbackA.y };
            const clonePoint = (src, fallback) => ({
              x: Number(src && src.x) || fallback.x || 0,
              y: Number(src && src.y) || fallback.y || 0,
              angle: typeof (src && src.angle) === "number" ? src.angle : undefined
            });
            const startA = clonePoint(data.startLine && data.startLine.a, fallbackA);
            const startB = clonePoint(data.startLine && data.startLine.b, fallbackB);
            const defaultAngle = Math.atan2((startB.y || 0) - (startA.y || 0), (startB.x || 0) - (startA.x || 0));
            const spawnPlayerSrc = data.spawn && data.spawn.player;
            const spawnAiSrc = data.spawn && data.spawn.ai;
            const spawnPlayer = {
              x: Number(spawnPlayerSrc && spawnPlayerSrc.x) || startA.x,
              y: Number(spawnPlayerSrc && spawnPlayerSrc.y) || startA.y,
              angle: typeof (spawnPlayerSrc && spawnPlayerSrc.angle) === "number" ? spawnPlayerSrc.angle : defaultAngle
            };
            const spawnAi = {
              x: Number(spawnAiSrc && spawnAiSrc.x) || (spawnPlayer.x - Math.cos(defaultAngle) * 40),
              y: Number(spawnAiSrc && spawnAiSrc.y) || (spawnPlayer.y - Math.sin(defaultAngle) * 40),
              angle: typeof (spawnAiSrc && spawnAiSrc.angle) === "number" ? spawnAiSrc.angle : defaultAngle
            };
            return {
              name,
              points,
              startLine: { a: startA, b: startB },
              spawn: { player: spawnPlayer, ai: spawnAi },
              roadWidth: data.roadWidth || 80,
              world,
              mask: data.mask || entry.mask || null,
              speedZones,
              labels,
              source: { id: entry.id, createdAt: entry.createdAt, updatedAt: entry.updatedAt, origin: data.origin || entry.origin || "sketcher" },
              origin: data.origin || "sketcher",
              isCustom: true
            };
          }

          async function ensureCustomTrack(name){
            if (!name || !/^custom:/i.test(name)) return null;
            if (Tracks[name]) return Tracks[name];
            if (customTrackCache.has(name)) {
              const cached = customTrackCache.get(name);
              if (cached && typeof cached.then !== "function") return cached;
            }
            if (customTrackPromises.has(name)) {
              return customTrackPromises.get(name);
            }
            if (!window.TrackStore || typeof TrackStore.getTrack !== "function") {
              throw new Error("Track storage unavailable");
            }
            const id = name.slice(7);
            if (!id) throw new Error("Custom track id missing");
            const promise = TrackStore.getTrack(id).then((entry) => {
              if (!entry) throw new Error("Custom track not found");
              const track = convertCustomEntry(entry);
              Tracks[name] = track;
              customTrackCache.set(name, track);
              customTrackPromises.delete(name);
              return track;
            }).catch((err) => {
              customTrackPromises.delete(name);
              customTrackCache.delete(name);
              throw err;
            });
            customTrackPromises.set(name, promise);
            return promise;
          }

          function drawTrackMask() {
            tctx.save();
            tctx.clearRect(0, 0, W, H);
            tctx.fillStyle = "black";
            tctx.fillRect(0, 0, W, H);
            tctx.lineJoin = "round";
            tctx.lineCap = "round";
            tctx.strokeStyle = "white";
            tctx.lineWidth = ROAD_WIDTH;
            tctx.beginPath();
            for (let i = 0; i < centerline.length; i++) {
              const pt = centerline[i];
              if (i === 0) tctx.moveTo(pt.x, pt.y); else tctx.lineTo(pt.x, pt.y);
            }
            tctx.stroke();
            tctx.restore();

            trackData = tctx.getImageData(0, 0, W, H).data;
          }

          function onRoad(x, y) {
            const ix = (Math.floor(y) * W + Math.floor(x)) * 4;
            return trackData && trackData[ix] > 200;
          }

          function ccw(A, B, C) { return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x); }
          function segIntersect(A, B, C, D) { return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D); }
          function loopIndex(i, len) { return ((i % len) + len) % len; }
          function normalizeAngle(a) { while (a > Math.PI) a -= Math.PI * 2; while (a < -Math.PI) a += Math.PI * 2; return a; }

          function carCorners(car) {
            const { x, y, angle, length, width } = car;
            const hl = length / 2, hw = width / 2;
            const pts = [ { x: hl, y: -hw }, { x: hl, y: hw }, { x: -hl, y: hw }, { x: -hl, y: -hw } ];
            const s = Math.sin(angle), c = Math.cos(angle);
            return pts.map((p) => ({ x: x + p.x * c - p.y * s, y: y + p.x * s + p.y * c }));
          }


          // Get the tangent heading of the centerline nearest to (x,y)
          function headingAtNearest(x, y) {
            if (!centerline || centerline.length < 2) return 0;
            let bestI = 0, bestD2 = Infinity;
            for (let i = 0; i < centerline.length - 1; i++) {
              const a = centerline[i], b = centerline[i + 1];
              // distance from point to segment (approx)
              const abx = b.x - a.x, aby = b.y - a.y;
              const apx = x - a.x, apy = y - a.y;
              const ab2 = abx*abx + aby*aby || 1;
              let t = (apx*abx + apy*aby) / ab2; t = Math.max(0, Math.min(1, t));
              const qx = a.x + abx*t, qy = a.y + aby*t;
              const dx = x - qx, dy = y - qy;
              const d2 = dx*dx + dy*dy;
              if (d2 < bestD2) { bestD2 = d2; bestI = i; }
            }
            const a = centerline[bestI], b = centerline[bestI + 1];
            return Math.atan2(b.y - a.y, b.x - a.x);
          }

          // ===== Track switcher =====
          function loadTrack(name) {
            GEO_SCALE = clampScale(GEO_SCALE);
            WIDTH_SCALE = clampScale(WIDTH_SCALE);
            let T = Tracks[name];
            if (!T) {
              if (name && /^custom:/i.test(name)) {
                setStatus("Loading custom track\u2026");
                ensureCustomTrack(name).then(() => {
                  setStatus("");
                  loadTrack(name);
                }).catch((err) => {
                  console.error("Custom track load failed", err);
                  setStatus("Custom track unavailable");
                });
              } else {
                console.error("Track not found:", name);
                setStatus("Track data missing");
              }
              return;
            }
            const displayName = T.name || name;
            const isCustomTrack = !!(T.isCustom || (T.origin && T.origin === "sketcher") || /^custom:/i.test(name));
            const baseWorldWidth = (T.world && T.world.width) || BASE_WORLD_W;
            const baseWorldHeight = (T.world && T.world.height) || BASE_WORLD_H;
            if (isCustomTrack) {
              applyWorldSize(baseWorldWidth * GEO_SCALE, baseWorldHeight * GEO_SCALE);
            } else {
              applyWorldSize(BASE_WORLD_W * GEO_SCALE, BASE_WORLD_H * GEO_SCALE);
            }
            activeTrack = { ...T, name: displayName, key: name, world: { width: W, height: H }, isCustom: isCustomTrack };

            const baseCx = baseWorldWidth / 2;
            const baseCy = baseWorldHeight / 2;
            const scaledPoints = T.points.map((p) => scalePoint(p, baseCx, baseCy, GEO_SCALE));
            const bb = bbox(scaledPoints);
            const dx = ((W - bb.w) / 2) - bb.minX;
            const dy = ((H - bb.h) / 2) - bb.minY;
            const transformPoint = (p) => {
              const src = p || { x: baseCx, y: baseCy };
              const scaled = scalePoint(src, baseCx, baseCy, GEO_SCALE);
              return { x: scaled.x + dx, y: scaled.y + dy };
            };
            const transformPose = (pose) => {
              const src = pose || { x: baseCx, y: baseCy, angle: 0 };
              const pt = transformPoint(src);
              return { x: pt.x, y: pt.y, angle: typeof src.angle === "number" ? src.angle : 0 };
            };

            centerline = interpolate(T.points.map(transformPoint), 6);
            const startSrc = T.startLine || { a: T.points[0], b: T.points[1] || T.points[0] };
            startLine = { a: transformPoint(startSrc.a), b: transformPoint(startSrc.b) };
            ROAD_WIDTH = (T.roadWidth || 80) * WIDTH_SCALE;
            labels = (T.labels || []).map(([text, x, y]) => {
              const pt = transformPoint({ x, y });
              return [text, pt.x, pt.y];
            });
            const rawPlayer = T.spawn && T.spawn.player ? T.spawn.player : startSrc.a;
            const rawAi = T.spawn && T.spawn.ai ? T.spawn.ai : rawPlayer;
            const playerSpawn = transformPose(rawPlayer);
            const aiSpawn = transformPose(rawAi);

            drawTrackMask();
            const zones = Array.isArray(T.speedZones) && T.speedZones.length ? T.speedZones : [[0, Math.max(1, Math.floor(centerline.length / 24)), 220]];
            waypoints = buildWaypoints(centerline, zones);
            trackBounds = bbox(centerline);
            checkpoints = [];
            const K = 12;
            for (let i=0;i<K;i++){
              const idx = Math.floor(i * Math.max(1, centerline.length-2) / K);
              const a = centerline[idx];
              const b = centerline[(idx+1) % centerline.length];
              const ang = Math.atan2(b.y-a.y, b.x-a.x);
              const nx = -Math.sin(ang), ny = Math.cos(ang);
              const half = ROAD_WIDTH*0.5;
              checkpoints.push({ a:{x:a.x+nx*half, y:a.y+ny*half}, b:{x:a.x-nx*half, y:a.y-ny*half} });
            }

            const fallbackPose = { x: W / 2, y: H / 2, angle: 0 };
            const pSpawn = playerSpawn || fallbackPose;
            Object.assign(player, { ...player, ...pSpawn, speed: 0, lap: 0, bestLap: null, lapStart: performance.now(), lastCross: 0, vx: 0, vy: 0, targetIndex: 0 });
            player.angle = headingAtNearest(player.x, player.y);
            const base = aiSpawn || pSpawn;
            const baseAngle = typeof rawAi.angle === "number" ? rawAi.angle : base.angle;
            aiCars = buildAICars(9, base, baseAngle);

            const prettyName = activeTrack && activeTrack.name ? activeTrack.name : name;
            try {
              const cam = camRef.current; 
              if (cam) { 
                cam.x = player.x;
                cam.y = player.y;
                cam.targetX = player.x;
                cam.targetY = player.y;
                cam.scale = cam.targetScale = 1.0;
              }
            } catch(_){}

            setStatus("");
            if (isCustomTrack) {
              setHudTip(`${prettyName} loaded (custom)`);
            } else {
              setHudTip(`${prettyName} loaded (geo x${GEO_SCALE.toFixed(2)}, width x${WIDTH_SCALE.toFixed(2)})`);
            }
          }
          loadTrackRef.current = loadTrack;

          // Build n AI cars in a staggered grid behind base position, aligned to angle
          function buildAICars(n, base, angleRad) {
            const arr = [];
            const v = { x: Math.cos(angleRad), y: Math.sin(angleRad) };
            const vp = { x: -v.y, y: v.x }; // left perp
            const gap = 38;       // gap along forward axis
            const lateral = 18;   // side column spacing
            const colors = ["#1e88e5","#43a047","#f4511e","#8e24aa","#00897b","#3949ab","#fdd835","#6d4c41","#00acc1","#c0ca33"];
            const kinds = Object.keys(CarProfiles);
            for (let i = 0; i < n; i++) {
              const row = Math.floor(i/2) + 1;
              const side = (i%2===0 ? -1 : 1);
              const x = base.x - v.x * gap * row + vp.x * lateral * side;
              const y = base.y - v.y * gap * row + vp.y * lateral * side;
              const kind = kinds[i % kinds.length];
              const car = makeCar({ x, y, angle: angleRad, color: colors[i % colors.length], kind, steeringMode: "manual" });
              car.targetIndex = 0;
              car.speedBias = (-20 + (i%5)*10); // small variety in target speed
              arr.push(car);
            }
            return arr;
          }

          // ===== Rendering =====
          
// ===== Car rendering (detailed) =====
// ===== Car rendering (per-vehicle models) =====
// ===== Car rendering (distinct per-vehicle models) =====
function drawCarDetailed(ctx, car){
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle + Math.PI/2); // align nose with +X physics

  const L = car.length, W = car.width;
  const steerAngle = (car.steerVis || 0) * 0.45;

  // Helpers
  function roundRectLocal(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }
  function poly(points){ ctx.beginPath(); ctx.moveTo(points[0][0], points[0][1]); for(let i=1;i<points.length;i++) ctx.lineTo(points[i][0], points[i][1]); ctx.closePath(); }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); }
  function gradBody(col){
    const g = ctx.createLinearGradient(0, -L/2, 0, L/2);
    g.addColorStop(0, '#eef1f5');
    g.addColorStop(0.45, col || (car.color || '#c23'));
    g.addColorStop(1, '#1a1f26');
    return g;
  }
  function wheel(x,y,a,ww,ll){
    ctx.save(); ctx.translate(x,y); ctx.rotate(a);
    ctx.fillStyle = '#131820'; roundRectLocal(-ww/2,-ll/2,ww,ll,2); ctx.fill();
    ctx.globalAlpha = .2; ctx.fillStyle = '#2a323d'; roundRectLocal(-ww/2+1.2,-ll/2+1.0,ww-2.4,ll-2.0,2); ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Shadow (stronger differentiation for silhouettes)
  ctx.save();
  ctx.globalAlpha = 0.28;
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(0, 3, W*0.8, L*0.65, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // Common lights (head/tail intensity from speed)
  function drawLights(){
    const accelGlow = Math.min(0.55, 0.18 + Math.max(0, car.speed)*0.0008);
    const brakeGlow = Math.min(0.85, 0.28 + Math.max(0, -car.speed)*0.0012);
    // Headlights (front)
    ctx.save(); ctx.globalAlpha = accelGlow; ctx.fillStyle = '#ffe69b';
    roundRectLocal(-W*0.36, -L*0.50, W*0.26, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.10, -L*0.50, W*0.26, L*0.04, 2); ctx.fill();
    ctx.restore();
    // Taillights (rear)
    ctx.save(); ctx.globalAlpha = brakeGlow; ctx.fillStyle = '#ff3b3b';
    roundRectLocal(-W*0.34,  L*0.46, W*0.24, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.10,  L*0.46, W*0.24, L*0.04, 2); ctx.fill();
    ctx.restore();
  }

  // === Distinct models ===
  function drawGT(){
    // Wide, low silhouette with big rear wing and twin stripes
    ctx.fillStyle = gradBody(car.color || '#f59e0b'); // warm GT tone by default
    roundRectLocal(-W/2, -L/2, W, L, Math.min(W,L)*0.22); ctx.fill();
    // canopy
    ctx.fillStyle = 'rgba(15,20,28,0.92)';
    roundRectLocal(-W*0.36, -L*0.18, W*0.72, L*0.34, 6); ctx.fill();
    // rear wing pylons + plane
    ctx.fillStyle = 'rgba(220,225,232,0.95)';
    roundRectLocal(-W*0.08, L*0.34, W*0.16, L*0.12, 2); ctx.fill();
    roundRectLocal(-W*0.50, L*0.40, W, L*0.06, 3); ctx.fill();
    // twin stripes
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRectLocal(-W*0.13, -L*0.48, W*0.06, L*0.96, 2); ctx.fill();
    roundRectLocal( W*0.07, -L*0.48, W*0.06, L*0.96, 2); ctx.fill();
    // side intakes (triangles)
    ctx.fillStyle = 'rgba(20,24,30,0.70)';
    poly([[-W*0.52, -L*0.08],[-W*0.32,0],[ -W*0.52, L*0.06 ]]); ctx.fill();
    poly([[ W*0.52, -L*0.08],[ W*0.32,0],[  W*0.52, L*0.06 ]]); ctx.fill();

    // wheels (tucked, performance)
    const axY=L*0.30, t=W*0.38, ww=Math.max(3,W*0.24), ll=Math.max(6,L*0.22);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    drawLights();
  }

  function drawRally(){
    // Short hatch with flares, roof scoop, light pod, spare
    ctx.fillStyle = gradBody(car.color || '#2563eb'); // rally blue default
    roundRectLocal(-W/2, -L/2, W, L*0.95, Math.min(W,L)*0.20); ctx.fill();
    // wheel arch flares (outside body)
    ctx.fillStyle = 'rgba(22,28,35,0.95)';
    roundRectLocal(-W*0.60, -L*0.34, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal( W*0.44, -L*0.34, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal(-W*0.60,  L*0.16, W*0.16, L*0.18, 4); ctx.fill();
    roundRectLocal( W*0.44,  L*0.16, W*0.16, L*0.18, 4); ctx.fill();
    // roof scoop
    ctx.fillStyle = 'rgba(235,238,242,0.85)';
    roundRectLocal(-W*0.18, -L*0.10, W*0.36, L*0.08, 3); ctx.fill();
    // light pod (4 circles)
    ctx.fillStyle = '#eaeef4';
    const ly=-L*0.35, lr=W*0.055;
    circle(-W*0.16, ly, lr); ctx.fill();
    circle(-W*0.05, ly, lr); ctx.fill();
    circle( W*0.06, ly, lr); ctx.fill();
    circle( W*0.17, ly, lr); ctx.fill();
    // spare wheel on roof
    ctx.fillStyle='rgba(40,45,54,0.9)'; circle(0, -L*0.02, W*0.12); ctx.fill();
    ctx.fillStyle='rgba(220,224,230,0.45)'; circle(0, -L*0.02, W*0.07); ctx.fill();
    // rally number circle on door (player only to reduce clutter)
    if (typeof player!=='undefined' && car===player){
      ctx.fillStyle='rgba(255,255,255,0.95)'; circle(-W*0.30, 0, W*0.16); ctx.fill();
      ctx.fillStyle='#111'; ctx.font = `${Math.max(10, W*0.22)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('01', -W*0.30, 0);
    }
    // wheels (chunky)
    const axY=L*0.30, t=W*0.42, ww=Math.max(5,W*0.30), ll=Math.max(8,L*0.24);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    drawLights();
  }

  function drawF1(){
    // Very narrow monocoque, open wheels far outside body, large wings
    const bodyW = Math.max(6, W*0.36);
    // center body
    ctx.fillStyle = gradBody(car.color || '#ef4444'); // F1 red default
    roundRectLocal(-bodyW/2, -L*0.45, bodyW, L*0.90, Math.min(bodyW,L)*0.22); ctx.fill();
    // cockpit/halo
    ctx.fillStyle = 'rgba(22,26,32,0.95)';
    roundRectLocal(-bodyW*0.40, -L*0.10, bodyW*0.80, L*0.16, 3); ctx.fill();
    // sidepods hint (low)
    ctx.fillStyle = 'rgba(200,200,210,0.55)';
    roundRectLocal(-W*0.60, -L*0.08, W*1.20, L*0.14, 6); ctx.fill();
    // front & rear wings extremely wide
    ctx.fillStyle = 'rgba(235,238,242,0.95)';
    roundRectLocal(-W*0.95, -L*0.48, W*1.90, L*0.06, 3); ctx.fill(); // front wing
    roundRectLocal(-W*0.75,  L*0.42,  W*1.50, L*0.06, 3); ctx.fill(); // rear wing
    // nose tip
    ctx.fillStyle = 'rgba(240,240,242,0.95)'; roundRectLocal(-bodyW*0.25, -L*0.50, bodyW*0.50, L*0.06, 3); ctx.fill();

    // Open wheels: far outboard, thin lengthwise
    const axY=L*0.30, t=W*0.85, ww=Math.max(6,W*0.34), ll=Math.max(6,L*0.18);
    wheel(-t, axY, 0, ww, ll); wheel(t, axY, 0, ww, ll);
    wheel(-t,-axY, steerAngle, ww, ll); wheel(t,-axY, steerAngle, ww, ll);
    // No body over the wheels -> silhouette reads F1 at a glance
  }

  function drawTruck(){
    // Boxy cab-over with long chassis, twin rear axles, exhaust stacks, square lights
    // Chassis
    ctx.fillStyle = gradBody(car.color || '#f97316'); // bright truck orange
    roundRectLocal(-W/2, -L*0.10, W, L*0.60, 6); ctx.fill();
    // Cab
    ctx.fillStyle = 'rgba(58,62,70,0.95)';
    roundRectLocal(-W*0.50, -L*0.48, W, L*0.34, 6); ctx.fill();
    // Grill bars
    ctx.globalAlpha = 0.28; ctx.fillStyle = '#e6e9ed';
    roundRectLocal(-W*0.42, -L*0.38, W*0.84, L*0.03, 2); ctx.fill();
    roundRectLocal(-W*0.42, -L*0.32, W*0.84, L*0.03, 2); ctx.fill();
    roundRectLocal(-W*0.42, -L*0.26, W*0.84, L*0.03, 2); ctx.fill();
    ctx.globalAlpha = 1;
    // Mirrors
    ctx.fillStyle = 'rgba(230,232,236,0.95)';
    roundRectLocal(-W*0.62, -L*0.35, W*0.10, L*0.04, 2); ctx.fill();
    roundRectLocal( W*0.52, -L*0.35, W*0.10, L*0.04, 2); ctx.fill();
    // Exhaust stacks (behind cab)
    ctx.fillStyle = 'rgba(210,214,220,0.9)';
    roundRectLocal(-W*0.44, -L*0.14, W*0.06, L*0.18, 2); ctx.fill();
    roundRectLocal( W*0.38, -L*0.14, W*0.06, L*0.18, 2); ctx.fill();
    // Square headlights
    ctx.fillStyle = '#ffe69b';
    roundRectLocal(-W*0.38, -L*0.50, W*0.14, L*0.06, 2); ctx.fill();
    roundRectLocal( W*0.24, -L*0.50, W*0.14, L*0.06, 2); ctx.fill();
    // Rear aero flap
    ctx.fillStyle = 'rgba(220,225,232,0.95)';
    roundRectLocal(-W*0.50, L*0.44, W, L*0.05, 3); ctx.fill();

    // Wheels: twin rear axles with dual wheels + single front axle
    const axF=-L*0.28, axR1=L*0.06, axR2=L*0.22, t=W*0.48;
    const wwF=Math.max(6,W*0.30), llF=Math.max(9,L*0.24);
    const wwR=Math.max(6,W*0.34), llR=Math.max(10,L*0.26);
    // Front
    wheel(-t, axF, steerAngle, wwF, llF); wheel(t, axF, steerAngle, wwF, llF);
    // Rear axle 1 (dual each side)
    wheel(-t-3, axR1, 0, wwR, llR); wheel(-t+3, axR1, 0, wwR, llR);
    wheel( t-3, axR1, 0, wwR, llR); wheel( t+3, axR1, 0, wwR, llR);
    // Rear axle 2
    wheel(-t-3, axR2, 0, wwR, llR); wheel(-t+3, axR2, 0, wwR, llR);
    wheel( t-3, axR2, 0, wwR, llR); wheel( t+3, axR2, 0, wwR, llR);
  }

  switch (car.kind){
    case 'F1':    drawF1();    break;
    case 'Truck': drawTruck(); break;
    case 'Rally': drawRally(); break;
    default:      drawGT();    break;
  }

  ctx.restore();
}


function roundRect(ctx, x, y, w, h, r){ r = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); }
          function drawBackground() {
            // Clear and reset to screen-space
            ctx.setTransform(1,0,0,1,0,0);
            ctx.fillStyle = "#184f1a"; ctx.fillRect(0, 0, W, H);

            // World-space transform: center exactly on player
            const cam = camRef.current;
            const s = cam && cam.scale ? cam.scale : 1.0;
            
            // Ensure player has valid position and track data is loaded
            if (!player || typeof player.x !== 'number' || typeof player.y !== 'number' || !trackData) {
              console.warn('Invalid player position or track not loaded yet');
              return;
            }
            
            ctx.save();
            const cw = canvasRef.current ? canvasRef.current.width : W;
            const ch = canvasRef.current ? canvasRef.current.height : H;
            ctx.translate(cw/2, ch/2);
            ctx.scale(s, s);
            const focusX = cam && typeof cam.x === "number" ? cam.x : player.x;
            const focusY = cam && typeof cam.y === "number" ? cam.y : player.y;
            ctx.translate(-focusX, -focusY);

            // Optional track-specific scenery
            if (activeTrack && activeTrack.drawScenery){ activeTrack.drawScenery(ctx, {W,H,ROAD_WIDTH,centerline,labels}); }
            // Kerbs
            if (activeTrack && activeTrack.kerbs){
              ctx.save(); ctx.lineJoin = "round"; ctx.lineCap="butt"; ctx.setLineDash([14,14]); ctx.lineWidth = ROAD_WIDTH + 14;
              ctx.strokeStyle = activeTrack.kerbColors ? activeTrack.kerbColors[0] : "#d32f2f";
              ctx.beginPath(); for (let i=0;i<centerline.length;i++){ const p=centerline[i]; if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
              ctx.strokeStyle = activeTrack.kerbColors ? activeTrack.kerbColors[1] : "#fafafa"; ctx.lineDashOffset=14;
              ctx.beginPath(); for (let i=0;i<centerline.length;i++){ const p=centerline[i]; if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); ctx.restore();
            }
            // Track ribbon
            ctx.lineJoin = "round"; ctx.lineCap = "round";
            ctx.strokeStyle = "#5f6368"; ctx.lineWidth = ROAD_WIDTH;
            ctx.beginPath();
            for (let i = 0; i < centerline.length; i++) {
              const pt = centerline[i]; if (i === 0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            // Edge highlight
            ctx.strokeStyle = "#cfd8dc"; ctx.lineWidth = 2; ctx.stroke();
            // Start line
            ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 4; ctx.beginPath();
            ctx.moveTo(startLine.a.x, startLine.a.y); ctx.lineTo(startLine.b.x, startLine.b.y); ctx.stroke();
            // checkpoints
            ctx.strokeStyle = "rgba(255,255,255,0.15)"; ctx.lineWidth = 2; for(const cp of checkpoints){ ctx.beginPath(); ctx.moveTo(cp.a.x,cp.a.y); ctx.lineTo(cp.b.x,cp.b.y); ctx.stroke(); }

            // Skids and labels
            drawSkids(ctx);
            ctx.fillStyle = "#e0f2f1"; ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
            for (const [text, x, y] of labels) ctx.fillText(text, x, y);

            // Cars
            const allCars = [player, ...aiCars];
            for (const car of allCars) drawCarDetailed(ctx, car);
            if (window.RacerPhysics) { for (const car of allCars) window.RacerPhysics.drawDebug(ctx, car); }
            ctx.restore();
          }

          function drawCar(car) {
            const corners = carCorners(car);
            const ctx = canvasRef.current.getContext("2d");
            // shadow
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            ctx.beginPath(); corners.forEach((p, i) => (i ? ctx.lineTo(p.x + 2, p.y + 2) : ctx.moveTo(p.x + 2, p.y + 2)));
            ctx.closePath(); ctx.fill();

            // body
            ctx.fillStyle = car.color;
            ctx.beginPath(); corners.forEach((p, i) => (i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)));
            ctx.closePath(); ctx.fill();

            // windshield indicator
            const nose = { x: car.x + Math.cos(car.angle) * (car.length / 2 - 2), y: car.y + Math.sin(car.angle) * (car.length / 2 - 2) };
            ctx.strokeStyle = "#fafafa"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(car.x, car.y); ctx.lineTo(nose.x, nose.y); ctx.stroke();
            ctx.restore();
          }

          function drawHUD() {
            const ctx = canvasRef.current.getContext("2d");
            ctx.save();
            // Minimal HUD: only show status if any
            if (status) {
              ctx.font = "bold 36px ui-sans-serif, system-ui"; ctx.fillStyle = "rgba(0,0,0,0.7)";
              ctx.fillRect(W / 2 - 260, H / 2 - 40, 520, 60); ctx.fillStyle = "#fff";
              ctx.fillText(status, W / 2 - ctx.measureText(status).width / 2, H / 2);
            }
            // Minimap
            if (centerline && centerline.length){
              const mw = 180, mh = 120, pad=10; const x=W-mw-pad, y=pad;
              ctx.fillStyle = "rgba(10,16,24,0.75)"; ctx.strokeStyle = "#223453"; ctx.lineWidth=1.5;
              ctx.fillRect(x,y,mw,mh); ctx.strokeRect(x,y,mw,mh);
              const bb = trackBounds || {minX:0,minY:0,w:W,h:H};
              const s = Math.min((mw-12)/bb.w, (mh-12)/bb.h);
              const ox = x + 6 - (bb.minX)*s; const oy = y + 6 - (bb.minY)*s;
              ctx.save(); ctx.beginPath(); ctx.rect(x+2,y+2,mw-4,mh-4); ctx.clip();
              ctx.lineWidth = Math.max(1, ROAD_WIDTH*0.12*s);
              ctx.strokeStyle = "#9aa5b1"; ctx.beginPath(); for (let i=0;i<centerline.length;i++){ const p=centerline[i]; const px=p.x*s+ox, py=p.y*s+oy; if(i===0)ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke();
              function dot(col, px,py){ ctx.fillStyle=col; ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.fill(); }
              dot('#e53935', player.x*s+ox, player.y*s+oy); for(const a of aiCars){ dot('#7dd3fc', a.x*s+ox, a.y*s+oy); }
              ctx.restore();
              ctx.fillStyle = "#cbd5e1"; ctx.font = "11px system-ui"; ctx.fillText(activeTrack && activeTrack.name ? activeTrack.name : trackName, x+8, y+14);
            }
            ctx.restore();
          }

          // ===== Simulation =====
          let last = performance.now();

          function updateCar(car, dt, control) {
            const rawSteer = control ? ((control.right?1:0) - (control.left?1:0)) : 0;
            // Surface detection
            const corners = carCorners(car);
            const samples = [corners[0], corners[1], corners[2], corners[3], { x: car.x, y: car.y }];
            let roadCount = 0; for (const s of samples) if (onRoad(s.x, s.y)) roadCount++;
            const onroad = roadCount >= 3;
            const prevX = car.x, prevY = car.y;

            const res = (window.RacerPhysics||{}).updateCar ? window.RacerPhysics.updateCar(
              car,
              { throttle: !!(control && control.throttle), brake: !!(control && control.brake), steer: rawSteer },
              { onRoad: onroad },
              dt
            ) : null;

            // Skid marks
            const skidAmount = res && typeof res.skid === 'number' ? res.skid : 0;
            if (skidAmount > 0.28){
              const wp = window.RacerPhysics ? window.RacerPhysics.wheelPositions(car) : null;
              if (wp){
                if (car.skidLPrev && car.skidRPrev){
                  addSkid(car.skidLPrev.x, car.skidLPrev.y, wp.left.x, wp.left.y);
                  addSkid(car.skidRPrev.x, car.skidRPrev.y, wp.right.x, wp.right.y);
                }
                car.skidLPrev = wp.left; car.skidRPrev = wp.right;
              }
            } else { car.skidLPrev = null; car.skidRPrev = null; }

            // Lap counting
            const now = performance.now();
            if (now - car.lastCross > 800) {
              if (segIntersect({x: prevX, y: prevY}, { x: car.x, y: car.y }, startLine.a, startLine.b)) {
                car.lap += 1; car.lastCross = now;
                const lapTime = (now - car.lapStart) / 1000;
                car.bestLap = car.bestLap ? Math.min(car.bestLap, lapTime) : lapTime; car.lapStart = now;
              }
            }
          }

          function updateAI(dt) {
            for (const car of aiCars) {
              const target = waypoints[car.targetIndex]; if (!target) continue;
              const dx = target.x - car.x, dy = target.y - car.y;
              const targetAngle = Math.atan2(dy, dx);
              let da = normalizeAngle(targetAngle - car.angle);
              const steer = Math.max(-1, Math.min(1, da));
              const control = { throttle: car.speed < (target.speed + car.speedBias), brake: car.speed > (target.speed + car.speedBias + 20),
                                left: steer < -0.03, right: steer > 0.03 };
              updateCar(car, dt, control);
              const dist = Math.hypot(dx, dy); if (dist < 40) car.targetIndex = loopIndex(car.targetIndex + 1, waypoints.length);
            }
          }

          function updatePlayer(dt) {
            const control = { throttle: keys.w, brake: keys.s, left: keys.a, right: keys.d };
            updateCar(player, dt, control);
          }

          // ===== Collisions (pairwise among all cars) =====
          function handleCollisions() {
            const all = [player, ...aiCars];
            for (let i = 0; i < all.length; i++) {
              for (let j = i+1; j < all.length; j++) {
                const a = all[i], b = all[j];
                const ra = Math.hypot((a.length||36)/2, (a.width||18)/2);
                const rb = Math.hypot((b.length||36)/2, (b.width||18)/2);
                const dx = b.x - a.x, dy = b.y - a.y;
                const dist = Math.hypot(dx, dy) || 1e-6;
                const minDist = ra + rb;
                if (dist < minDist) {
                  const nx = dx / dist, ny = dy / dist;
                  const overlap = (minDist - dist);
                  const ma = (a.physics && a.physics.params && a.physics.params.mass) || 1.0;
                  const mb = (b.physics && b.physics.params && b.physics.params.mass) || 1.0;
                  const invSum = 1 / (ma + mb);
                  a.x -= nx * overlap * (mb * invSum);
                  a.y -= ny * overlap * (mb * invSum);
                  b.x += nx * overlap * (ma * invSum);
                  b.y += ny * overlap * (ma * invSum);

                  const vax = (a.physics ? a.physics.vx : (Math.cos(a.angle)*a.speed + a.vx));
                  const vay = (a.physics ? a.physics.vy : (Math.sin(a.angle)*a.speed + a.vy));
                  const vbx = (b.physics ? b.physics.vx : (Math.cos(b.angle)*b.speed + b.vx));
                  const vby = (b.physics ? b.physics.vy : (Math.sin(b.angle)*b.speed + b.vy));
                  const rvx = vbx - vax, rvy = vby - vay;
                  const relNorm = rvx * nx + rvy * ny;
                  if (relNorm < 0) {
                    const e = 0.45;
                    const j = -(1 + e) * relNorm / (1/ma + 1/mb);
                    const jx = j * nx, jy = j * ny;
                    if (a.physics){ a.physics.vx -= jx / ma; a.physics.vy -= jy / ma; a.vx = a.physics.vx; a.vy = a.physics.vy; }
                    else { a.vx -= jx / ma; a.vy -= jy / ma; }
                    if (b.physics){ b.physics.vx += jx / mb; b.physics.vy += jy / mb; b.vx = b.physics.vx; b.vy = b.physics.vy; }
                    else { b.vx += jx / mb; b.vy += jy / mb; }
                    const impact = Math.min(1, Math.abs(j) * 0.003);
                    if (a===player || b===player) { player.sfxImpact = Math.max(player.sfxImpact||0, impact); }
                  }
                }
              }
            }
          }

          // ===== Input =====
          function key(e, down) {
            const k = e.key.toLowerCase();
            if (k === "w") keys.w = down;
            if (k === "s") keys.s = down;
            if (k === "a") keys.a = down;
            if (k === "d") keys.d = down;
            if (down && (k === "r" || k === "enter")) loadTrack(trackName); // restart current track
            if (down && k === " ") setRunning((r) => !r);
            if (down && k === "t") {
              const next = trackName === "Silverstone" ? "Le Mans" : "Silverstone";
              setTrackName(next); setTimeout(() => loadTrack(next), 0);
            }
            if (down) { try { const a = ensureAudio(); if (a && a.ctx.state==='suspended') a.ctx.resume(); } catch(_){} }
            if (down && k === 'm') toggleSFX();
            if (down && k === "1") { setTrackName("Silverstone"); setTimeout(() => loadTrack("Silverstone"), 0); }
            if (down && k === "2") { setTrackName("Le Mans"); setTimeout(() => loadTrack("Le Mans"), 0); }
            if (down && (k === "+" || k === "=")) {
              GEO_SCALE = clampScale(GEO_SCALE + SCALE_STEP);
              writeScale('geoScale', GEO_SCALE);
              setGeoScaleInput(GEO_SCALE);
              loadTrack(trackName);
            }
            if (down && (k === "-" || k === "_")) {
              GEO_SCALE = clampScale(GEO_SCALE - SCALE_STEP);
              writeScale('geoScale', GEO_SCALE);
              setGeoScaleInput(GEO_SCALE);
              loadTrack(trackName);
            }
            // Gyro removed
          }
          const kd = (e) => key(e, true), ku = (e) => key(e, false);
          window.addEventListener("keydown", kd);
          window.addEventListener("keyup", ku);

          // Touch HUD bindings
          function bindTouchButton(el, onDown, onUp){ if(!el) return; const d=(e)=>{ e.preventDefault(); onDown(); try{ const a=ensureAudio(); if(a&&a.ctx.state==='suspended') a.ctx.resume(); }catch{} }; const u=(e)=>{ e.preventDefault(); onUp(); }; el.addEventListener('touchstart', d, {passive:false}); el.addEventListener('touchend', u, {passive:false}); el.addEventListener('touchcancel', u, {passive:false}); el.addEventListener('mousedown', d); el.addEventListener('mouseup', u); el.addEventListener('mouseleave', u); }
          const hud = document.querySelector('.hud');
          if (hud){
            bindTouchButton(hud.querySelector('.btn.left'),  ()=>keys.a=true, ()=>keys.a=false);
            bindTouchButton(hud.querySelector('.btn.right'), ()=>keys.d=true, ()=>keys.d=false);
            bindTouchButton(hud.querySelector('.btn.thr'),   ()=>keys.w=true, ()=>keys.w=false);
            bindTouchButton(hud.querySelector('.btn.brk'),   ()=>keys.s=true, ()=>keys.s=false);
            // Gyro button removed
          }

          // Motion steering removed
          // Optional: keep the screen awake during play (Android Chrome)
          let wakeLock = null;
          async function enableWakeLock(){
            try { if ('wakeLock' in navigator) { wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>{}); } } catch(_){}
          }
          window.addEventListener('pointerdown', ()=>{ try{ const a=ensureAudio(); if(a&&a.ctx.state==='suspended') a.ctx.resume(); }catch{} enableWakeLock(); }, { once:true });
          document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible' && wakeLock && wakeLock.released){ enableWakeLock(); } });
          // Pause when tab/app is hidden
          document.addEventListener('visibilitychange', ()=>{ if (document.hidden) setRunning(false); });

          function frame(t) {
            const dt = Math.min(0.05, (t - last) / 1000); last = t;
            if (running) {
              updatePlayer(dt); updateAI(dt);
              handleCollisions();
              if (!status && (player.lap >= 3)) {
                setStatus("3 laps done! Press R to restart");
                setRunning(false);
              }
            }
            const cam = camRef.current;
            if (cam && player && typeof player.x === 'number' && typeof player.y === 'number') {
              cam.targetX = player.x;
              cam.targetY = player.y;
            }
            const spd = Math.abs(player.speed || 0);
            const minZoom = 0.70, maxZoom = 1.10;
            if (cam) {
              cam.targetScale = Math.max(minZoom, Math.min(maxZoom, 1.0 - Math.min(0.35, spd / 1200)));
              cam.scale += (cam.targetScale - cam.scale) * Math.min(1, dt * 4);
              if (typeof cam.targetX === "number" && typeof cam.targetY === "number") {
                const canvasNode = canvasRef.current;
                const cw = canvasNode ? canvasNode.width : W;
                const ch = canvasNode ? canvasNode.height : H;
                const s = cam.scale || 1;
                const viewW = cw / s;
                const viewH = ch / s;
                const halfViewW = viewW / 2;
                const halfViewH = viewH / 2;
                if (W > viewW) {
                  cam.x = clamp(cam.targetX, halfViewW, W - halfViewW);
                } else {
                  cam.x = cam.targetX;
                }
                if (H > viewH) {
                  cam.y = clamp(cam.targetY, halfViewH, H - halfViewH);
                } else {
                  cam.y = cam.targetY;
                }
              }
            }

            updateSFX(player, dt); updateSkids(dt);
            drawBackground(); drawHUD();
            requestAnimationFrame(frame);
          }
          // initial track first, then start animation to ensure camera is centered
          loadTrack(trackName);
          camInitRef.current = true; // ensure camera is initialized
          requestAnimationFrame(frame);
          try { if (window.RacerPhysics) window.RacerPhysics.injectDevTools(()=>({ player, ai: aiCars })); } catch(_){}

          return () => {
            window.removeEventListener("keydown", kd);
            window.removeEventListener("keyup", ku);
            loadTrackRef.current = () => {};
          };
        }, [trackName]);

        return (
          <div className="wrap">
            {hudTip ? <div className="hud-tip">{hudTip}</div> : null}
            <button
              type="button"
              className="dev-toggle"
              onClick={() => setDevPanelOpen(open => !open)}
              aria-pressed={devPanelOpen}
            >
              {devPanelOpen ? "Hide scales" : "Scales"}
            </button>
            <div className={`dev-panel ${devPanelOpen ? "open" : ""}`}>
              <h3>Track scale</h3>
              <label>
                <span>Geo scale</span>
                <div className="field">
                  <input
                    type="range"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={geoScaleInput}
                    onChange={(e) => applyGeoScaleChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={geoScaleInput.toFixed(2)}
                    onChange={(e) => applyGeoScaleChange(e.target.value)}
                  />
                </div>
              </label>
              <label>
                <span>Width scale</span>
                <div className="field">
                  <input
                    type="range"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={widthScaleInput}
                    onChange={(e) => applyWidthScaleChange(e.target.value)}
                  />
                  <input
                    type="number"
                    min={SCALE_MIN}
                    max={SCALE_MAX}
                    step={SCALE_STEP}
                    value={widthScaleInput.toFixed(2)}
                    onChange={(e) => applyWidthScaleChange(e.target.value)}
                  />
                </div>
              </label>
            </div>
            <canvas ref={canvasRef} width="1000" height="700"></canvas>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<TopDownRacer />);
    </script>
    <script>
      // Register service worker only on http(s)
      if ('serviceWorker' in navigator && /^https?:$/i.test(location.protocol)) {
        window.addEventListener('load', function(){
          navigator.serviceWorker.register('service-worker.js').catch(function(e){ console.warn('SW reg failed', e); });
        });
      }
    </script>
  </body>
</html>
